<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OBS Ticker Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #04060e;
      --bg-accent: #080b17;
      --panel: rgba(14, 18, 32, 0.9);
      --panel-border: rgba(92, 104, 152, 0.28);
      --panel-highlight: rgba(124, 92, 255, 0.42);
      --muted: rgba(22, 26, 40, 0.92);
      --text: #f5f7ff;
      --subtle: #9da6c4;
      --accent: #7c5cff;
      --accent-strong: #8a7fff;
      --accent-soft: rgba(124, 92, 255, 0.16);
      --success: #3ddc97;
      --danger: #ff6b6b;
      --danger-soft: rgba(255, 107, 107, 0.18);
      --radius: 18px;
      --shadow: 0 22px 55px rgba(5, 8, 22, 0.55);
      --shadow-soft: 0 16px 38px rgba(5, 8, 22, 0.45);
      --pill-bg: rgba(34, 40, 60, 0.85);
      --input-bg: rgba(14, 18, 28, 0.88);
      --input-border: rgba(102, 119, 163, 0.28);
      --chip-bg: rgba(54, 62, 92, 0.55);
      --chip-border: rgba(116, 132, 188, 0.35);
      --toast-bg: rgba(18, 22, 34, 0.94);
    }

    *, *::before, *::after { box-sizing: border-box; }

    html, body { height: 100%; }

    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      background:
        radial-gradient(1400px 900px at -10% -20%, rgba(132, 96, 255, 0.22), transparent),
        radial-gradient(1200px 700px at 120% 0%, rgba(47, 103, 255, 0.18), transparent),
        linear-gradient(160deg, var(--bg) 0%, var(--bg-accent) 55%, #02030a 100%);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      padding: 48px 20px 64px;
    }

    .app { max-width: 1080px; margin: 0 auto; display: flex; flex-direction: column; gap: 24px; }

    .panel {
      background: linear-gradient(170deg, rgba(255, 255, 255, 0.02), transparent 30%) var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(20px);
      padding: 28px 32px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .header {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      justify-content: space-between;
      gap: 18px;
    }

    .title-block { display: flex; flex-direction: column; gap: 8px; max-width: 620px; }
    h1 { font-size: 30px; font-weight: 700; margin: 0; letter-spacing: 0.3px; }
    .subtitle { color: var(--subtle); font-size: 15px; line-height: 1.5; margin: 0; }

    .overlay-chip {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      border-radius: 14px;
      background: var(--chip-bg);
      border: 1px solid var(--chip-border);
      max-width: 360px;
      font-size: 12px;
      color: var(--subtle);
      word-break: break-all;
    }
    .overlay-chip strong { color: var(--text); font-weight: 600; }

    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 14px;
    }

    .status-card {
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: rgba(20, 24, 36, 0.9);
      border: 1px solid rgba(118, 136, 190, 0.18);
      border-radius: var(--radius);
      padding: 18px;
    }

    .status-item { display: flex; align-items: center; gap: 10px; font-size: 13px; color: var(--subtle); }
    .status-dot {
      width: 10px; height: 10px; border-radius: 50%;
      background: rgba(149, 160, 196, 0.5);
      box-shadow: 0 0 0 0 rgba(61, 220, 151, 0.25);
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }
    .status-dot.active { background: var(--success); box-shadow: 0 0 0 4px rgba(61, 220, 151, 0.22); }
    .status-value { color: var(--text); font-weight: 600; }

    .grid-two {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 24px;
    }

    .section-title { font-size: 18px; font-weight: 600; letter-spacing: 0.2px; }
    .section-sub { font-size: 13px; color: rgba(201, 208, 230, 0.75); }

    .control-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 16px; }
    .control-group { display: flex; flex-direction: column; gap: 10px; }

    label { font-size: 13px; color: var(--subtle); font-weight: 500; letter-spacing: 0.2px; }
    input[type="number"], input[type="text"] {
      width: 100%;
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: 12px;
      padding: 11px 13px;
      font-size: 14px;
      outline: none;
      transition: border 0.15s ease, box-shadow 0.15s ease, transform 0.15s ease;
      box-shadow: 0 10px 24px rgba(5, 7, 16, 0.32);
    }
    input[type="number"]:focus, input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px rgba(124, 92, 255, 0.25);
      transform: translateY(-1px);
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(84, 96, 138, 0.45);
      border: 1px solid rgba(118, 134, 189, 0.4);
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 18px; height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      box-shadow: 0 8px 20px rgba(124, 92, 255, 0.35);
      border: none;
      cursor: pointer;
    }
    input[type="range"]::-moz-range-thumb {
      width: 18px; height: 18px; border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      border: none; cursor: pointer;
    }

    .segment-row { display: flex; flex-wrap: wrap; gap: 8px; }
    .segment-button {
      appearance: none;
      border: 1px solid rgba(118, 134, 189, 0.4);
      border-radius: 999px;
      padding: 7px 14px;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.2px;
      background: rgba(48, 56, 86, 0.4);
      color: rgba(220, 226, 255, 0.88);
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, border 0.15s ease, background 0.15s ease;
    }
    .segment-button:hover { transform: translateY(-1px); box-shadow: 0 10px 22px rgba(18, 22, 34, 0.42); }
    .segment-button.is-active {
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      border-color: transparent;
      color: #fff;
      box-shadow: 0 14px 30px rgba(124, 92, 255, 0.35);
    }

    .toggle-row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .toggle-row label { display: flex; align-items: center; gap: 8px; cursor: pointer; }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .actions .spacer { flex: 1; }

    .btn {
      appearance: none;
      border: none;
      border-radius: 12px;
      padding: 11px 16px;
      font-weight: 600;
      cursor: pointer;
      color: #fff;
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      transition: transform 0.14s ease, box-shadow 0.14s ease, filter 0.14s ease;
      font-size: 14px;
      letter-spacing: 0.2px;
      box-shadow: 0 14px 30px rgba(124, 92, 255, 0.28);
    }
    .btn:hover { transform: translateY(-1px); filter: brightness(1.05); }
    .btn:active { transform: translateY(1px); }
    .btn-secondary { background: rgba(54, 62, 92, 0.9); color: #f3f4ff; box-shadow: none; }
    .btn-secondary:hover { box-shadow: 0 12px 26px rgba(32, 38, 60, 0.4); }
    .btn-ghost { background: rgba(255, 255, 255, 0.04); color: var(--subtle); box-shadow: none; border: 1px dashed rgba(118, 134, 189, 0.35); }
    .btn-ghost:hover { filter: none; transform: none; border-color: var(--accent); color: #fff; }
    .btn-danger { background: linear-gradient(135deg, var(--danger), #ff856b); box-shadow: 0 14px 26px rgba(255, 107, 107, 0.32); }
    .btn-success { background: linear-gradient(135deg, var(--success), #23c485); color: #04160f; box-shadow: 0 14px 26px rgba(61, 220, 151, 0.32); }

    .message-composer { display: flex; flex-wrap: wrap; gap: 12px; }
    .message-composer input { flex: 1; }
    .hint-row { font-size: 12px; color: rgba(201, 208, 230, 0.7); display: flex; flex-wrap: wrap; gap: 10px; }
    .hint-row code { background: rgba(44, 50, 72, 0.7); padding: 2px 6px; border-radius: 6px; font-size: 12px; color: #f0f4ff; }

    .message-list {
      display: flex;
      flex-direction: column;
      border: 1px solid rgba(118, 134, 189, 0.25);
      border-radius: 14px;
      overflow: hidden;
      background: rgba(10, 14, 24, 0.85);
    }
    .message-item {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 14px;
      align-items: center;
      padding: 14px 16px;
      border-bottom: 1px solid rgba(118, 134, 189, 0.18);
    }
    .message-item:last-child { border-bottom: none; }
    .message-preview { font-size: 15px; line-height: 1.4; color: #e7ebff; }
    .message-actions { display: flex; gap: 8px; }
    .message-actions button {
      appearance: none;
      border: none;
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      color: #f3f4ff;
      background: rgba(54, 62, 92, 0.9);
      transition: transform 0.14s ease, box-shadow 0.14s ease;
    }
    .message-actions button:hover { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(18, 22, 34, 0.4); }
    .message-actions button[data-action="delete"] { background: rgba(255, 107, 107, 0.12); color: #ff9696; }

    .empty-state { padding: 24px; text-align: center; color: rgba(201, 208, 230, 0.7); font-size: 14px; }

    .preset-header { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .preset-header input { max-width: 240px; }
    .preset-list { display: flex; flex-direction: column; gap: 12px; }
    .preset-card {
      border: 1px solid rgba(118, 134, 189, 0.25);
      border-radius: 12px;
      padding: 16px;
      background: rgba(18, 22, 34, 0.82);
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 14px;
      align-items: center;
    }
    .preset-title { font-weight: 600; font-size: 15px; color: #f6f7ff; }
    .preset-meta { font-size: 12px; color: rgba(201, 208, 230, 0.65); margin-top: 4px; }
    .preset-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .preset-actions button { border-radius: 10px; padding: 7px 12px; font-size: 12px; font-weight: 600; border: none; cursor: pointer; background: rgba(54, 62, 92, 0.9); color: #eef1ff; }
    .preset-actions button:hover { transform: translateY(-1px); box-shadow: 0 10px 22px rgba(18, 22, 34, 0.4); }
    .preset-actions button[data-action="delete"] { background: rgba(255, 107, 107, 0.14); color: #ff8e8e; }

    .toast {
      position: fixed;
      left: 24px;
      bottom: 24px;
      background: var(--toast-bg);
      border: 1px solid rgba(118, 134, 189, 0.35);
      color: #fff;
      padding: 12px 16px;
      border-radius: 12px;
      opacity: 0;
      transform: translateY(12px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: none;
      font-size: 13px;
      box-shadow: 0 14px 30px rgba(5, 8, 22, 0.45);
    }
    .toast.show { opacity: 1; transform: translateY(0); }

    .fx { display: inline-flex; position: relative; }
    .fx-letter { display: inline-block; --i: 0; will-change: transform, filter; }
    .fx.fx-sparkle { animation: gentlePulse 5.6s ease-in-out infinite; }
    .fx-rainbow .fx-letter {
      background-image: linear-gradient(90deg, #ff007a, #ff4d00, #ffe600, #2dff7a, #00f0ff, #7f66ff, #ff4ef0, #ff007a);
      background-size: 320% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: rainbowShift 3.4s linear infinite, subtleFloat 1.8s ease-in-out infinite;
      animation-delay: calc(var(--i) * -0.12s), calc(var(--i) * 0.07s);
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.18);
      filter: saturate(1.25) brightness(1.08);
    }
    .fx-sparkle .fx-letter {
      background-image:
        radial-gradient(circle at 30% 60%, rgba(255, 255, 255, 0.95) 0 12%, transparent 28%),
        radial-gradient(circle at 70% 40%, rgba(255, 255, 255, 0.65) 0 10%, transparent 30%),
        radial-gradient(circle at 50% 10%, rgba(255, 255, 255, 0.45) 0 8%, transparent 26%),
        linear-gradient(90deg, #ff007a, #ff4d00, #ffe600, #2dff7a, #00f0ff, #7f66ff, #ff4ef0, #ff007a);
      background-size: 180% 180%, 220% 220%, 200% 200%, 360% 100%;
      background-position: 0% 0%, 100% 100%, 50% 0%, 0% 0%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: sparkleShift 3.6s linear infinite, subtleFloat 1.9s ease-in-out infinite;
      animation-delay: calc(var(--i) * -0.1s), calc(var(--i) * 0.08s);
      text-shadow: 0 0 12px rgba(255, 255, 255, 0.22);
      filter: saturate(1.35) contrast(1.08);
    }
    .fx-bounce {
      display: inline-block;
      animation: enhancedBounce 1.9s ease-in-out infinite;
      transform-origin: center bottom;
      will-change: transform;
    }
    .fx-neon {
      color: #bfe2ff;
      text-shadow:
        0 0 3px rgba(100, 181, 246, 0.8),
        0 0 10px rgba(100, 181, 246, 0.65),
        0 0 18px rgba(100, 181, 246, 0.4);
      animation: neonFlicker 2.8s ease-in-out infinite, gentlePulse 4.6s ease-in-out infinite;
    }
    .fx-glitch {
      color: #f6f7ff;
      position: relative;
      text-shadow: -1px 0 rgba(255, 0, 128, 0.6), 1px 0 rgba(0, 255, 255, 0.55);
      animation: dataGlitch 1.9s steps(2, end) infinite;
    }

    .highlight { color: #fbbf24; font-weight: 600; }
    strong { font-weight: 700; }
    em { font-style: italic; }

    @keyframes rainbowShift {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }
    @keyframes sparkleShift {
      0% { background-position: 0% 0%, 100% 100%, 50% 0%, 0% 0%; }
      25% { background-position: 50% 50%, 0% 0%, 100% 50%, 50% 50%; }
      50% { background-position: 100% 100%, 50% 50%, 0% 100%, 100% 100%; }
      75% { background-position: 50% 0%, 100% 0%, 50% 50%, 150% 50%; }
      100% { background-position: 0% 0%, 100% 100%, 50% 0%, 200% 0%; }
    }
    @keyframes subtleFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-1px); }
    }
    @keyframes gentlePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
    @keyframes enhancedBounce {
      0%, 100% { transform: translateY(0) scale(1); }
      30% { transform: translateY(-4px) scale(1.05, 0.95); }
      50% { transform: translateY(-6px) scale(1.08, 0.92); }
      70% { transform: translateY(-2px) scale(1.02, 0.98); }
    }
    @keyframes neonFlicker {
      0%, 100% {
        text-shadow:
          0 0 2px rgba(100, 181, 246, 0.8),
          0 0 8px rgba(100, 181, 246, 0.6),
          0 0 16px rgba(100, 181, 246, 0.4),
          0 0 24px rgba(100, 181, 246, 0.2);
      }
      50% {
        text-shadow:
          0 0 4px rgba(100, 181, 246, 1),
          0 0 12px rgba(100, 181, 246, 0.8),
          0 0 20px rgba(100, 181, 246, 0.6),
          0 0 32px rgba(100, 181, 246, 0.3);
      }
    }
    @keyframes dataGlitch {
      0%, 100% { transform: translate(0); filter: hue-rotate(0deg); }
      10% { transform: translate(-1px, 1px); filter: hue-rotate(-6deg); }
      20% { transform: translate(1px, -1px); filter: hue-rotate(8deg); }
      35% { transform: translate(-2px, 0); filter: hue-rotate(-12deg); }
      50% { transform: translate(0, 1px); filter: hue-rotate(6deg); }
      65% { transform: translate(2px, -1px); filter: hue-rotate(-4deg); }
      80% { transform: translate(-1px, 0); filter: hue-rotate(10deg); }
      90% { transform: translate(1px, -1px); filter: hue-rotate(-8deg); }
    }

    @media (max-width: 960px) {
      body { padding: 32px 16px 48px; }
      .panel { padding: 24px; }
    }

    @media (max-width: 640px) {
      .message-item { grid-template-columns: 1fr; }
      .message-actions { justify-content: flex-end; }
      .preset-card { grid-template-columns: 1fr; }
      .preset-actions { justify-content: flex-end; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <div class="header">
        <div class="title-block">
          <h1>OBS Ticker Dashboard</h1>
          <p class="subtitle">Curate ticker copy, configure overlay styling, and manage presets in one place. Minutes-based intervals and rich text modifiers are supported.</p>
        </div>
        <div class="overlay-chip" title="Click to copy" id="overlayUrlChip">
          <strong>Overlay URL</strong>
          <span id="overlayUrlText">–</span>
        </div>
      </div>

      <div class="status-grid">
        <div class="status-card">
          <div class="status-item"><span class="status-dot" id="statusActive"></span><span>State</span><span class="status-value" id="statusActiveText">Inactive</span></div>
          <div class="status-item"><span>Messages</span><span class="status-value" id="statusMessageCount">0</span></div>
        </div>
        <div class="status-card">
          <div class="status-item"><span>Last Update</span><span class="status-value" id="statusUpdated">–</span></div>
          <div class="status-item"><span>Server</span><span class="status-value" id="statusServer">Checking…</span></div>
        </div>
        <div class="status-card">
          <div class="status-item" style="flex-wrap: wrap; gap: 6px;">
            <span>Server URL</span>
            <input type="text" id="serverUrl" placeholder="http://127.0.0.1:3000" style="flex:1; min-width: 160px;" />
          </div>
          <div class="status-item"><label><input type="checkbox" id="autoStart" /> Auto-start when messages exist</label></div>
        </div>
      </div>
    </div>

    <div class="grid-two">
      <section class="panel" id="tickerPanel">
        <div>
          <div class="section-title">Ticker Timing</div>
          <div class="section-sub">Control rotation and cooldown cadence. Intervals are stored in minutes (0–60) and converted server-side.</div>
        </div>
        <div class="control-grid">
          <div class="control-group">
            <label for="displayDuration">Display Duration (seconds)</label>
            <input type="number" id="displayDuration" min="2" max="90" step="1" value="5" />
          </div>
          <div class="control-group">
            <label for="intervalMinutes">Interval Between Messages (minutes)</label>
            <input type="number" id="intervalMinutes" min="0" max="60" step="0.1" value="0" />
          </div>
        </div>
        <div class="actions">
          <button class="btn btn-success" id="startBtn">Start</button>
          <button class="btn btn-danger" id="stopBtn">Stop</button>
          <div class="spacer"></div>
          <button class="btn btn-secondary" id="refreshBtn">Refresh</button>
        </div>
      </section>

      <section class="panel" id="overlayPanel">
        <div>
          <div class="section-title">Overlay Styling</div>
          <div class="section-sub">Adjust label, highlights, animation preferences, and scale for the browser source preview.</div>
        </div>
        <div class="control-grid">
          <div class="control-group">
            <label for="overlayLabel">Overlay Label</label>
            <input type="text" id="overlayLabel" maxlength="32" />
          </div>
          <div class="control-group">
            <label for="overlayAccent">Accent Colour</label>
            <input type="text" id="overlayAccent" placeholder="#ef4444" />
          </div>
          <div class="control-group">
            <label for="highlightWords">Highlight Words (comma separated)</label>
            <input type="text" id="highlightWords" placeholder="YouTube,Twitch,breaking" />
          </div>
        </div>
        <div class="control-group">
          <label for="scaleRange">Overlay Scale</label>
          <div class="segment-row" style="flex-wrap: nowrap; gap: 12px; align-items: center;">
            <input type="range" id="scaleRange" min="0.75" max="2.5" step="0.05" value="1.75" />
            <input type="number" id="scaleNumber" min="0.75" max="2.5" step="0.05" value="1.75" style="max-width: 90px;" />
          </div>
        </div>
        <div class="control-group">
          <label>Position</label>
          <div class="segment-row" id="positionButtons">
            <button type="button" class="segment-button" data-position="bottom">Bottom</button>
            <button type="button" class="segment-button" data-position="top">Top</button>
          </div>
        </div>
        <div class="control-group">
          <label>Animation Mode</label>
          <div class="segment-row" id="modeButtons">
            <button type="button" class="segment-button" data-mode="auto">Auto</button>
            <button type="button" class="segment-button" data-mode="marquee">Marquee</button>
            <button type="button" class="segment-button" data-mode="chunk">Chunk</button>
          </div>
        </div>
        <div class="toggle-row">
          <label><input type="checkbox" id="accentAnimToggle" checked /> Accent shimmer</label>
          <label><input type="checkbox" id="sparkleToggle" checked /> Sparkle effects</label>
        </div>
        <div class="actions">
          <button class="btn btn-secondary" id="openOverlay">Open Preview</button>
          <button class="btn btn-ghost" id="copyOverlay">Copy URL</button>
        </div>
      </section>
    </div>

    <section class="panel" id="messagesPanel">
      <div>
        <div class="section-title">Ticker Messages</div>
        <div class="section-sub">Use modifiers like <code>~~rainbow~~</code>, <code>%%spark%%</code>, <code>^^bounce^^</code>, <code>==neon==</code>, and <code>!!glitch!!</code>. Markdown-style <code>**bold**</code> and <code>*italic*</code> are supported.</div>
      </div>
      <form class="message-composer" id="messageForm">
        <input type="text" id="newMessage" placeholder="Add a ticker message…" autocomplete="off" />
        <button type="submit" class="btn">Add</button>
        <button type="button" class="btn btn-secondary" id="clearMessages">Clear</button>
        <button type="button" class="btn btn-ghost" id="exportMessages">Export</button>
        <button type="button" class="btn btn-ghost" id="importMessages">Import</button>
      </form>
      <div class="message-list" id="messageList">
        <div class="empty-state">No messages yet — add a line above or load a preset.</div>
      </div>
    </section>

    <section class="panel" id="presetsPanel">
      <div>
        <div class="section-title">Message Presets</div>
        <div class="section-sub">Save frequently used rotations. Loading replaces the current queue; appending pushes messages to the bottom.</div>
      </div>
      <div class="preset-header">
        <input type="text" id="presetName" placeholder="Preset name" />
        <button class="btn" type="button" id="savePreset">Save Current Messages</button>
      </div>
      <div class="preset-list" id="presetList">
        <div class="empty-state">No presets saved yet.</div>
      </div>
    </section>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    const STORAGE_KEY = 'ticker-dashboard-v3';
    const DEFAULT_OVERLAY = {
      label: 'LIVE',
      accent: '#ef4444',
      highlight: 'YouTube,Twitch,Discord,Patreon,breaking,update,tonight,today',
      scale: 1.75,
      position: 'bottom',
      mode: 'auto',
      accentAnim: true,
      sparkle: true
    };

    const DEFAULT_STATE = {
      isActive: false,
      messages: [],
      displayDuration: 5,
      intervalMinutes: 0,
      updatedAt: null
    };

    const SPECIAL_MAP = {
      '~~': 'rainbow',
      '%%': 'sparkle',
      '^^': 'bounce',
      '==': 'neon',
      '!!': 'glitch'
    };

    const DEFAULT_HIGHLIGHTS = ['live', 'breaking', 'alert', 'update', 'tonight', 'today'];

    let state = { ...DEFAULT_STATE };
    let overlayPrefs = { ...DEFAULT_OVERLAY };
    let presets = [];

    const el = {
      overlayChip: document.getElementById('overlayUrlChip'),
      overlayText: document.getElementById('overlayUrlText'),
      serverUrl: document.getElementById('serverUrl'),
      statusServer: document.getElementById('statusServer'),
      statusActive: document.getElementById('statusActive'),
      statusActiveText: document.getElementById('statusActiveText'),
      statusCount: document.getElementById('statusMessageCount'),
      statusUpdated: document.getElementById('statusUpdated'),
      autoStart: document.getElementById('autoStart'),
      duration: document.getElementById('displayDuration'),
      interval: document.getElementById('intervalMinutes'),
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      refreshBtn: document.getElementById('refreshBtn'),
      overlayLabel: document.getElementById('overlayLabel'),
      overlayAccent: document.getElementById('overlayAccent'),
      highlightWords: document.getElementById('highlightWords'),
      scaleRange: document.getElementById('scaleRange'),
      scaleNumber: document.getElementById('scaleNumber'),
      positionButtons: document.getElementById('positionButtons'),
      modeButtons: document.getElementById('modeButtons'),
      accentAnim: document.getElementById('accentAnimToggle'),
      sparkle: document.getElementById('sparkleToggle'),
      openOverlay: document.getElementById('openOverlay'),
      copyOverlay: document.getElementById('copyOverlay'),
      messageForm: document.getElementById('messageForm'),
      newMessage: document.getElementById('newMessage'),
      clearMessages: document.getElementById('clearMessages'),
      exportMessages: document.getElementById('exportMessages'),
      importMessages: document.getElementById('importMessages'),
      messageList: document.getElementById('messageList'),
      presetName: document.getElementById('presetName'),
      savePreset: document.getElementById('savePreset'),
      presetList: document.getElementById('presetList'),
      toast: document.getElementById('toast')
    };

    let fetchInFlight = false;
    let saveTimer = null;
    let overlaySaveTimer = null;
    let overlaySaveInFlight = false;
    let highlightRegex = null;

    function toast(message) {
      el.toast.textContent = message;
      el.toast.classList.add('show');
      clearTimeout(el.toast._hideTimer);
      el.toast._hideTimer = setTimeout(() => el.toast.classList.remove('show'), 1800);
    }

    function serverBase() {
      const value = (el.serverUrl.value || 'http://127.0.0.1:3000').trim();
      return value.replace(/\/?$/, '');
    }

    function secondsToMinutes(seconds) {
      return Math.max(0, Math.min(60, Math.round((Number(seconds) || 0) * 100 / 60) / 100));
    }

    function minutesToSeconds(minutes) {
      const numeric = Number(minutes);
      if (!Number.isFinite(numeric)) return 0;
      return Math.max(0, Math.min(3600, Math.round(numeric * 60)));
    }

    function normaliseHighlightInput(value) {
      return String(value || '')
        .split(',')
        .map(part => part.trim())
        .filter(Boolean)
        .join(',');
    }

    function normaliseOverlayData(data) {
      const result = { ...DEFAULT_OVERLAY };
      if (!data || typeof data !== 'object') return result;
      if (typeof data.label === 'string' && data.label.trim()) {
        result.label = data.label.trim().slice(0, 48);
      }
      if (typeof data.accent === 'string') {
        result.accent = data.accent.trim().slice(0, 48);
      }
      if (typeof data.highlight === 'string') {
        result.highlight = normaliseHighlightInput(data.highlight);
      }
      if (Number.isFinite(data.scale)) {
        const numeric = Number(data.scale);
        result.scale = Math.max(0.75, Math.min(2.5, Math.round(numeric * 100) / 100));
      }
      if (typeof data.position === 'string') {
        const pos = data.position.toLowerCase();
        if (pos === 'top' || pos === 'bottom') result.position = pos;
      }
      if (typeof data.mode === 'string') {
        const mode = data.mode.toLowerCase();
        if (['auto', 'marquee', 'chunk'].includes(mode)) result.mode = mode;
      }
      if (typeof data.accentAnim === 'boolean') {
        result.accentAnim = data.accentAnim;
      }
      if (typeof data.sparkle === 'boolean') {
        result.sparkle = data.sparkle;
      }
      return result;
    }

    function updateHighlightRegex() {
      const custom = (overlayPrefs.highlight || '')
        .split(',')
        .map(s => s.trim())
        .filter(Boolean);
      const merged = Array.from(new Set([...DEFAULT_HIGHLIGHTS, ...custom]));
      if (!merged.length) {
        highlightRegex = null;
        return;
      }
      const escaped = merged
        .map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
        .join('|');
      highlightRegex = new RegExp(`\\b(${escaped})\\b`, 'gi');
    }

    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, match => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      })[match]);
    }

    function applyEmphasis(html) {
      return html
        .replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>')
        .replace(/(^|[^*])\*([^*]+?)\*(?!\*)/g, (match, prefix, inner) => `${prefix}<em>${inner}</em>`);
    }

    function applyHighlights(html) {
      if (!highlightRegex) return html;
      return html.replace(highlightRegex, '<span class="highlight">$1</span>');
    }

    function buildLetters(text) {
      let index = 0;
      let result = '';
      for (const char of text) {
        if (/\s/.test(char)) {
          result += escapeHtml(char);
        } else {
          result += `<span class="fx-letter" style="--i:${index++}">${escapeHtml(char)}</span>`;
        }
      }
      return result;
    }

    function renderSegment(type, text) {
      const clean = escapeHtml(text);
      switch (type) {
        case 'rainbow':
          return `<span class="fx fx-rainbow">${buildLetters(text)}</span>`;
        case 'sparkle':
          return `<span class="fx fx-sparkle">${buildLetters(text)}</span>`;
        case 'bounce':
          return `<span class="fx fx-bounce">${clean}</span>`;
        case 'neon':
          return `<span class="fx fx-neon">${clean}</span>`;
        case 'glitch':
          return `<span class="fx fx-glitch">${clean}</span>`;
        default: {
          const emphasised = applyEmphasis(clean);
          return applyHighlights(emphasised);
        }
      }
    }

    function formatMessage(raw) {
      const str = String(raw || '').trim();
      if (!str) return '';
      const segments = [];
      const regex = /(%%|~~|\^\^|==|!!)([\s\S]+?)\1/g;
      let lastIndex = 0;
      let match;
      while ((match = regex.exec(str))) {
        if (match.index > lastIndex) {
          segments.push({ type: 'text', text: str.slice(lastIndex, match.index) });
        }
        const mapped = SPECIAL_MAP[match[1]] || 'text';
        segments.push({ type: mapped, text: match[2] });
        lastIndex = match.index + match[0].length;
      }
      if (lastIndex < str.length) {
        segments.push({ type: 'text', text: str.slice(lastIndex) });
      }
      return segments.map(seg => renderSegment(seg.type, seg.text)).join('');
    }

    function sanitiseMessages(list) {
      if (!Array.isArray(list)) return [];
      const cleaned = [];
      for (const entry of list) {
        const trimmed = String(entry).trim();
        if (trimmed) cleaned.push(trimmed);
      }
      return cleaned;
    }

    function updateOverlayChip() {
      const url = buildOverlayUrl();
      el.overlayText.textContent = url;
      el.overlayText.dataset.url = url;
    }

    function buildOverlayUrl() {
      const basePath = `${location.origin}${location.pathname.replace(/index\.html$/, '')}output.html`;
      const params = new URLSearchParams();
      params.set('server', serverBase());
      params.set('label', overlayPrefs.label || 'LIVE');
      if (overlayPrefs.accent) params.set('accent', overlayPrefs.accent);
      const highlights = (overlayPrefs.highlight || '')
        .split(',')
        .map(s => s.trim())
        .filter(Boolean)
        .join(',');
      if (highlights) params.set('hl', highlights);
      params.set('scale', String(overlayPrefs.scale));
      params.set('position', overlayPrefs.position);
      params.set('mode', overlayPrefs.mode);
      if (!overlayPrefs.accentAnim) params.set('accentAnim', '0');
      if (!overlayPrefs.sparkle) params.set('sparkle', '0');
      return `${basePath}?${params.toString()}`;
    }

    function saveLocal() {
      const payload = {
        overlay: overlayPrefs,
        autoStart: el.autoStart.checked,
        serverUrl: el.serverUrl.value
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (err) {
        console.warn('Failed to save local preferences', err);
      }
    }

    function loadLocal() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (parsed.overlay) overlayPrefs = normaliseOverlayData({ ...overlayPrefs, ...parsed.overlay });
        if (typeof parsed.autoStart === 'boolean') el.autoStart.checked = parsed.autoStart;
        if (typeof parsed.serverUrl === 'string') el.serverUrl.value = parsed.serverUrl;
      } catch (err) {
        console.warn('Failed to read local preferences', err);
      }
    }

    function clampDuration(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return state.displayDuration;
      return Math.min(Math.max(Math.round(numeric), 2), 90);
    }

    function clampMinutesValue(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return state.intervalMinutes;
      return Math.max(0, Math.min(60, Math.round(numeric * 100) / 100));
    }

    function renderTicker() {
      el.duration.value = state.displayDuration;
      el.interval.value = state.intervalMinutes.toFixed(state.intervalMinutes >= 10 ? 0 : 1);
      el.statusActive.classList.toggle('active', state.isActive);
      el.statusActiveText.textContent = state.isActive ? 'Active' : 'Inactive';
      el.statusCount.textContent = String(state.messages.length);
      el.statusUpdated.textContent = state.updatedAt ? new Date(state.updatedAt).toLocaleTimeString() : '–';
    }

    function renderOverlayControls() {
      el.overlayLabel.value = overlayPrefs.label;
      el.overlayAccent.value = overlayPrefs.accent;
      el.highlightWords.value = overlayPrefs.highlight;
      el.scaleRange.value = overlayPrefs.scale;
      el.scaleNumber.value = overlayPrefs.scale;
      el.accentAnim.checked = overlayPrefs.accentAnim;
      el.sparkle.checked = overlayPrefs.sparkle;
      Array.from(el.positionButtons.querySelectorAll('.segment-button')).forEach(btn => {
        btn.classList.toggle('is-active', btn.dataset.position === overlayPrefs.position);
      });
      Array.from(el.modeButtons.querySelectorAll('.segment-button')).forEach(btn => {
        btn.classList.toggle('is-active', btn.dataset.mode === overlayPrefs.mode);
      });
    }

    function renderMessages() {
      if (!state.messages.length) {
        el.messageList.innerHTML = '<div class="empty-state">No messages yet — add a line above or load a preset.</div>';
        return;
      }
      const rows = state.messages.map((msg, index) => {
        const formatted = formatMessage(msg);
        return `<div class="message-item" data-index="${index}">
          <div class="message-preview">${formatted}</div>
          <div class="message-actions">
            <button type="button" data-action="up" title="Move up">↑</button>
            <button type="button" data-action="down" title="Move down">↓</button>
            <button type="button" data-action="delete" title="Remove">Delete</button>
          </div>
        </div>`;
      }).join('');
      el.messageList.innerHTML = rows;
    }

    function formatPresetMeta(preset) {
      const date = new Date(preset.updatedAt);
      return `${preset.messages.length} message${preset.messages.length === 1 ? '' : 's'} • ${date.toLocaleString()}`;
    }

    function renderPresets() {
      if (!presets.length) {
        el.presetList.innerHTML = '<div class="empty-state">No presets saved yet.</div>';
        return;
      }
      const cards = presets.map(preset => {
        return `<div class="preset-card" data-id="${preset.id}">
          <div>
            <div class="preset-title">${escapeHtml(preset.name)}</div>
            <div class="preset-meta">${formatPresetMeta(preset)}</div>
          </div>
          <div class="preset-actions">
            <button type="button" data-action="load">Load</button>
            <button type="button" data-action="append">Append</button>
            <button type="button" data-action="delete">Delete</button>
          </div>
        </div>`;
      }).join('');
      el.presetList.innerHTML = cards;
    }

    function renderAll() {
      renderTicker();
      renderOverlayControls();
      updateHighlightRegex();
      renderMessages();
      renderPresets();
      updateOverlayChip();
      saveLocal();
    }

    async function fetchState({ silent = false } = {}) {
      if (fetchInFlight) return;
      fetchInFlight = true;
      const base = serverBase();
      try {
        const [tickerRes, overlayRes, presetRes] = await Promise.all([
          fetch(`${base}/ticker/state`, { cache: 'no-store' }),
          fetch(`${base}/ticker/overlay`, { cache: 'no-store' }),
          fetch(`${base}/ticker/presets`, { cache: 'no-store' })
        ]);
        if (!tickerRes.ok) throw new Error(`Ticker HTTP ${tickerRes.status}`);
        const tickerData = await tickerRes.json();
        state.isActive = !!tickerData.isActive;
        state.messages = sanitiseMessages(tickerData.messages || []);
        state.displayDuration = clampDuration(tickerData.displayDuration || 5);
        state.intervalMinutes = secondsToMinutes(tickerData.intervalBetween || 0);
        state.updatedAt = tickerData._updatedAt || Date.now();
        if (overlayRes.ok && !overlaySaveTimer && !overlaySaveInFlight) {
          const overlayData = await overlayRes.json();
          const normalisedOverlay = normaliseOverlayData(overlayData);
          overlayPrefs = normalisedOverlay;
        } else if (overlayRes.ok) {
          // Consume body even when skipping update to avoid leaking readers.
          await overlayRes.json();
        }
        if (presetRes.ok) {
          const presetData = await presetRes.json();
          if (Array.isArray(presetData.presets)) {
            presets = presetData.presets.map(entry => ({
              id: String(entry.id || `preset-${Math.random().toString(36).slice(2, 8)}`),
              name: String(entry.name || 'Preset'),
              messages: sanitiseMessages(entry.messages || []),
              updatedAt: Number(entry.updatedAt) || Date.now()
            }));
          }
        }
        el.statusServer.textContent = 'Online';
        el.statusServer.style.color = '#9de2c2';
        if (!silent && !state.messages.length) {
          el.statusActive.classList.remove('active');
          state.isActive = false;
        }
        renderAll();
      } catch (err) {
        console.error('Failed to fetch state', err);
        el.statusServer.textContent = 'Unreachable';
        el.statusServer.style.color = '#ff9a9a';
        if (!silent) toast('Server unreachable');
      } finally {
        fetchInFlight = false;
      }
    }

    async function persistState() {
      const base = serverBase();
      const payload = {
        isActive: state.isActive,
        messages: state.messages,
        displayDuration: state.displayDuration,
        intervalBetween: minutesToSeconds(state.intervalMinutes)
      };
      try {
        const res = await fetch(`${base}/ticker/state`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        if (data && data.state) {
          const serverState = data.state;
          state.updatedAt = serverState._updatedAt || Date.now();
          state.isActive = !!serverState.isActive;
          if (Array.isArray(serverState.messages)) {
            state.messages = sanitiseMessages(serverState.messages);
            renderMessages();
          }
          if (Number.isFinite(serverState.displayDuration)) {
            state.displayDuration = clampDuration(serverState.displayDuration);
          }
          if (Number.isFinite(serverState.intervalBetween)) {
            state.intervalMinutes = secondsToMinutes(serverState.intervalBetween);
          }
          renderTicker();
        }
        el.statusServer.textContent = 'Online';
        el.statusServer.style.color = '#9de2c2';
      } catch (err) {
        console.error('Failed to save state', err);
        toast('Failed to save ticker state');
        el.statusServer.textContent = 'Error';
        el.statusServer.style.color = '#ff9a9a';
      }
    }

    async function persistPresets() {
      const base = serverBase();
      try {
        const res = await fetch(`${base}/ticker/presets`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ presets })
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        if (data && Array.isArray(data.presets)) {
          presets = data.presets.map(entry => ({
            id: String(entry.id || `preset-${Math.random().toString(36).slice(2, 8)}`),
            name: String(entry.name || 'Preset'),
            messages: sanitiseMessages(entry.messages || []),
            updatedAt: Number(entry.updatedAt) || Date.now()
          }));
          renderPresets();
        }
        toast('Presets saved');
      } catch (err) {
        console.error('Failed to save presets', err);
        toast('Failed to save presets');
      }
    }

    function queueSave() {
      clearTimeout(saveTimer);
      saveTimer = setTimeout(() => {
        persistState();
      }, 250);
    }

    async function persistOverlay() {
      const base = serverBase();
      const payload = {
        label: overlayPrefs.label,
        accent: overlayPrefs.accent,
        highlight: overlayPrefs.highlight,
        scale: overlayPrefs.scale,
        position: overlayPrefs.position,
        mode: overlayPrefs.mode,
        accentAnim: overlayPrefs.accentAnim,
        sparkle: overlayPrefs.sparkle
      };
      overlaySaveInFlight = true;
      try {
        const res = await fetch(`${base}/ticker/overlay`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        // Consume response to keep connection clean.
        const data = await res.json();
        if (data && data.overlay) {
          overlayPrefs = normaliseOverlayData(data.overlay);
        }
      } catch (err) {
        console.error('Failed to save overlay preferences', err);
        toast('Failed to save overlay preferences');
      } finally {
        overlaySaveInFlight = false;
      }
    }

    function queueOverlaySave() {
      clearTimeout(overlaySaveTimer);
      overlaySaveTimer = setTimeout(() => {
        overlaySaveTimer = null;
        persistOverlay();
      }, 200);
    }

    function addMessage(text) {
      const trimmed = String(text || '').trim();
      if (!trimmed) return;
      state.messages.push(trimmed);
      if (el.autoStart.checked) state.isActive = true;
      renderMessages();
      renderTicker();
      queueSave();
    }

    function removeMessage(index) {
      if (index < 0 || index >= state.messages.length) return;
      state.messages.splice(index, 1);
      if (!state.messages.length) state.isActive = false;
      renderMessages();
      renderTicker();
      queueSave();
    }

    function moveMessage(index, delta) {
      const target = index + delta;
      if (target < 0 || target >= state.messages.length) return;
      const [item] = state.messages.splice(index, 1);
      state.messages.splice(target, 0, item);
      renderMessages();
      queueSave();
    }

    function handleMessageAction(event) {
      const button = event.target.closest('button[data-action]');
      if (!button) return;
      const row = button.closest('.message-item');
      if (!row) return;
      const index = Number(row.dataset.index);
      if (button.dataset.action === 'delete') removeMessage(index);
      if (button.dataset.action === 'up') moveMessage(index, -1);
      if (button.dataset.action === 'down') moveMessage(index, 1);
    }

    function setMode(value) {
      overlayPrefs.mode = value;
      renderOverlayControls();
      updateOverlayChip();
      saveLocal();
      queueOverlaySave();
    }

    function setPosition(value) {
      overlayPrefs.position = value;
      renderOverlayControls();
      updateOverlayChip();
      saveLocal();
      queueOverlaySave();
    }

    function updateScale(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return;
      overlayPrefs.scale = Math.max(0.75, Math.min(2.5, Math.round(numeric * 100) / 100));
      el.scaleRange.value = overlayPrefs.scale;
      el.scaleNumber.value = overlayPrefs.scale;
      updateOverlayChip();
      saveLocal();
      queueOverlaySave();
    }

    function handlePresetAction(event) {
      const button = event.target.closest('button[data-action]');
      if (!button) return;
      const card = button.closest('.preset-card');
      if (!card) return;
      const id = card.dataset.id;
      const preset = presets.find(item => item.id === id);
      if (!preset) return;
      switch (button.dataset.action) {
        case 'load':
          state.messages = [...preset.messages];
          if (state.messages.length) {
            state.isActive = state.isActive || el.autoStart.checked;
          } else {
            state.isActive = false;
          }
          renderMessages();
          renderTicker();
          queueSave();
          toast(`Loaded preset “${preset.name}”`);
          break;
        case 'append':
          state.messages.push(...preset.messages);
          if (el.autoStart.checked && state.messages.length) state.isActive = true;
          renderMessages();
          renderTicker();
          queueSave();
          toast(`Appended ${preset.messages.length} message${preset.messages.length === 1 ? '' : 's'}`);
          break;
        case 'delete':
          presets = presets.filter(item => item.id !== id);
          renderPresets();
          persistPresets();
          break;
      }
    }

    el.overlayChip.addEventListener('click', async () => {
      const url = buildOverlayUrl();
      try {
        await navigator.clipboard.writeText(url);
        toast('Overlay URL copied');
      } catch (err) {
        console.warn('Clipboard copy failed', err);
        toast('Copy failed');
      }
    });

    el.copyOverlay.addEventListener('click', async () => {
      const url = buildOverlayUrl();
      try {
        await navigator.clipboard.writeText(url);
        toast('Overlay URL copied');
      } catch (err) {
        toast('Copy failed');
      }
    });

    el.openOverlay.addEventListener('click', () => {
      window.open(buildOverlayUrl(), '_blank');
    });

    el.serverUrl.addEventListener('change', () => {
      saveLocal();
      fetchState({ silent: true });
      updateOverlayChip();
    });

    el.autoStart.addEventListener('change', () => {
      saveLocal();
    });

    el.duration.addEventListener('change', () => {
      state.displayDuration = clampDuration(el.duration.value);
      renderTicker();
      queueSave();
    });

    el.interval.addEventListener('change', () => {
      state.intervalMinutes = clampMinutesValue(el.interval.value);
      renderTicker();
      queueSave();
    });

    el.startBtn.addEventListener('click', () => {
      if (!state.messages.length) {
        toast('Add at least one message first');
        return;
      }
      state.isActive = true;
      renderTicker();
      queueSave();
    });

    el.stopBtn.addEventListener('click', () => {
      state.isActive = false;
      renderTicker();
      queueSave();
    });

    el.refreshBtn.addEventListener('click', () => fetchState({ silent: true }));

    el.overlayLabel.addEventListener('input', () => {
      overlayPrefs.label = el.overlayLabel.value.trim() || 'LIVE';
      updateOverlayChip();
      saveLocal();
      queueOverlaySave();
    });

    el.overlayAccent.addEventListener('input', () => {
      overlayPrefs.accent = el.overlayAccent.value.trim();
      updateOverlayChip();
      saveLocal();
      queueOverlaySave();
    });

    el.highlightWords.addEventListener('input', () => {
      overlayPrefs.highlight = normaliseHighlightInput(el.highlightWords.value);
      el.highlightWords.value = overlayPrefs.highlight;
      updateHighlightRegex();
      renderMessages();
      updateOverlayChip();
      saveLocal();
      queueOverlaySave();
    });

    el.scaleRange.addEventListener('input', () => updateScale(el.scaleRange.value));
    el.scaleNumber.addEventListener('change', () => updateScale(el.scaleNumber.value));

    el.positionButtons.addEventListener('click', event => {
      const button = event.target.closest('button[data-position]');
      if (!button) return;
      setPosition(button.dataset.position);
    });

    el.modeButtons.addEventListener('click', event => {
      const button = event.target.closest('button[data-mode]');
      if (!button) return;
      setMode(button.dataset.mode);
    });

    el.accentAnim.addEventListener('change', () => {
      overlayPrefs.accentAnim = el.accentAnim.checked;
      updateOverlayChip();
      saveLocal();
      queueOverlaySave();
    });

    el.sparkle.addEventListener('change', () => {
      overlayPrefs.sparkle = el.sparkle.checked;
      updateOverlayChip();
      saveLocal();
      queueOverlaySave();
    });

    el.messageForm.addEventListener('submit', event => {
      event.preventDefault();
      addMessage(el.newMessage.value);
      el.newMessage.value = '';
      el.newMessage.focus();
    });

    el.clearMessages.addEventListener('click', () => {
      if (!state.messages.length) return;
      if (confirm('Clear all messages?')) {
        state.messages = [];
        state.isActive = false;
        renderMessages();
        renderTicker();
        queueSave();
      }
    });

    el.exportMessages.addEventListener('click', () => {
      const blob = new Blob([JSON.stringify({ messages: state.messages }, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ticker-messages.json';
      a.click();
      URL.revokeObjectURL(url);
    });

    el.importMessages.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';
      input.onchange = async () => {
        const file = input.files && input.files[0];
        if (!file) return;
        try {
          const text = await file.text();
          const data = JSON.parse(text);
          if (Array.isArray(data.messages)) {
            state.messages = sanitiseMessages(data.messages);
            if (el.autoStart.checked && state.messages.length) state.isActive = true;
            renderMessages();
            renderTicker();
            queueSave();
            toast('Messages imported');
          } else {
            toast('Invalid file format');
          }
        } catch (err) {
          console.error('Failed to import messages', err);
          toast('Import failed');
        }
      };
      input.click();
    });

    el.messageList.addEventListener('click', handleMessageAction);

    el.savePreset.addEventListener('click', () => {
      const name = el.presetName.value.trim();
      if (!name) {
        toast('Enter a preset name');
        return;
      }
      if (!state.messages.length) {
        toast('Nothing to save');
        return;
      }
      const existing = presets.find(p => p.name.toLowerCase() === name.toLowerCase());
      const payload = {
        id: existing ? existing.id : `preset-${Math.random().toString(36).slice(2, 8)}`,
        name,
        messages: [...state.messages],
        updatedAt: Date.now()
      };
      if (existing) {
        Object.assign(existing, payload);
      } else {
        presets.unshift(payload);
      }
      el.presetName.value = '';
      renderPresets();
      persistPresets();
    });

    el.presetList.addEventListener('click', handlePresetAction);

    function init() {
      loadLocal();
      renderOverlayControls();
      updateHighlightRegex();
      updateOverlayChip();
      fetchState();
      setInterval(() => fetchState({ silent: true }), 4000);
    }

    init();
  </script>
</body>
</html>