<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OBS Ticker Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/SplitText.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrambleTextPlugin.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <link rel="stylesheet" href="css/themes.css">
  <style>
    :root {
      --ui-scale: 1;
      --bg: #050608;
      --bg-accent: #090b10;
      --panel: rgba(12, 14, 20, 0.9);
      --panel-border: rgba(110, 116, 134, 0.28);
      --panel-highlight: rgba(124, 92, 255, 0.22);
      --muted: rgba(18, 20, 28, 0.92);
      --text: #f5f7fb;
      --subtle: #9ea3b4;
      --accent: #7c5cff;
      --accent-strong: #a38cff;
      --accent-soft: rgba(124, 92, 255, 0.12);
      --accent-bright: #9fa6ff;
      --accent-glow: rgba(124, 92, 255, 0.42);
      --accent-duo: #372f6a;
      --accent-contrast: #131622;
      --success: #3ddc97;
      --danger: #ff6b6b;
      --danger-soft: rgba(255, 107, 107, 0.18);
      --radius: 16px;
      --shadow: 0 18px 40px rgba(4, 5, 12, 0.55);
      --shadow-soft: 0 12px 28px rgba(4, 6, 16, 0.4);
      --pill-bg: rgba(30, 32, 42, 0.78);
      --input-bg: rgba(14, 16, 24, 0.92);
      --input-border: rgba(110, 116, 134, 0.22);
      --chip-bg: rgba(36, 38, 48, 0.7);
      --chip-border: rgba(120, 124, 140, 0.26);
      --toast-bg: rgba(16, 18, 24, 0.95);
      --popup-scale: 1;
    }

    @supports (color: color-mix(in srgb, red 50%, blue)) {
      :root {
        --panel-highlight: color-mix(in srgb, var(--accent) 22%, rgba(255, 255, 255, 0.08));
        --accent-strong: color-mix(in srgb, var(--accent) 78%, white 22%);
        --accent-soft: color-mix(in srgb, var(--accent) 12%, transparent);
        --accent-bright: color-mix(in srgb, var(--accent) 82%, #f8f9ff 18%);
        --accent-glow: color-mix(in srgb, var(--accent) 58%, rgba(255, 255, 255, 0.42));
        --accent-duo: color-mix(in srgb, var(--accent) 60%, #1b1d27 40%);
        --accent-contrast: color-mix(in srgb, var(--accent) 58%, #0e1018 42%);
      }
    }

    *, *::before, *::after { box-sizing: border-box; }

    html, body { height: 100%; }

    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      background-color: #050608;
      background:
        radial-gradient(1200px 720px at -10% -20%, rgba(124, 92, 255, 0.12), transparent 68%),
        radial-gradient(980px 620px at 120% -10%, rgba(24, 26, 34, 0.8), transparent 60%),
        linear-gradient(160deg, #050608 0%, #080a11 55%, #020305 100%);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      padding: 44px 24px 64px;
    }

    @supports (color: color-mix(in srgb, red 50%, blue)) {
      body {
        background:
          radial-gradient(1200px 720px at -10% -20%, color-mix(in srgb, var(--accent) 8%, rgba(20, 22, 28, 0.85)), transparent 68%),
          radial-gradient(980px 620px at 120% -10%, rgba(24, 26, 34, 0.8), transparent 60%),
          linear-gradient(160deg, #050608 0%, #080a11 55%, #020305 100%);
      }
    }

    body.is-modal-open { overflow: hidden; }

    .app { max-width: 1320px; margin: 0 auto; display: flex; flex-direction: column; gap: 28px; }

    .layout-grid {
      display: grid;
      gap: 28px;
    }

    .layout-col {
      display: flex;
      flex-direction: column;
      gap: 28px;
    }

    .layout-col--secondary {
      gap: 26px;
      align-self: start;
    }

    .panel-switcher {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .panel-switcher__tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 10px;
      border-radius: 18px;
      background: rgba(14, 18, 28, 0.85);
      border: 1px solid rgba(112, 118, 136, 0.28);
      box-shadow: 0 12px 28px rgba(4, 6, 16, 0.45);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      overflow-x: auto;
      scrollbar-width: thin;
    }

    .panel-switcher__tabs::-webkit-scrollbar {
      height: 6px;
    }

    .panel-switcher__tabs::-webkit-scrollbar-thumb {
      background: rgba(124, 92, 255, 0.35);
      border-radius: 999px;
    }

    .panel-switcher__tab {
      flex: 1 1 140px;
      appearance: none;
      border: 1px solid rgba(112, 118, 136, 0.35);
      border-radius: 12px;
      background: rgba(22, 26, 38, 0.72);
      color: rgba(220, 226, 255, 0.72);
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.24px;
      padding: 12px 16px;
      cursor: pointer;
      transition: border 0.18s ease, box-shadow 0.18s ease, transform 0.18s ease, color 0.18s ease, background 0.18s ease;
      text-align: left;
    }

    .panel-switcher__tab:hover {
      transform: translateY(-1px);
      border-color: rgba(124, 92, 255, 0.45);
      color: var(--text);
    }

    .panel-switcher__tab.is-active {
      color: #fff;
      background: linear-gradient(135deg, var(--accent-duo), var(--accent));
      border-color: transparent;
      box-shadow: 0 16px 36px rgba(124, 92, 255, 0.28);
    }

    .panel-switcher__tab:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .panel-switcher__content {
      position: relative;
    }

    .panel-switcher__panel {
      display: none;
    }

    .panel-switcher__panel.is-active {
      display: flex;
    }

    .panel-switcher__panel[hidden] {
      display: none !important;
    }

    @media (min-width: 1100px) {
      .layout-grid {
        grid-template-columns: minmax(0, 1.35fr) minmax(0, 1fr);
        align-items: start;
      }
      .layout-col--secondary {
        position: sticky;
        top: 48px;
      }
    }

    @media (max-width: 1099px) {
      .layout-col--secondary {
        position: static;
      }
    }

    @media (max-width: 720px) {
      .app { gap: 24px; }
      .layout-grid { gap: 24px; }
      .layout-col { gap: 24px; }
      .panel-switcher__tab { flex: 1 1 calc(50% - 10px); text-align: center; }
    }

    @media (max-width: 480px) {
      .panel {
        padding: 20px 18px;
        gap: 16px;
      }
      .preset-header,
      .scene-header {
        gap: 10px;
      }
      .preset-header button,
      .scene-header button {
        flex: 1 1 140px;
      }
      .panel-switcher__tab { flex: 1 1 100%; }
    }

    .panel {
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 20px;
      border-radius: var(--radius);
      padding: 26px 28px;
      --panel-bg: var(--panel);
      --panel-border-color: var(--panel-border);
      --panel-glow: rgba(124, 92, 255, 0.1);
      --panel-sheen: rgba(255, 255, 255, 0.04);
      border: 1px solid var(--panel-border-color);
      background-color: var(--panel-bg);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), transparent 32%) var(--panel-bg);
      box-shadow: var(--shadow);
    }

    @keyframes panelBusySpin {
      to { transform: rotate(360deg); }
    }

    .panel[data-busy="true"]::before,
    .panel[data-busy="true"]::after {
      position: absolute;
      pointer-events: none;
      z-index: 3;
    }

    .panel[data-busy="true"]::before {
      content: '';
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 2px solid var(--accent-bright);
      border-top-color: transparent;
      border-right-color: transparent;
      top: 20px;
      right: 40px;
      animation: panelBusySpin 0.9s linear infinite;
      opacity: 0.9;
    }

    .panel[data-busy="true"]::after {
      content: attr(data-busy-label);
      top: 16px;
      right: 18px;
      font-size: 12px;
      letter-spacing: 0.02em;
      font-weight: 600;
      color: var(--accent-bright);
      background: var(--pill-bg);
      border: 1px solid rgba(124, 92, 255, 0.28);
      border-radius: 999px;
      padding: 6px 18px 6px 30px;
      box-shadow: 0 16px 32px rgba(7, 9, 20, 0.5);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }

    .panel[data-busy-state="pending"]::after {
      color: var(--subtle);
      border-color: rgba(124, 92, 255, 0.18);
    }

    .panel[data-busy-state="pending"]::before {
      border-color: rgba(158, 163, 180, 0.6);
      border-top-color: transparent;
      border-right-color: transparent;
    }

    .panel[data-busy-state="draft"]::before {
      animation: none;
      border-color: rgba(124, 92, 255, 0.36);
      border-top-color: rgba(124, 92, 255, 0.36);
      border-right-color: rgba(124, 92, 255, 0.36);
      background: rgba(124, 92, 255, 0.12);
    }

    .panel[data-busy-state="draft"]::after {
      color: var(--accent-bright);
      border-color: rgba(124, 92, 255, 0.28);
    }

    @supports ((backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px))) {
      .panel {
        backdrop-filter: blur(18px) saturate(1.05);
        -webkit-backdrop-filter: blur(18px) saturate(1.05);
      }
    }

    .panel.is-live {
      --panel-border-color: rgba(124, 92, 255, 0.35);
      --panel-glow: rgba(124, 92, 255, 0.18);
      box-shadow: 0 24px 60px rgba(7, 10, 24, 0.55);
    }

    @supports (color: color-mix(in srgb, red 50%, blue)) {
      .panel.is-live {
        --panel-border-color: color-mix(in srgb, var(--accent) 65%, rgba(112, 118, 136, 0.2));
        --panel-glow: color-mix(in srgb, var(--accent) 36%, rgba(124, 92, 255, 0.22));
        box-shadow: 0 24px 60px color-mix(in srgb, rgba(7, 10, 24, 0.55) 55%, var(--accent) 45%);
      }
    }

    .panel::before,
    .panel::after { content: ''; position: absolute; inset: 0; pointer-events: none; }

    .panel::before {
      inset: -40% -35%;
      background: radial-gradient(ellipse at top left, var(--panel-glow), transparent 60%);
      opacity: 0.55;
      transform: rotate(6deg);
    }

    .panel.is-live::before {
      opacity: 0.8;
    }

    .panel::after {
      background: linear-gradient(135deg, var(--panel-sheen), transparent 70%);
      mix-blend-mode: screen;
    }

    .panel > * { position: relative; z-index: 1; }

    .panel--accent {
      --panel-bg: rgba(16, 20, 36, 0.9);
      --panel-border-color: rgba(124, 92, 255, 0.32);
      --panel-glow: rgba(124, 92, 255, 0.18);
      --panel-sheen: rgba(255, 255, 255, 0.06);
      box-shadow: 0 24px 60px rgba(8, 12, 30, 0.5);
    }

    @supports (color: color-mix(in srgb, red 50%, blue)) {
      .panel--accent {
        --panel-border-color: color-mix(in srgb, var(--accent) 36%, rgba(112, 118, 136, 0.45));
        --panel-glow: color-mix(in srgb, var(--accent) 24%, rgba(124, 92, 255, 0.22));
      }
    }

    .panel--neutral {
      --panel-bg: rgba(13, 16, 26, 0.9);
      --panel-border-color: rgba(112, 118, 136, 0.26);
      --panel-glow: rgba(112, 118, 136, 0.14);
      --panel-sheen: rgba(255, 255, 255, 0.04);
    }

    .panel--muted {
      --panel-bg: rgba(11, 14, 22, 0.88);
      --panel-border-color: rgba(92, 104, 152, 0.22);
      --panel-glow: rgba(84, 96, 138, 0.12);
      --panel-sheen: rgba(255, 255, 255, 0.03);
      box-shadow: var(--shadow-soft);
    }

    .header {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      justify-content: space-between;
      gap: 18px;
    }

    .title-block { display: flex; flex-direction: column; gap: 8px; max-width: 620px; }
    h1 { font-size: 30px; font-weight: 700; margin: 0; letter-spacing: 0.3px; }
    .subtitle { color: var(--subtle); font-size: 15px; line-height: 1.5; margin: 0; }

    .overlay-chip {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      border-radius: 14px;
      background: var(--chip-bg);
      border: 1px solid var(--chip-border);
      max-width: 360px;
      font-size: 12px;
      color: var(--subtle);
      word-break: break-all;
    }
    .overlay-chip strong { color: var(--text); font-weight: 600; }

    .status-ribbon {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      padding: 10px 16px;
      border-radius: 14px;
      background: linear-gradient(135deg, rgba(24, 28, 40, 0.5), rgba(14, 16, 26, 0.32));
      border: 1px solid rgba(124, 92, 255, 0.12);
      box-shadow: 0 8px 22px rgba(6, 8, 18, 0.22);
    }

    .status-item {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(20, 24, 36, 0.32);
      border: 1px solid rgba(124, 92, 255, 0.14);
      font-size: 12px;
      letter-spacing: 0.2px;
      color: var(--subtle);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    .status-dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
      background: rgba(149, 160, 196, 0.55);
      box-shadow: 0 0 0 0 rgba(61, 220, 151, 0.22);
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .status-dot.active {
      background: var(--success);
      box-shadow: 0 0 0 4px rgba(61, 220, 151, 0.18);
    }

    .status-value {
      color: var(--text);
      font-weight: 600;
    }

    .status-value--success { color: var(--success); }
    .status-value--warning { color: #facc6b; }
    .status-value--error,
    .status-value--offline { color: var(--danger); }
    .status-value--neutral { color: var(--subtle); }

    .status-dot--success {
      background: var(--success);
      box-shadow: 0 0 0 4px rgba(61, 220, 151, 0.18);
    }

    .status-dot--warning {
      background: #facc6b;
      box-shadow: 0 0 0 4px rgba(250, 204, 107, 0.18);
    }

    .status-dot--error,
    .status-dot--offline {
      background: var(--danger);
      box-shadow: 0 0 0 4px rgba(255, 107, 107, 0.2);
    }

    .status-dot--neutral {
      background: rgba(149, 160, 196, 0.55);
      box-shadow: none;
    }

    .status-value.is-active { color: color-mix(in srgb, var(--success) 55%, var(--accent) 45%); }
    .status-value.is-inactive { color: var(--subtle); }
    .status-value.is-full { color: var(--danger); }

    .config-drawer {
      margin-top: 18px;
      border-radius: 16px;
      background: rgba(14, 18, 28, 0.82);
      border: 1px solid rgba(118, 136, 190, 0.24);
      overflow: hidden;
      box-shadow: 0 16px 34px rgba(6, 8, 20, 0.38);
    }

    .config-drawer summary {
      list-style: none;
      cursor: pointer;
      padding: 16px 20px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      color: var(--text);
      font-weight: 600;
      letter-spacing: 0.2px;
      position: relative;
    }

    .config-drawer summary::-webkit-details-marker { display: none; }

    .config-drawer summary:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
      border-radius: inherit;
    }

    .config-drawer summary::after {
      content: '';
      position: absolute;
      right: 20px;
      top: 50%;
      width: 10px;
      height: 10px;
      border-right: 2px solid rgba(159, 166, 204, 0.8);
      border-bottom: 2px solid rgba(159, 166, 204, 0.8);
      transform: translateY(-50%) rotate(45deg);
      transition: transform 0.2s ease;
    }

    .config-drawer[open] summary::after {
      transform: translateY(-50%) rotate(225deg);
    }

    .config-drawer__summary-sub {
      font-size: 12px;
      font-weight: 400;
      color: rgba(201, 208, 230, 0.7);
    }

    .config-drawer__content {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 18px 20px 20px;
      background: rgba(10, 12, 20, 0.6);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    .config-drawer__field {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .config-drawer__toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--subtle);
      cursor: pointer;
    }

    .config-drawer__toggle input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }

    .config-drawer__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    .config-drawer__actions .btn {
      min-width: 140px;
    }

    .section-title { font-size: 18px; font-weight: 600; letter-spacing: 0.2px; }
    .section-sub { font-size: 13px; color: rgba(201, 208, 230, 0.75); }

    .control-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 16px; }
    .control-group { display: flex; flex-direction: column; gap: 10px; }
    .control-hint { margin: 2px 0 0; font-size: 12px; color: rgba(201, 208, 230, 0.7); }
    .control-hint.is-warning { color: rgba(255, 205, 130, 0.9); }
    .control-hint.is-error { color: rgba(255, 152, 152, 0.85); }
    .control-hint--status { margin-top: 6px; }
    .control-hint--status[hidden] { display: none !important; }
    .control-hint--status[data-tone="success"] { color: var(--success); }
    .control-hint--status[data-tone="warning"] { color: #facc6b; }
    .control-hint--status[data-tone="error"] { color: var(--danger); }
    .control-hint--status[data-tone="neutral"] { color: var(--subtle); }
    input[aria-invalid="true"] {
      border-color: var(--danger);
      box-shadow: 0 0 0 1px var(--danger-soft);
    }
    .accent-inputs { display: flex; align-items: center; gap: 10px; }
    .accent-inputs input[type="color"] {
      width: 44px;
      height: 44px;
      padding: 0;
      border: 1px solid var(--input-border);
      border-radius: 12px;
      background: none;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(5, 7, 16, 0.32);
      transition: border 0.15s ease, box-shadow 0.15s ease, transform 0.15s ease;
    }
    .accent-inputs input[type="color"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px rgba(124, 92, 255, 0.25);
      transform: translateY(-1px);
    }
    .accent-inputs input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; border-radius: inherit; }
    .accent-inputs input[type="color"]::-webkit-color-swatch { border: none; border-radius: inherit; }
    .accent-inputs input[type="color"]::-moz-color-swatch { border: none; border-radius: inherit; }
    .accent-inputs input[type="text"] { flex: 1; }
    .accent-inputs.has-error input[type="text"],
    .accent-inputs.has-error input[type="color"] {
      border-color: rgba(255, 107, 107, 0.65);
      box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.22);
    }
    .theme-notes { display: flex; flex-wrap: wrap; gap: 8px 12px; font-size: 12px; color: rgba(201, 208, 230, 0.72); }
    .theme-notes span { display: inline-flex; gap: 4px; align-items: baseline; }
    .theme-notes strong { color: var(--text); font-weight: 600; letter-spacing: 0.02em; }

    label { font-size: 13px; color: var(--subtle); font-weight: 500; letter-spacing: 0.2px; }
    input[type="number"], input[type="text"] {
      width: 100%;
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: 12px;
      padding: 11px 13px;
      font-size: 14px;
      outline: none;
      transition: border 0.15s ease, box-shadow 0.15s ease, transform 0.15s ease;
      box-shadow: 0 10px 24px rgba(5, 7, 16, 0.32);
    }
    input[type="number"]:focus, input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px rgba(124, 92, 255, 0.25);
      transform: translateY(-1px);
    }

    textarea {
      width: 100%;
      min-height: 96px;
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: 12px;
      padding: 12px 14px;
      font-size: 14px;
      line-height: 1.5;
      resize: vertical;
      outline: none;
      transition: border 0.15s ease, box-shadow 0.15s ease, transform 0.15s ease;
      box-shadow: inset 0 1px 2px rgba(5, 7, 16, 0.45);
      font-family: inherit;
    }
    textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px rgba(124, 92, 255, 0.25);
      transform: translateY(-1px);
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(84, 96, 138, 0.45);
      border: 1px solid rgba(112, 118, 136, 0.4);
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 18px; height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      box-shadow: 0 8px 20px rgba(124, 92, 255, 0.35);
      border: none;
      cursor: pointer;
    }
    input[type="range"]::-moz-range-thumb {
      width: 18px; height: 18px; border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      border: none; cursor: pointer;
    }

    .segment-row { display: flex; flex-wrap: wrap; gap: 8px; }
    .segment-button {
      appearance: none;
      border: 1px solid rgba(112, 118, 136, 0.4);
      border-radius: 999px;
      padding: 7px 14px;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.2px;
      background: rgba(48, 56, 86, 0.4);
      color: rgba(220, 226, 255, 0.88);
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, border 0.15s ease, background 0.15s ease;
    }
    .segment-button:hover { transform: translateY(-1px); box-shadow: 0 10px 22px rgba(18, 22, 34, 0.42); }
    .segment-button.is-active {
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      border-color: transparent;
      color: #fff;
      box-shadow: 0 14px 30px rgba(124, 92, 255, 0.35);
    }

    .toggle-row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .toggle-row label { display: flex; align-items: center; gap: 8px; cursor: pointer; }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .actions--overlay-hint {
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
    }
    .actions .spacer { flex: 1; }

    .btn {
      appearance: none;
      border: none;
      border-radius: 12px;
      padding: 11px 16px;
      font-weight: 600;
      cursor: pointer;
      color: #fff;
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      transition: transform 0.14s ease, box-shadow 0.14s ease, filter 0.14s ease;
      font-size: 14px;
      letter-spacing: 0.2px;
      box-shadow: 0 14px 30px rgba(124, 92, 255, 0.28);
    }
    .btn:hover { transform: translateY(-1px); filter: brightness(1.05); }
    .btn:active { transform: translateY(1px); }
    .btn-secondary { background: rgba(54, 62, 92, 0.9); color: #f3f4ff; box-shadow: none; }
    .btn-secondary:hover { box-shadow: 0 12px 26px rgba(32, 38, 60, 0.4); }
    .btn-ghost { background: rgba(255, 255, 255, 0.04); color: var(--subtle); box-shadow: none; border: 1px dashed rgba(112, 118, 136, 0.35); }
    .btn-ghost:hover { filter: none; transform: none; border-color: var(--accent); color: #fff; }
    .btn-danger { background: linear-gradient(135deg, var(--danger), #ff856b); box-shadow: 0 14px 26px rgba(255, 107, 107, 0.32); }
    .btn-success { background: linear-gradient(135deg, var(--success), #23c485); color: #04160f; box-shadow: 0 14px 26px rgba(61, 220, 151, 0.32); }

    .message-composer { display: flex; flex-wrap: wrap; gap: 12px; }
    .message-composer input { flex: 1; }
    .message-composer input[disabled],
    .message-composer button[disabled] {
      opacity: 0.55;
      cursor: not-allowed;
    }
    .hint-row { font-size: 12px; color: rgba(201, 208, 230, 0.7); display: flex; flex-wrap: wrap; gap: 10px; }
    .hint-row code { background: rgba(44, 50, 72, 0.7); padding: 2px 6px; border-radius: 6px; font-size: 12px; color: #f0f4ff; }

    .popup-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: flex-start;
    }
    .popup-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--subtle);
      transition: color 0.2s ease, text-shadow 0.25s ease;
    }
    .popup-toggle.is-live,
    .brb-toggle.is-live {
      color: var(--accent-bright);
      text-shadow: 0 0 14px color-mix(in srgb, var(--accent-glow) 75%, transparent);
      font-weight: 600;
    }
    .popup-duration {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--subtle);
      margin-left: auto;
    }
    .popup-duration input {
      width: 112px;
      min-width: 96px;
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
      box-shadow: inset 0 1px 2px rgba(5, 7, 16, 0.35);
    }
    .popup-duration input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(124, 92, 255, 0.25);
    }
    .popup-countdown {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-top: 10px;
      font-size: 13px;
      color: var(--subtle);
    }
    .popup-countdown-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
      color: var(--text);
    }
    .popup-countdown-input {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 220px;
    }
    .popup-countdown-input label {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(201, 208, 230, 0.7);
    }
    .popup-countdown-input input {
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
      box-shadow: inset 0 1px 2px rgba(5, 7, 16, 0.35);
    }
    .popup-countdown-input input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(124, 92, 255, 0.25);
    }
    .popup-preview {
      position: relative;
      display: flex;
      align-items: center;
      gap: calc(var(--space-sm) * var(--popup-scale));
      padding: calc(var(--space-md) * var(--popup-scale)) calc(var(--space-lg) * var(--popup-scale));
      border-radius: 0;
      border: 1px solid var(--popup-border-color, rgba(112, 118, 136, 0.28));
      background-color: var(--popup-surface-a, rgba(28, 30, 44, 0.95));
      background:
        var(--ticker-ambient-mask, transparent),
        linear-gradient(150deg, var(--popup-surface-a, rgba(28, 30, 44, 0.95)), var(--popup-surface-b, rgba(12, 14, 24, 0.9)));
      color: var(--popup-text-color, rgba(248, 250, 255, 0.96));
      font-size: calc(var(--text-lg) * var(--popup-scale) / var(--ui-scale));
      font-weight: 600;
      line-height: 1.45;
      box-shadow: var(--popup-shadow, 0 16px 40px rgba(5, 8, 22, 0.42)), var(--ticker-chromatic-shadows, 0 0 0 transparent);
      min-height: 64px;
      overflow: hidden;
      transition: padding 0.2s var(--ease-smooth), font-size 0.2s var(--ease-smooth);
      --popup-surface-a: rgba(28, 30, 44, 0.95);
      --popup-surface-b: rgba(12, 14, 24, 0.9);
      --popup-border-color: rgba(128, 136, 176, 0.32);
      --popup-shadow: var(--ticker-shadow);
      --popup-text-color: rgba(248, 250, 255, 0.96);
      --popup-divider-color: rgba(180, 192, 224, 0.22);
      --preview-accent: #38bdf8;
      --preview-accent-secondary: #f472b6;
      --overlay-accent: var(--preview-accent);
      --overlay-accent-secondary: var(--preview-accent-secondary, var(--overlay-accent));
      --accent: var(--overlay-accent, var(--preview-accent));
      --accent-secondary: var(--overlay-accent-secondary, var(--accent));
      --accent-bright: #7dd3fc;
      --accent-glow: rgba(56, 189, 248, 0.45);
      --accent-duo: #1c1e27;
      --accent-contrast: #0d0f16;
      --popup-countdown-color: rgba(247, 249, 255, 0.9);
      --popup-countdown-dot: rgba(255, 255, 255, 0.52);
      --popup-accent-strip:
        linear-gradient(165deg, var(--accent), rgba(255, 255, 255, 0.45));
      --ticker-surface-a: rgba(16, 18, 26, 0.94);
      --ticker-surface-b: rgba(6, 8, 14, 0.92);
      --ticker-border: rgba(120, 126, 146, 0.24);
      --ticker-shadow: 0 14px 38px rgba(4, 6, 16, 0.45);
      --ticker-divider-color: rgba(255, 255, 255, 0.16);
      filter: var(--ticker-depth-filter, none);
      mask-image: var(--ticker-depth-mask, none);
      -webkit-mask-image: var(--ticker-depth-mask, none);
      mask-mode: luminance;
      mask-size: cover;
      -webkit-mask-size: cover;
      mask-repeat: no-repeat;
      -webkit-mask-repeat: no-repeat;
      animation: var(--popup-glow-anim, none);
      --popup-sheen: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0) 65%);
    }

    body[data-preview-theme] {
      --accent: var(--overlay-accent, var(--preview-accent));
      --accent-secondary: var(--overlay-accent-secondary, var(--accent));
    }

    @supports ((backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px))) {
      .popup-preview {
        backdrop-filter: var(--ticker-backdrop-filter, blur(18px) saturate(1.05));
        -webkit-backdrop-filter: var(--ticker-backdrop-filter, blur(18px) saturate(1.05));
      }
    }

    @supports (color: color-mix(in srgb, red 50%, blue)) {
      .popup-preview {
        --popup-surface-a: color-mix(in srgb, var(--ticker-surface-a, rgba(16, 18, 26, 0.94)) 92%, rgba(255, 255, 255, 0.02));
        --popup-surface-b: color-mix(in srgb, var(--ticker-surface-b, rgba(6, 8, 14, 0.92)) 92%, rgba(0, 0, 0, 0.08));
        --popup-border-color: color-mix(in srgb, var(--ticker-border, rgba(120, 126, 146, 0.24)) 85%, rgba(255, 255, 255, 0.12));
        --popup-divider-color: color-mix(in srgb, var(--ticker-divider-color, rgba(255, 255, 255, 0.16)) 78%, rgba(255, 255, 255, 0.12));
        --accent-bright: color-mix(in srgb, var(--accent) 80%, #f8f9ff 20%);
        --accent-glow: color-mix(in srgb, var(--accent) 56%, rgba(255, 255, 255, 0.4));
        --accent-duo: color-mix(in srgb, var(--accent) 60%, #1c1e27 40%);
        --accent-contrast: color-mix(in srgb, var(--accent) 56%, #0d0f16 44%);
        --popup-countdown-color: color-mix(in srgb, rgba(247, 249, 255, 0.9) 85%, var(--accent) 15%);
        --popup-countdown-dot: color-mix(in srgb, rgba(255, 255, 255, 0.52) 75%, var(--accent) 25%);
        --popup-accent-strip:
          linear-gradient(165deg, var(--accent), color-mix(in srgb, var(--accent-secondary) 32%, rgba(255, 255, 255, 0.45)));
      }
    }
    .popup-preview::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: calc(4px * var(--popup-scale));
      background: var(--popup-accent-strip);
      opacity: 0.7;
      pointer-events: none;
    }
    .popup-preview::after {
      content: '';
      position: absolute;
      inset: 0;
      background:
        var(--ticker-ambient-caustics, transparent),
        var(--popup-sheen);
      opacity: 0.18;
      pointer-events: none;
      animation: var(--popup-glow-anim, none);
      mix-blend-mode: screen;
    }
    .popup-preview > * { position: relative; z-index: 1; }
    .popup-preview-message { flex: 1 1 auto; }
    .popup-preview.is-empty { color: rgba(201, 208, 230, 0.65); font-weight: 500; }
    .popup-preview .popup-countdown-chip {
      display: inline-flex;
      align-items: center;
      gap: calc(10px * var(--popup-scale));
      margin-left: calc(16px * var(--popup-scale));
      font-size: 0.9em;
      font-weight: 600;
      color: var(--popup-countdown-color, rgba(247, 249, 255, 0.85));
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }
    .popup-preview .popup-countdown-chip::before {
      content: '•';
      margin-right: calc(4px * var(--popup-scale));
      color: var(--popup-countdown-dot, rgba(255, 255, 255, 0.6));
    }
    .popup-meta { font-size: 12px; color: rgba(201, 208, 230, 0.68); }
    .popup-buttons { display: flex; gap: 10px; flex-wrap: wrap; }

    .brb-actions { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .brb-actions .spacer { flex: 1 1 auto; }
    .brb-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--subtle);
      transition: color 0.2s ease, text-shadow 0.25s ease;
    }
    .brb-status { font-size: 12px; color: rgba(201, 208, 230, 0.75); }

    .message-list {
      display: flex;
      flex-direction: column;
      border: 1px solid rgba(112, 118, 136, 0.25);
      border-radius: 14px;
      overflow: hidden;
      background: rgba(10, 14, 24, 0.85);
    }
    .message-item {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 14px;
      align-items: center;
      padding: 14px 16px;
      border-bottom: 1px solid rgba(112, 118, 136, 0.18);
    }
    .message-item:last-child { border-bottom: none; }
    .message-preview { font-size: 15px; line-height: 1.4; color: #e7ebff; }
    .message-actions { display: flex; gap: 8px; }
    .message-actions button {
      appearance: none;
      border: none;
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      color: #f3f4ff;
      background: rgba(54, 62, 92, 0.9);
      transition: transform 0.14s ease, box-shadow 0.14s ease;
    }
    .message-actions button:hover { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(18, 22, 34, 0.4); }
    .message-actions button[data-action="delete"] { background: rgba(255, 107, 107, 0.12); color: #ff9696; }
    .message-actions button[data-action="save-preset"] { background: rgba(124, 92, 255, 0.18); color: #dad6ff; }

    .message-item.is-editing { align-items: flex-start; }
    .message-editor { display: flex; flex-direction: column; gap: 8px; }
    .message-edit-input {
      width: 100%;
      min-height: 72px;
      resize: vertical;
      border-radius: 10px;
      border: 1px solid rgba(112, 118, 136, 0.35);
      background: rgba(14, 18, 28, 0.92);
      color: #f5f7ff;
      font-size: 14px;
      padding: 10px 12px;
      font-family: inherit;
      line-height: 1.45;
      box-shadow: inset 0 1px 2px rgba(4, 6, 12, 0.4);
    }
    .message-edit-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(124, 92, 255, 0.22);
    }
    .message-item.is-editing .message-actions { align-items: center; }
    .message-actions button[data-action="save"] {
      background: rgba(61, 220, 151, 0.18);
      color: #8df0c6;
    }
    .message-actions button[data-action="cancel"] {
      background: rgba(112, 118, 136, 0.22);
      color: #d5ddff;
    }

    .empty-state { padding: 24px; text-align: center; color: rgba(201, 208, 230, 0.7); font-size: 14px; }

    .preview-block {
      display: flex;
      flex-direction: column;
      gap: 14px;
      border: 1px solid rgba(112, 118, 136, 0.22);
      border-radius: 16px;
      padding: 18px;
      background: rgba(12, 16, 28, 0.72);
    }
    .preview-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .preview-title { font-weight: 600; font-size: 15px; }
    .preview-sub { font-size: 12px; color: rgba(201, 208, 230, 0.68); }
    .preview-actions { display: flex; gap: 8px; }
    .preview-frame {
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(112, 118, 136, 0.26);
      background: radial-gradient(120% 120% at 50% 0%, rgba(124, 92, 255, 0.2), rgba(10, 12, 20, 0.9));
      aspect-ratio: 16 / 9;
      min-height: 220px;
    }

    @supports (color: color-mix(in srgb, red 50%, blue)) {
      .preview-frame {
        background: radial-gradient(120% 120% at 50% 0%, color-mix(in srgb, var(--accent) 18%, rgba(26, 28, 36, 0.6)), rgba(10, 12, 20, 0.9));
      }
    }
    .preview-frame iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: none;
      background: transparent;
      transition: opacity 0.24s var(--ease-smooth);
    }
    .preview-frame.is-loading::before,
    .preview-frame.is-loading::after {
      position: absolute;
      z-index: 2;
      pointer-events: none;
    }
    .preview-frame.is-loading::before {
      content: '';
      inset: 0;
      background: linear-gradient(180deg, rgba(9, 11, 18, 0.78), rgba(9, 11, 18, 0.92));
      backdrop-filter: blur(12px) saturate(1.1);
      -webkit-backdrop-filter: blur(12px) saturate(1.1);
      opacity: 0.9;
    }
    .preview-frame.is-loading::after {
      content: 'Loading preview…';
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 10px 22px 10px 42px;
      border-radius: 999px;
      background: rgba(28, 32, 48, 0.85);
      border: 1px solid rgba(124, 92, 255, 0.32);
      color: rgba(226, 230, 255, 0.92);
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.02em;
      box-shadow: 0 18px 40px rgba(7, 9, 20, 0.6);
    }
    .preview-frame.is-loading::after {
      position: relative;
    }
    .preview-frame.is-loading::after::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 18px;
      width: 16px;
      height: 16px;
      margin-top: -8px;
      border-radius: 50%;
      border: 2px solid rgba(158, 163, 196, 0.7);
      border-top-color: transparent;
      animation: panelBusySpin 0.85s linear infinite;
    }
    .preview-frame.is-loading iframe {
      opacity: 0.12;
      filter: blur(1px);
    }

    .preset-header { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .preset-header input {
      flex: 1 1 160px;
      min-width: 0;
    }
    .preset-header button { flex: 0 0 auto; }
    .preset-list { display: flex; flex-direction: column; gap: 12px; }
    .preset-card {
      border: 1px solid rgba(112, 118, 136, 0.25);
      border-radius: 12px;
      padding: 16px;
      background: rgba(18, 22, 34, 0.82);
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 14px;
      align-items: center;
    }
    .preset-title { font-weight: 600; font-size: 15px; color: #f6f7ff; }
    .preset-meta { font-size: 12px; color: rgba(201, 208, 230, 0.65); margin-top: 4px; }
    .preset-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .preset-actions button { border-radius: 10px; padding: 7px 12px; font-size: 12px; font-weight: 600; border: none; cursor: pointer; background: rgba(54, 62, 92, 0.9); color: #eef1ff; }
    .preset-actions button:hover { transform: translateY(-1px); box-shadow: 0 10px 22px rgba(18, 22, 34, 0.4); }
    .preset-hint { font-size: 12px; color: rgba(201, 208, 230, 0.68); margin-top: 6px; line-height: 1.4; }
    .preset-actions button[data-action="delete"] { background: rgba(255, 107, 107, 0.14); color: #ff8e8e; }

    .preset-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      background: rgba(6, 10, 22, 0.85);
      z-index: 1200;
    }

    @supports ((backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px))) {
      .preset-modal {
        background: rgba(6, 10, 22, 0.6);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }
    }
    .preset-modal.is-visible { display: flex; }
    .preset-modal__card {
      position: relative;
      width: min(420px, 100%);
      border-radius: var(--radius);
      border: 1px solid rgba(118, 136, 190, 0.35);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.05), transparent 28%) rgba(14, 18, 32, 0.95);
      box-shadow: 0 32px 70px rgba(8, 12, 30, 0.65);
      padding: 28px 32px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .preset-modal__title { font-size: 18px; font-weight: 600; color: var(--text); }
    .preset-modal__message {
      border: 1px solid var(--input-border);
      border-radius: 12px;
      padding: 12px 14px;
      background: rgba(12, 16, 28, 0.85);
      min-height: 48px;
      font-size: 14px;
      line-height: 1.5;
      color: var(--text);
      box-shadow: inset 0 1px 2px rgba(5, 7, 16, 0.4);
    }
    .preset-modal__message .small { color: rgba(201, 208, 230, 0.7); }
    .preset-modal__field { display: flex; flex-direction: column; gap: 8px; }
    .preset-modal__input { width: 100%; }
    .preset-modal__input.has-error {
      border-color: rgba(255, 107, 107, 0.7);
      box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.24);
    }
    .preset-modal__hint { font-size: 12px; color: rgba(201, 208, 230, 0.7); margin-top: -6px; }
    .preset-modal__hint.is-error { color: rgba(255, 152, 152, 0.85); }
    .preset-modal__actions { display: flex; justify-content: flex-end; gap: 10px; }

    .scene-header { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .scene-header input {
      flex: 1 1 160px;
      min-width: 0;
    }
    .scene-header button { flex: 0 0 auto; }
    .scene-list { display: flex; flex-direction: column; gap: 12px; }
    .scene-card {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 12px;
      padding: 18px;
      border-radius: 14px;
      border: 1px solid rgba(112, 118, 136, 0.32);
      background: rgba(20, 26, 44, 0.85);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04), 0 18px 38px rgba(5, 7, 16, 0.45);
    }
    .scene-title { font-weight: 600; font-size: 15px; color: #f6f7ff; }
    .scene-meta { font-size: 12px; color: rgba(201, 208, 230, 0.65); margin-top: 4px; }
    .scene-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .scene-actions button {
      border-radius: 10px;
      padding: 7px 12px;
      font-size: 12px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      background: rgba(54, 62, 92, 0.9);
      color: #eef1ff;
      transition: transform 0.12s ease, box-shadow 0.12s ease;
    }
    .scene-actions button:hover { transform: translateY(-1px); box-shadow: 0 10px 22px rgba(18, 22, 34, 0.4); }
    .scene-actions button[data-action="delete"] { background: rgba(255, 107, 107, 0.14); color: #ff8e8e; }

    .toast {
      position: fixed;
      left: 24px;
      bottom: 24px;
      background: var(--toast-bg);
      border: 1px solid rgba(112, 118, 136, 0.35);
      color: #fff;
      padding: 12px 16px;
      border-radius: 12px;
      opacity: 0;
      transform: translateY(12px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: none;
      font-size: 13px;
      box-shadow: 0 14px 30px rgba(5, 8, 22, 0.45);
    }
    .toast.show { opacity: 1; transform: translateY(0); }

    .boot-warning {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 12px 16px;
      background: #7f1d1d;
      color: #fef2f2;
      text-align: center;
      font-weight: 600;
      z-index: 1200;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
    }

    .boot-warning[hidden] {
      display: none;
    }

    .fx { display: inline-flex; position: relative; color: inherit; }
    .fx-letter { display: inline-block; --i: 0; will-change: transform, filter; }
    .fx.fx-sparkle { animation: gentlePulse 6s ease-in-out infinite; }
    .fx-rainbow .fx-letter {
      background-image: linear-gradient(
        120deg,
        color-mix(in srgb, var(--accent-bright) 70%, rgba(255, 255, 255, 0.1) 30%),
        color-mix(in srgb, var(--accent-contrast) 60%, rgba(8, 12, 22, 0.25) 40%),
        color-mix(in srgb, var(--accent-duo) 55%, rgba(10, 12, 24, 0.32) 45%)
      );
      background-size: 220% 100%;
      background-position: 0% 50%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: rainbowShift 3.6s linear infinite, subtleFloat 2s ease-in-out infinite;
      animation-delay: calc(var(--i) * -0.12s), calc(var(--i) * 0.08s);
      text-shadow:
        0 0 3px color-mix(in srgb, var(--accent) 26%, rgba(255, 255, 255, 0.25)),
        0 0 8px color-mix(in srgb, var(--accent-glow) 35%, rgba(0, 0, 0, 0.12));
      filter: saturate(1.08) brightness(1.04);
    }
    .fx-sparkle .fx-letter {
      background-image:
        radial-gradient(circle at 38% 62%, color-mix(in srgb, var(--accent-bright) 75%, white 25%) 0 18%, transparent 42%),
        radial-gradient(circle at 68% 32%, color-mix(in srgb, var(--accent-glow) 65%, rgba(255, 255, 255, 0.05)) 0 16%, transparent 40%),
        linear-gradient(120deg, color-mix(in srgb, var(--accent) 70%, rgba(255, 255, 255, 0.08)), color-mix(in srgb, var(--accent-contrast) 50%, rgba(8, 12, 22, 0.4)));
      background-size: 160% 160%, 220% 220%, 280% 100%;
      background-position: 0% 0%, 100% 100%, 0% 50%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: sparkleShift 4.2s linear infinite, subtleFloat 1.9s ease-in-out infinite;
      animation-delay: calc(var(--i) * -0.1s), calc(var(--i) * 0.07s);
      text-shadow:
        0 0 4px color-mix(in srgb, var(--accent) 28%, rgba(255, 255, 255, 0.3)),
        0 0 10px color-mix(in srgb, var(--accent-glow) 24%, rgba(0, 0, 0, 0.16));
      filter: saturate(1.1) contrast(1.05);
    }

    body.no-sparkle .fx-sparkle .fx-letter {
      background-image: linear-gradient(
        120deg,
        color-mix(in srgb, var(--accent-bright) 70%, rgba(255, 255, 255, 0.1) 30%),
        color-mix(in srgb, var(--accent) 55%, rgba(8, 12, 22, 0.25) 45%)
      );
      background-size: 220% 100%;
      background-position: 0% 50%;
      animation: rainbowShift 3.6s linear infinite, subtleFloat 2s ease-in-out infinite;
      animation-delay: calc(var(--i) * -0.12s), calc(var(--i) * 0.08s);
      text-shadow: 0 0 3px color-mix(in srgb, var(--accent) 22%, rgba(255, 255, 255, 0.25));
      filter: saturate(1.05) brightness(1.03);
    }

    .fx-bounce {
      display: inline-block;
      animation: enhancedBounce 2.2s ease-in-out infinite;
      transform-origin: center bottom;
      will-change: transform;
    }

    .fx-neon {
      color: color-mix(in srgb, var(--accent-bright) 72%, white 28%);
      text-shadow:
        0 0 2px color-mix(in srgb, var(--accent) 50%, rgba(255, 255, 255, 0.32)),
        0 0 6px color-mix(in srgb, var(--accent-glow) 40%, rgba(10, 14, 26, 0.4)),
        0 0 12px color-mix(in srgb, var(--accent) 28%, rgba(0, 0, 0, 0.18));
      animation: neonFlicker 3.4s ease-in-out infinite, gentlePulse 5.2s ease-in-out infinite;
    }

    .fx-glitch {
      position: relative;
      display: inline-block;
      color: #f4f7ff;
      animation: dataGlitch 2.4s steps(2, end) infinite;
    }

    .fx-glitch::before,
    .fx-glitch::after {
      content: attr(data-text);
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0.5;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .fx-glitch::before {
      color: color-mix(in srgb, var(--accent-duo) 70%, rgba(255, 255, 255, 0.2));
    }

    .fx-glitch::after {
      color: color-mix(in srgb, var(--accent-contrast) 70%, rgba(255, 255, 255, 0.2));
    }

    .highlight { color: #fbbf24; font-weight: 600; }
    strong { font-weight: 700; }
    em { font-style: italic; }

    @keyframes rainbowShift {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }
    @keyframes sparkleShift {
      0% { background-position: 0% 0%, 100% 100%, 50% 0%, 0% 0%; }
      25% { background-position: 50% 50%, 0% 0%, 100% 50%, 50% 50%; }
      50% { background-position: 100% 100%, 50% 50%, 0% 100%, 100% 100%; }
      75% { background-position: 50% 0%, 100% 0%, 50% 50%, 150% 50%; }
      100% { background-position: 0% 0%, 100% 100%, 50% 0%, 200% 0%; }
    }
    @keyframes subtleFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-1px); }
    }
    @keyframes gentlePulse {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-1px); }
    }
    @keyframes enhancedBounce {
      0%, 100% { transform: translateY(0); }
      30% { transform: translateY(-3px); }
      55% { transform: translateY(-4px); }
      75% { transform: translateY(-1px); }
    }
    @keyframes neonFlicker {
      0%, 100% {
        text-shadow:
          0 0 1px color-mix(in srgb, var(--accent) 58%, rgba(255, 255, 255, 0.28)),
          0 0 4px color-mix(in srgb, var(--accent-glow) 48%, rgba(12, 16, 28, 0.4)),
          0 0 8px color-mix(in srgb, var(--accent) 36%, rgba(0, 0, 0, 0.18));
      }
      50% {
        text-shadow:
          0 0 2px color-mix(in srgb, var(--accent-bright) 70%, rgba(255, 255, 255, 0.36)),
          0 0 6px color-mix(in srgb, var(--accent-glow) 60%, rgba(10, 14, 26, 0.3)),
          0 0 12px color-mix(in srgb, var(--accent) 40%, rgba(0, 0, 0, 0.2));
      }
    }
    @keyframes dataGlitch {
      0%, 100% { transform: translate(0); filter: hue-rotate(0deg); }
      12% { transform: translate(-1px, 1px); filter: hue-rotate(-4deg); }
      24% { transform: translate(1px, -1px); filter: hue-rotate(5deg); }
      38% { transform: translate(-1.5px, 0); filter: hue-rotate(-6deg); }
      52% { transform: translate(0.5px, 1px); filter: hue-rotate(4deg); }
      68% { transform: translate(1.5px, -1px); filter: hue-rotate(-3deg); }
      82% { transform: translate(-0.8px, 0); filter: hue-rotate(3deg); }
      92% { transform: translate(0.8px, -0.6px); filter: hue-rotate(-2deg); }
    }

    .slate-panel-controls {
      display: grid;
      gap: 20px;
    }

    .slate-toggles {
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
      align-items: center;
      font-size: 13px;
      color: var(--subtle);
    }

    .slate-toggles label {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 14px;
      border-radius: 12px;
      background: rgba(30, 34, 52, 0.6);
      border: 1px solid rgba(110, 128, 182, 0.26);
      transition: border 0.2s ease, background 0.2s ease, transform 0.2s ease;
    }

    .slate-toggles label:hover {
      transform: translateY(-1px);
      border-color: rgba(124, 92, 255, 0.36);
      background: rgba(38, 44, 70, 0.72);
    }

    @supports (color: color-mix(in srgb, red 50%, blue)) {
      .slate-toggles label:hover {
        border-color: color-mix(in srgb, var(--accent) 32%, rgba(110, 128, 182, 0.36));
      }
    }

    .slate-toggles input[type='checkbox'] {
      accent-color: var(--accent);
    }

    .slate-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 18px;
    }

    .slate-preview {
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 10px;
      border-radius: 0;
      padding: 16px 18px;
      padding-left: 20px;
      background: linear-gradient(150deg, rgba(30, 34, 50, 0.94), rgba(14, 18, 28, 0.9));
      border: 1px solid rgba(124, 144, 200, 0.28);
      box-shadow: 0 18px 40px rgba(6, 10, 28, 0.42);
      min-height: 120px;
      opacity: 0;
      transform: translate3d(0, 12px, 0);
      transition: opacity 0.32s ease, transform 0.32s ease;
    }

    .slate-preview.is-visible {
      opacity: 1;
      transform: translate3d(0, 0, 0);
    }

    .slate-preview::before,
    .slate-preview::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .slate-preview::before {
      width: 3px;
      left: 0;
      background: linear-gradient(172deg, rgba(124, 92, 255, 0.75), rgba(12, 18, 32, 0.9));
      opacity: 0.95;
    }

    @supports (color: color-mix(in srgb, red 50%, blue)) {
      .slate-preview::before {
        background: linear-gradient(172deg, color-mix(in srgb, var(--accent) 80%, rgba(255, 255, 255, 0.3)), color-mix(in srgb, var(--accent) 52%, rgba(12, 18, 32, 0.9)));
      }
    }

    .slate-preview::after {
      background: linear-gradient(130deg, rgba(255, 255, 255, 0.18), transparent 70%);
      opacity: 0.25;
    }

    .slate-preview.is-empty {
      justify-content: center;
      text-align: center;
      color: rgba(200, 208, 230, 0.72);
      gap: 8px;
    }

    .slate-preview.is-disabled {
      opacity: 0.55;
    }

    .slate-preview-row {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }

    .slate-preview-row.refresh {
      animation: slatePreviewRefresh 0.32s ease;
    }

    .slate-preview-pill {
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: color-mix(in srgb, var(--accent) 70%, rgba(255, 255, 255, 0.65));
    }

    .slate-preview-title {
      font-size: 15px;
      font-weight: 600;
      color: rgba(244, 246, 255, 0.96);
      letter-spacing: 0.02em;
    }

    .slate-preview[data-type='clock'] .slate-preview-title {
      font-size: 18px;
      font-variant-numeric: tabular-nums;
      letter-spacing: 0.06em;
    }

    .slate-preview-subtitle {
      font-size: 12px;
      color: rgba(210, 216, 234, 0.8);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .slate-preview-meta {
      font-size: 11px;
      color: rgba(182, 196, 226, 0.68);
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .slate-preview-dots {
      position: relative;
      z-index: 1;
      display: flex;
      gap: 4px;
      margin-top: auto;
      justify-content: flex-end;
    }

    .slate-preview-dot {
      width: 4px;
      height: 4px;
      border-radius: 0;
      background: rgba(236, 238, 255, 0.38);
      opacity: 0.45;
      transition: opacity 0.25s ease;
    }

    .slate-preview-dot.is-active {
      opacity: 1;
      background: rgba(124, 92, 255, 0.68);
    }

    @supports (color: color-mix(in srgb, red 50%, blue)) {
      .slate-preview-dot.is-active {
        background: color-mix(in srgb, var(--accent) 72%, rgba(255, 255, 255, 0.6));
      }
    }

    .is-hidden {
      display: none !important;
    }

    @keyframes slatePreviewRefresh {
      0% { opacity: 0; transform: translate3d(0, 10px, 0) scale(0.98); }
      100% { opacity: 1; transform: translate3d(0, 0, 0) scale(1); }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.001ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.001ms !important;
      }
      .panel::before { animation: none; }
      .slate-preview::before,
      .slate-preview::after,
      .slate-preview-row,
      .slate-preview-dot { animation: none !important; transition: none !important; }
    }

    @media (max-width: 960px) {
      body { padding: 32px 16px 48px; }
      .panel { padding: 24px; }
    }

    @media (max-width: 640px) {
      .message-item { grid-template-columns: 1fr; }
      .message-actions { justify-content: flex-end; }
      .preset-card { grid-template-columns: 1fr; }
      .preset-actions { justify-content: flex-end; }
      .scene-card { grid-template-columns: 1fr; }
      .scene-actions { justify-content: flex-end; }
    }
  </style>
</head>
<body>
  <!-- Loading State Overlay -->
  <div id="loadingOverlay" style="
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    color: white;
    font-family: system-ui, -apple-system, sans-serif;
    display: none;
  ">
    <div style="text-align: center;">
      <div style="
        width: 40px;
        height: 40px;
        border: 3px solid #333;
        border-top-color: #007cba;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 16px;
      "></div>
      <div id="loadingText">Loading...</div>
    </div>
  </div>

  <!-- Error Toast Container -->
  <div id="errorToastContainer" style="
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 9999;
    max-width: 400px;
  "></div>

  <!-- Connection Status Indicator -->
  <div id="connectionStatus" style="
    position: fixed;
    bottom: 20px;
    right: 20px;
    padding: 8px 12px;
    background: #28a745;
    color: white;
    border-radius: 4px;
    font-size: 12px;
    font-family: system-ui, -apple-system, sans-serif;
    display: none;
  ">
    Connected
  </div>

  <style>
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .error-toast {
      background: #dc3545;
      color: white;
      padding: 12px 16px;
      border-radius: 4px;
      margin-bottom: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      animation: slideIn 0.3s ease;
      cursor: pointer;
    }
    
    .error-toast:hover {
      opacity: 0.9;
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    .success-toast {
      background: #28a745;
      color: white;
      padding: 12px 16px;
      border-radius: 4px;
      margin-bottom: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      animation: slideIn 0.3s ease;
      cursor: pointer;
    }
    
    .connection-status--connected {
      background: #28a745 !important;
    }
    
    .connection-status--disconnected {
      background: #dc3545 !important;
    }
    
    .connection-status--reconnecting {
      background: #ffc107 !important;
      color: #212529 !important;
    }
  </style>

  <div class="app">
    <div class="panel panel--accent">
      <div class="header">
        <div class="title-block">
          <h1>OBS Ticker Dashboard</h1>
          <p class="subtitle">Curate ticker copy, configure overlay styling, and manage presets in one place. Minutes-based intervals and rich text modifiers are supported.</p>
        </div>
        <div class="overlay-chip" title="Click to copy" id="overlayUrlChip">
          <strong>Overlay URL</strong>
          <span id="overlayUrlText">–</span>
        </div>
      </div>

      <div class="status-ribbon" aria-live="polite">
        <div class="status-item"><span class="status-dot" id="statusActive"></span><span>State</span><span class="status-value" id="statusActiveText">Inactive</span></div>
        <div class="status-item"><span>Messages</span><span class="status-value" id="statusMessageCount">0</span></div>
        <div class="status-item"><span class="status-dot" id="statusBrbDot"></span><span>BRB</span><span class="status-value" id="statusBrb">Hidden</span></div>
        <div class="status-item">
          <span class="status-dot status-dot--warning" id="statusServerDot"></span>
          <span>Server</span>
          <span class="status-value status-value--warning" id="statusServer">Checking…</span>
        </div>
        <div class="status-item"><span>Last Update</span><span class="status-value" id="statusUpdated">–</span></div>
      </div>

      <details class="config-drawer" id="connectionDrawer">
        <summary>
          <span>Connection &amp; Data</span>
          <span class="config-drawer__summary-sub">Server URL, auto-start, and state management</span>
        </summary>
        <div class="config-drawer__content">
          <div class="config-drawer__field">
            <label for="serverUrl">Server URL</label>
            <input type="text" id="serverUrl" placeholder="http://127.0.0.1:3000" aria-describedby="serverUrlStatus" />
            <p class="control-hint control-hint--status" id="serverUrlStatus" hidden aria-live="polite"></p>
          </div>
          <label class="config-drawer__toggle" for="autoStart">
            <input type="checkbox" id="autoStart" />
            <span>Auto-start when messages exist</span>
          </label>
          <div class="config-drawer__actions">
            <button type="button" class="btn btn-ghost" id="exportState">Export state</button>
            <button type="button" class="btn btn-ghost" id="importState">Import state</button>
            <input type="file" id="importStateInput" accept="application/json,.json" hidden />
          </div>
        </div>
      </details>
    </div>

    <div class="layout-grid">
      <div class="layout-col layout-col--primary">
        <section class="panel panel--neutral" id="tickerPanel">
          <div>
            <div class="section-title">Ticker Timing</div>
            <div class="section-sub">Control rotation and cooldown cadence. Intervals are stored in minutes (0–60) and converted server-side.</div>
          </div>
          <div class="control-grid">
            <div class="control-group">
              <label for="displayDuration">Display Duration (seconds)</label>
              <input type="number" id="displayDuration" min="2" max="90" step="1" value="5" />
            </div>
            <div class="control-group">
              <label for="intervalMinutes">Interval Between Messages (minutes)</label>
              <input type="number" id="intervalMinutes" min="0" max="60" step="0.01" value="0" />
            </div>
          </div>
          <div class="actions">
            <button class="btn btn-success" id="startBtn">Start</button>
            <button class="btn btn-danger" id="stopBtn">Stop</button>
            <div class="spacer"></div>
            <button class="btn btn-secondary" id="refreshBtn">Refresh</button>
          </div>
        </section>

        <section class="panel panel--neutral" id="messagesPanel">
          <div>
            <div class="section-title">Ticker Messages</div>
            <div class="section-sub">Use modifiers like <code>~~rainbow~~</code>, <code>%%spark%%</code>, <code>^^bounce^^</code>, <code>==neon==</code>, and <code>!!glitch!!</code>. Markdown-style <code>**bold**</code> and <code>*italic*</code> are supported.</div>
          </div>
          <form class="message-composer" id="messageForm">
            <input type="text" id="newMessage" placeholder="Add a ticker message…" autocomplete="off" />
            <button type="submit" class="btn" id="addMessageButton">Add</button>
            <button type="button" class="btn btn-secondary" id="clearMessages">Clear</button>
            <button type="button" class="btn btn-ghost" id="exportMessages">Export</button>
            <button type="button" class="btn btn-ghost" id="importMessages">Import</button>
          </form>
          <div class="message-list" id="messageList">
            <div class="empty-state">No messages yet — add a line above or load a preset.</div>
          </div>
        </section>

        <section class="panel panel--muted" id="presetsPanel">
          <div>
            <div class="section-title">Message Presets</div>
            <div class="section-sub">Save frequently used rotations. Loading replaces the current queue; appending pushes messages to the bottom.</div>
          </div>
          <div class="preset-header">
            <input type="text" id="presetName" placeholder="Preset name" />
            <button class="btn" type="button" id="savePreset">Save Current Messages</button>
          </div>
          <div class="preset-list" id="presetList">
            <div class="empty-state">No presets saved yet.</div>
          </div>
        </section>

        <section class="panel panel--accent" id="scenesPanel">
          <div>
            <div class="section-title">Scene Presets</div>
            <div class="section-sub">Snapshot ticker queues with popup and theme settings so you can recall complete looks for recurring segments.</div>
          </div>
          <div class="scene-header">
            <input type="text" id="sceneName" placeholder="Scene name" />
            <button class="btn" type="button" id="saveScene">Save Scene</button>
          </div>
          <div class="scene-list" id="sceneList">
            <div class="empty-state">No scenes saved yet.</div>
          </div>
        </section>
      </div>

      <div class="layout-col layout-col--secondary">
        <div class="panel-switcher" id="controlPanelSwitcher">
          <div class="panel-switcher__tabs" role="tablist" aria-label="Overlay and standby controls">
            <button type="button" class="panel-switcher__tab is-active" role="tab" aria-selected="true" aria-controls="overlayPanel" id="panelTabOverlay" data-panel-target="overlayPanel">Overlay</button>
            <button type="button" class="panel-switcher__tab" role="tab" aria-selected="false" aria-controls="slatePanel" id="panelTabSlate" data-panel-target="slatePanel">Slate</button>
            <button type="button" class="panel-switcher__tab" role="tab" aria-selected="false" aria-controls="popupPanel" id="panelTabPopup" data-panel-target="popupPanel">Popup</button>
            <button type="button" class="panel-switcher__tab" role="tab" aria-selected="false" aria-controls="brbPanel" id="panelTabBrb" data-panel-target="brbPanel">BRB</button>
          </div>
          <div class="panel-switcher__content">
            <section class="panel panel--accent panel-switcher__panel is-active" id="overlayPanel" role="tabpanel" aria-labelledby="panelTabOverlay" aria-hidden="false">
          <div>
            <div class="section-title">Overlay Styling</div>
            <div class="section-sub">Adjust label, highlights, animation preferences, and scale for the browser source preview.</div>
          </div>
          <div class="control-grid">
            <div class="control-group">
              <label for="overlayLabel">Overlay Label</label>
              <input type="text" id="overlayLabel" maxlength="48" />
              <p class="control-hint">Overlay label can be up to 48 characters.</p>
            </div>
            <div class="control-group">
              <label for="overlayAccent">Accent Colour</label>
              <div class="accent-inputs" id="overlayAccentGroup">
                <input type="color" id="overlayAccentPicker" aria-label="Accent colour" value="#38bdf8" />
                <input type="text" id="overlayAccent" placeholder="#38bdf8" autocomplete="off" spellcheck="false" maxlength="64" />
              </div>
              <p class="control-hint" id="overlayAccentHint">Accepts hex (#ff0000), rgb(a), hsl(a), or named colours.</p>
            </div>
            <div class="control-group">
              <label for="overlayAccentSecondary">Accent Colour B</label>
              <div class="accent-inputs" id="overlayAccentSecondaryGroup">
                <input type="color" id="overlayAccentSecondaryPicker" aria-label="Secondary accent colour" value="#f472b6" />
                <input type="text" id="overlayAccentSecondary" placeholder="#f472b6" autocomplete="off" spellcheck="false" maxlength="64" />
              </div>
              <p class="control-hint" id="overlayAccentSecondaryHint">Optional second highlight used by Duotone Fusion and blended gradients.</p>
            </div>
            <div class="control-group">
              <label for="highlightWords">Highlight Words (comma separated)</label>
              <input type="text" id="highlightWords" placeholder="YouTube,Twitch,breaking" maxlength="512" />
              <p class="control-hint" id="highlightWordsHint" aria-live="polite">Highlight words can be up to 512 characters. 512 characters remaining.</p>
            </div>
          </div>
          <div class="control-group">
            <label for="scaleRange">Overlay Scale</label>
            <div class="segment-row" style="flex-wrap: nowrap; gap: 12px; align-items: center;">
              <input type="range" id="scaleRange" min="0.75" max="2.5" step="0.05" value="1.75" />
              <input type="number" id="scaleNumber" min="0.75" max="2.5" step="0.05" value="1.75" style="max-width: 90px;" />
            </div>
          </div>
          <div class="control-group">
            <label for="popupScaleRange">Popup Scale</label>
            <div class="segment-row" style="flex-wrap: nowrap; gap: 12px; align-items: center;">
              <input type="range" id="popupScaleRange" min="0.6" max="1.5" step="0.05" value="1" />
              <input type="number" id="popupScaleNumber" min="0.6" max="1.5" step="0.05" value="1" style="max-width: 90px;" />
            </div>
            <p class="control-hint">Shrink or grow the popup independently of the ticker.</p>
          </div>
          <div class="control-group">
            <label>Position</label>
            <div class="segment-row" id="positionButtons">
              <button type="button" class="segment-button" data-position="bottom">Bottom</button>
              <button type="button" class="segment-button" data-position="top">Top</button>
            </div>
          </div>
          <div class="control-group">
            <label>Animation Mode</label>
            <div class="segment-row" id="modeButtons">
              <button type="button" class="segment-button" data-mode="auto">Auto</button>
              <button type="button" class="segment-button" data-mode="marquee">Marquee</button>
              <button type="button" class="segment-button" data-mode="chunk">Chunk</button>
            </div>
          </div>
          <div class="control-group">
            <label>Theme</label>
              <div class="segment-row" id="themeButtons">
                <button type="button" class="segment-button" data-theme="midnight-glass">Midnight Glass</button>
                <button type="button" class="segment-button" data-theme="aurora-night">Aurora Night</button>
                <button type="button" class="segment-button" data-theme="nexus-grid">Nexus Grid</button>
                <button type="button" class="segment-button" data-theme="zen-flow">Zen Flow</button>
                <button type="button" class="segment-button" data-theme="duotone-fusion">Duotone Fusion</button>
              </div>
              <div class="theme-notes">
                <span><strong>Midnight Glass</strong> frosted panes with ambient PixiJS particles</span>
                <span><strong>Aurora Night</strong> flowing shader ribbons reacting to your accent colours</span>
                <span><strong>Nexus Grid</strong> animated network lattice with responsive nodes</span>
                <span><strong>Zen Flow</strong> tranquil Lottie morphing shapes for calm motion</span>
                <span><strong>Duotone Fusion</strong> bold dual-colour gradients and reactive highlights</span>
              </div>
          </div>
          <div class="toggle-row">
            <label><input type="checkbox" id="accentAnimToggle" checked /> Accent shimmer</label>
            <label><input type="checkbox" id="sparkleToggle" checked /> Sparkle effects</label>
          </div>
          <div class="actions actions--overlay-hint">
            <button class="btn btn-ghost" id="copyOverlay">Copy URL</button>
            <p class="control-hint">Use this in an OBS Browser Source.</p>
          </div>
          <div class="preview-block">
            <div class="preview-toolbar">
              <div>
                <div class="preview-title">Live Preview</div>
                <div class="preview-sub">Embeds the overlay URL above so changes appear instantly.</div>
              </div>
              <div class="preview-actions">
                <button type="button" class="btn btn-secondary" id="reloadPreview">Reload</button>
                <button type="button" class="btn btn-ghost" id="openOverlay">Open in new tab</button>
              </div>
            </div>
            <div class="preview-frame">
              <iframe id="overlayPreview" title="Overlay preview" loading="lazy" sandbox="allow-same-origin allow-scripts"></iframe>
            </div>
          </div>
            </section>

            <section class="panel panel--neutral panel-switcher__panel" id="slatePanel" role="tabpanel" aria-labelledby="panelTabSlate" aria-hidden="true" hidden>
          <div>
            <div class="section-title">Segment Slate</div>
            <div class="section-sub">Curate the compact top-right slate with UK time and short notices such as next-up cues or sponsor callouts.</div>
          </div>
          <div class="slate-panel-controls">
            <div class="slate-toggles">
              <label><input type="checkbox" id="slateEnabled" /> Enable segment slate</label>
              <label><input type="checkbox" id="slateShowClock" /> Show clock</label>
            </div>
            <div class="slate-grid">
              <div class="control-group">
                <label for="slateRotation">Rotation Interval (seconds)</label>
                <div class="segment-row" style="gap: 12px; align-items: center;">
                  <input type="range" id="slateRotation" min="4" max="900" step="1" value="12" />
                  <input type="number" id="slateRotationNumber" min="4" max="900" step="1" value="12" style="max-width: 90px;" />
                </div>
                <p class="control-hint">Supports gaps of up to 900 seconds (15 minutes).</p>
              </div>
              <div class="control-group">
                <label for="slateClockLabel">Clock label</label>
                <input type="text" id="slateClockLabel" placeholder="UK TIME" />
              </div>
              <div class="control-group">
                <label for="slateClockSubtitle">Clock subtitle</label>
                <input type="text" id="slateClockSubtitle" placeholder="UK time" />
              </div>
              <div class="control-group">
                <label for="slateNextLabel">Next-up label</label>
                <input type="text" id="slateNextLabel" placeholder="Next up" />
              </div>
              <div class="control-group">
                <label for="slateNextTitle">Next-up title</label>
                <input type="text" id="slateNextTitle" placeholder="Guest interview" />
              </div>
              <div class="control-group">
                <label for="slateNextSubtitle">Next-up details</label>
                <input type="text" id="slateNextSubtitle" placeholder="Happening after the break" />
              </div>
              <div class="control-group">
                <label for="slateSponsorLabel">Sponsor label</label>
                <input type="text" id="slateSponsorLabel" placeholder="Sponsor" />
              </div>
              <div class="control-group">
                <label for="slateSponsorName">Sponsor name</label>
                <input type="text" id="slateSponsorName" placeholder="Acme Co." />
              </div>
              <div class="control-group">
                <label for="slateSponsorTagline">Sponsor tagline</label>
                <input type="text" id="slateSponsorTagline" placeholder="Proudly supporting tonight's stream" />
              </div>
              <div class="control-group">
                <label for="slateNotesLabel">Spotlight label</label>
                <input type="text" id="slateNotesLabel" placeholder="Spotlight" />
              </div>
              <div class="control-group">
                <label for="slateNotes">Spotlight notes (one per line)</label>
                <textarea id="slateNotes" placeholder="Follow @channelhandle&#10;Share your questions with #AskLive"></textarea>
                <p class="control-hint" id="slateNotesHint">Up to six lines (200 characters each) rotate alongside the clock card.</p>
              </div>
            </div>
            <div class="slate-preview is-empty is-visible" id="slatePreview">
              <div class="slate-preview-row" id="slatePreviewContent">
                <span class="slate-preview-pill">Segment slate</span>
                <div class="slate-preview-title">Add upcoming items or notes to preview the slate.</div>
                <div class="slate-preview-subtitle">Clock and messages will rotate automatically.</div>
                <div class="slate-preview-meta">Rotation preview</div>
              </div>
              <div class="slate-preview-dots" id="slatePreviewDots"></div>
            </div>
          </div>
            </section>

            <section class="panel panel--neutral panel-switcher__panel" id="popupPanel" role="tabpanel" aria-labelledby="panelTabPopup" aria-hidden="true" hidden>
          <div>
            <div class="section-title">Popup Message</div>
            <div class="section-sub">Send a top-left callout styled like the ticker. Supports the same text modifiers.</div>
          </div>
          <textarea id="popupText" placeholder="Enter popup message…"></textarea>
          <div class="popup-actions">
            <label class="popup-toggle"><input type="checkbox" id="popupActive" /> Display popup</label>
            <div class="popup-duration">
              <label for="popupDuration">Auto-hide (seconds)</label>
              <input type="number" id="popupDuration" min="0" max="600" step="1" placeholder="Leave blank to stay visible" inputmode="numeric" />
            </div>
            <div class="popup-buttons">
              <button class="btn btn-secondary" type="button" id="clearPopup">Clear</button>
              <button class="btn" type="button" id="savePopup">Update Popup</button>
            </div>
          </div>
          <div class="popup-countdown">
            <label class="popup-countdown-toggle"><input type="checkbox" id="popupCountdownEnabled" /> Append countdown timer</label>
            <div class="popup-countdown-input">
              <label for="popupCountdownTarget">Countdown target</label>
              <input type="datetime-local" id="popupCountdownTarget" />
            </div>
          </div>
          <div class="popup-preview is-empty" id="popupPreview">Popup preview</div>
          <div class="popup-meta" id="popupMeta">Popup hidden</div>
            </section>

            <section class="panel panel--muted panel-switcher__panel" id="brbPanel" role="tabpanel" aria-labelledby="panelTabBrb" aria-hidden="true" hidden>
          <div>
            <div class="section-title">BRB Message</div>
            <div class="section-sub">Manage the standby banner shared with the overlay output.</div>
          </div>
          <textarea id="brbText" placeholder="Enter BRB message…"></textarea>
          <div class="brb-actions">
            <label class="brb-toggle"><input type="checkbox" id="brbActive" /> Show BRB message</label>
            <div class="spacer"></div>
            <button class="btn btn-secondary" type="button" id="brbClear">Clear</button>
            <button class="btn" type="button" id="brbSave">Update BRB</button>
          </div>
          <div class="brb-status" id="brbStatus">BRB hidden</div>
            </section>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="preset-modal" id="presetMessageModal" aria-hidden="true">
    <div class="preset-modal__card" role="dialog" aria-modal="true" aria-labelledby="presetModalTitle" aria-describedby="presetModalHint">
      <div class="preset-modal__title" id="presetModalTitle">Save message to presets</div>
      <div class="preset-modal__message" id="presetModalPreview"><span class="small">Select a message to begin.</span></div>
      <div class="preset-modal__field">
        <label for="presetModalName">Preset name</label>
        <input type="text" class="preset-modal__input" id="presetModalName" maxlength="80" autocomplete="off" spellcheck="false" />
      </div>
      <p class="preset-modal__hint" id="presetModalHint">Preset names can be up to 80 characters.</p>
      <div class="preset-modal__actions">
        <button type="button" class="btn btn-secondary" id="presetModalCancel">Cancel</button>
        <button type="button" class="btn" id="presetModalSave">Save preset</button>
      </div>
    </div>
  </div>

  <div class="boot-warning" id="bootWarning" role="alert" hidden></div>
  <div class="toast" id="toast"></div>

  <script src="js/shared-config.js"></script>
  <script src="js/shared-utils.js"></script>
  <script src="js/request-client.js"></script>
  <script src="js/client-normalisers.js"></script>
  <script src="js/state-manager.js"></script>
  <script src="js/ticker-websocket.js"></script>
  <script src="js/popup-manager.js"></script>
  <script src="js/brb-manager.js"></script>
  <script src="js/slate-manager.js"></script>
  <script src="js/dashboard-init.js"></script>

  <script>
    // Enhanced Loading States and Error Handling System
    var LoadingManager = {
      overlay: null,
      text: null,
      
      init: function() {
        this.overlay = document.getElementById('loadingOverlay');
        this.text = document.getElementById('loadingText');
      },
      
      show: function(message) {
        if (!this.overlay) this.init();
        this.text.textContent = message || 'Loading...';
        this.overlay.style.display = 'flex';
      },
      
      hide: function() {
        if (!this.overlay) this.init();
        this.overlay.style.display = 'none';
      },
      
      update: function(message) {
        if (!this.text) this.init();
        this.text.textContent = message;
      }
    };
    
    var ToastManager = {
      container: null,
      
      init: function() {
        this.container = document.getElementById('errorToastContainer');
      },
      
      show: function(message, type, duration) {
        if (!this.container) this.init();
        type = type || 'error';
        duration = duration || 5000;
        
        var toast = document.createElement('div');
        toast.className = type + '-toast';
        toast.textContent = message;
        
        var self = this;
        toast.addEventListener('click', function() {
          self.remove(toast);
        });
        
        this.container.appendChild(toast);
        
        setTimeout(function() {
          self.remove(toast);
        }, duration);
      },
      
      remove: function(toast) {
        if (toast && toast.parentNode) {
          toast.style.animation = 'slideIn 0.3s ease reverse';
          setTimeout(function() {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 300);
        }
      },
      
      error: function(message, duration) {
        this.show(message, 'error', duration);
      },
      
      success: function(message, duration) {
        this.show(message, 'success', duration);
      }
    };
    
    var ConnectionManager = {
      indicator: null,
      status: 'disconnected',
      
      init: function() {
        this.indicator = document.getElementById('connectionStatus');
      },
      
      setStatus: function(status, message) {
        if (!this.indicator) this.init();
        this.status = status;
        
        this.indicator.className = 'connection-status--' + status;
        this.indicator.textContent = message || status.charAt(0).toUpperCase() + status.slice(1);
        this.indicator.style.display = 'block';
        
        if (status === 'connected') {
          setTimeout(function() {
            if (ConnectionManager.indicator) {
              ConnectionManager.indicator.style.display = 'none';
            }
          }, 3000);
        }
      }
    };
    
    // Enhanced Error Handling
    function handleNetworkError(error, context) {
      console.error('[Dashboard] Network error in ' + context + ':', error);
      
      var message = 'Network error';
      if (error.message) {
        if (error.message.includes('timeout')) {
          message = 'Request timed out - please try again';
        } else if (error.message.includes('abort')) {
          message = 'Request was cancelled';
        } else if (error.message.includes('fetch')) {
          message = 'Unable to connect to server';
        } else {
          message = error.message;
        }
      }
      
      ToastManager.error(message + ' (' + context + ')');
      return false;
    }
    
    // Enhanced Promise utilities for ES5 compatibility
    function promiseTimeout(promise, timeoutMs, errorMessage) {
      timeoutMs = timeoutMs || 10000;
      errorMessage = errorMessage || 'Operation timed out';
      
      return new Promise(function(resolve, reject) {
        var timeoutId = setTimeout(function() {
          reject(new Error(errorMessage));
        }, timeoutMs);
        
        promise.then(
          function(result) {
            clearTimeout(timeoutId);
            resolve(result);
          },
          function(error) {
            clearTimeout(timeoutId);
            reject(error);
          }
        );
      });
    }
    
    function retryOperation(operation, maxRetries, delay) {
      maxRetries = maxRetries || 3;
      delay = delay || 1000;
      
      return new Promise(function(resolve, reject) {
        var attempt = 0;
        
        function tryOperation() {
          attempt++;
          operation().then(resolve).catch(function(error) {
            if (attempt < maxRetries) {
              setTimeout(tryOperation, delay * attempt);
            } else {
              reject(error);
            }
          });
        }
        
        tryOperation();
      });
    }

    var TickerShared = window.TickerShared || {};
    var OVERLAY_THEMES = TickerShared.OVERLAY_THEMES;
    var clampDurationSeconds = TickerShared.clampDurationSeconds;
    var clampIntervalSeconds = TickerShared.clampIntervalSeconds;
    var clampScaleValue = TickerShared.clampScaleValue;
    var clampPopupScaleValue = TickerShared.clampPopupScaleValue;
    var clampSlateRotationSeconds = TickerShared.clampSlateRotationSeconds;
    var normaliseHighlightList = TickerShared.normaliseHighlightList;
    var sharedNormaliseMode = TickerShared.normaliseMode;
    var sharedNormalisePosition = TickerShared.normalisePosition;
    var sharedNormaliseTheme = TickerShared.normaliseTheme;
    var normaliseSlateNotes = TickerShared.normaliseSlateNotes;
    var sharedNormaliseServerBase = TickerShared.normaliseServerBase;
    var sharedIsSafeCssColor = TickerShared.isSafeCssColor;

    var sharedConfigWindow = window.SharedConfig || {};
    var normaliserExports = window.TickerClientNormalisers || {};
    var BASE_DEFAULT_OVERLAY = normaliserExports.DEFAULT_OVERLAY;
    var BASE_DEFAULT_POPUP = normaliserExports.DEFAULT_POPUP;
    var BASE_DEFAULT_SLATE = normaliserExports.DEFAULT_SLATE;
    var BASE_DEFAULT_HIGHLIGHTS = normaliserExports.DEFAULT_HIGHLIGHTS;
    var BASE_DEFAULT_HIGHLIGHT_STRING = normaliserExports.DEFAULT_HIGHLIGHT_STRING;
    var BASE_THEME_OPTIONS = normaliserExports.THEME_OPTIONS;
    var EXPORTED_MAX_MESSAGES = normaliserExports.MAX_MESSAGES;
    var EXPORTED_MAX_MESSAGE_LENGTH = normaliserExports.MAX_MESSAGE_LENGTH;
    var EXPORTED_MAX_POPUP_SECONDS = normaliserExports.MAX_POPUP_SECONDS;
    var EXPORTED_MAX_SLATE_TITLE_LENGTH = normaliserExports.MAX_SLATE_TITLE_LENGTH;
    var EXPORTED_MAX_SLATE_TEXT_LENGTH = normaliserExports.MAX_SLATE_TEXT_LENGTH;
    var EXPORTED_MAX_SLATE_NOTES = normaliserExports.MAX_SLATE_NOTES;
    var normaliseHighlightInput = normaliserExports.normaliseHighlightInput;
    var normaliseOverlayData = normaliserExports.normaliseOverlayData;
    var normalisePopupData = normaliserExports.normalisePopupData;
    var normaliseSlateNotesList = normaliserExports.normaliseSlateNotesList;
    var normaliseSlateData = normaliserExports.normaliseSlateData;
    var normaliseSceneEntry = normaliserExports.normaliseSceneEntry;
    var sanitiseMessages = normaliserExports.sanitiseMessages;

    var requestClientApi = window.RequestClient || {};
    var requestManager = typeof requestClientApi.create === 'function'
      ? requestClientApi.create({ defaultTimeoutMs: 8000 })
      : null;
    
    function RequestError(message, code, details) {
      Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
      this.name = 'RequestError';
      this.message = message || 'Request failed';
      this.code = code || 'request_error';
      details = details || {};
      if (details && typeof details === 'object') {
        for (var key in details) {
          if (details.hasOwnProperty(key)) {
            this[key] = details[key];
          }
        }
      }
    }
    RequestError.prototype = Object.create(Error.prototype);
    RequestError.prototype.constructor = RequestError;
    
    var RequestErrorCtor = typeof requestClientApi.RequestError === 'function'
      ? requestClientApi.RequestError
      : RequestError;

    function createFallbackTimeoutController(timeoutMs, upstreamSignal) {
      if (typeof AbortController !== 'function') {
        return { signal: upstreamSignal, cleanup: function() {} };
      }
      var numericTimeout = Number(timeoutMs);
      if (!Number.isFinite(numericTimeout) || numericTimeout <= 0) {
        return { signal: upstreamSignal, cleanup: function() {} };
      }

      var controller = new AbortController();
      var timeoutId = null;
      var upstreamAbortListener = null;

      if (upstreamSignal) {
        if (upstreamSignal.aborted) {
          controller.abort(upstreamSignal.reason);
        } else {
          upstreamAbortListener = () => controller.abort(upstreamSignal.reason);
          upstreamSignal.addEventListener('abort', upstreamAbortListener, { once: true });
        }
      }

      const timeoutError = new Error('Request timed out');
      timeoutError.name = 'TimeoutError';
      timeoutId = setTimeout(() => controller.abort(timeoutError), numericTimeout);

      return {
        signal: controller.signal,
        cleanup() {
          if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          if (upstreamAbortListener && upstreamSignal) {
            upstreamSignal.removeEventListener('abort', upstreamAbortListener);
            upstreamAbortListener = null;
          }
        }
      };
    }

    async function performFallbackFetch(url, init = {}, timeoutMs) {
      const controller = createFallbackTimeoutController(timeoutMs, init.signal);
      const mergedInit = { ...init };
      if (controller.signal) {
        mergedInit.signal = controller.signal;
      }
      try {
        const response = await fetch(url, mergedInit);
        return { response, cleanup: controller.cleanup };
      } catch (error) {
        controller.cleanup();
        if (error && (error.name === 'AbortError' || error.name === 'TimeoutError')) {
          throw new RequestErrorCtor('Request timed out', 'timeout', { url });
        }
        const message = error && error.message ? error.message : 'Network request failed';
        throw new RequestErrorCtor(message, 'network', { url, cause: error });
      }
    }

    function createAsyncQueue(options = {}) {
      if (requestManager && typeof requestManager.createQueue === 'function') {
        return requestManager.createQueue(options);
      }
      return {
        enqueue(task) {
          try {
            const result = task();
            return result && typeof result.then === 'function'
              ? result
              : Promise.resolve(result);
          } catch (error) {
            return Promise.reject(error);
          }
        }
      };
    }

    async function requestJson(url, options = {}) {
      if (requestManager) {
        return requestManager.requestJson(url, options);
      }
      const init = options.init || {};
      const timeoutMs = options.timeoutMs;
      const validate = options.validate;
      const { response, cleanup } = await performFallbackFetch(url, init, timeoutMs);
      let payload = null;
      const contentType = (response.headers && response.headers.get && response.headers.get('content-type')) || '';
      const expectsJson = /json/i.test(contentType || '');

      if (!response.ok) {
        if (expectsJson) {
          payload = await response.json().catch(() => null);
        } else {
          payload = await response.text().catch(() => null);
        }
        cleanup();
        const message = typeof payload === 'object' && payload && typeof payload.error === 'string'
          ? payload.error
          : `Request failed with status ${response.status}`;
        throw new RequestErrorCtor(message, 'http_error', { url, status: response.status, response: payload });
      }

      let data;
      try {
        data = await response.json();
      } catch (error) {
        cleanup();
        throw new RequestErrorCtor('Failed to parse response', 'parse_error', { url, cause: error });
      }

      cleanup();

      if (typeof validate === 'function') {
        const result = validate(data);
        if (result !== true && result !== undefined) {
          const message = typeof result === 'string'
            ? result
            : (result && typeof result === 'object' && typeof result.message === 'string'
              ? result.message
              : 'Response validation failed');
          throw new RequestErrorCtor(message, 'invalid_response', { url, response: data });
        }
      }

      return data;
    }

    async function requestBlob(url, options = {}) {
      if (requestManager && typeof requestManager.request === 'function') {
        return requestManager.request(url, { ...options, parser: 'blob' });
      }
      const init = options.init || {};
      const timeoutMs = options.timeoutMs;
      const { response, cleanup } = await performFallbackFetch(url, init, timeoutMs);
      if (!response.ok) {
        let payload = null;
        try {
          payload = await response.text();
        } catch (err) {
          payload = null;
        }
        cleanup();
        const message = payload && typeof payload === 'string' && payload.trim()
          ? payload.trim()
          : `Request failed with status ${response.status}`;
        throw new RequestErrorCtor(message, 'http_error', { url, status: response.status, response: payload });
      }
      try {
        const blob = await response.blob();
        cleanup();
        return blob;
      } catch (error) {
        cleanup();
        throw new RequestErrorCtor('Failed to parse blob response', 'parse_error', { url, cause: error });
      }
    }

    function getLocalStorage() {
      try {
        if (typeof localStorage !== 'undefined' && localStorage) {
          return localStorage;
        }
      } catch (err) {
        console.warn('Local storage unavailable', err);
      }
      return null;
    }

    function safeSetText(target, value) {
      if (!target) return;
      const next = value == null ? '' : String(value);
      if (target.textContent !== next) {
        target.textContent = next;
      }
    }

    function safeSetValue(target, value) {
      if (!target) return;
      const next = value == null ? '' : String(value);
      if (target.value !== next) {
        target.value = next;
      }
    }

    function createCleanupBag() {
      const tasks = new Set();
      return {
        add(task) {
          if (typeof task === 'function') {
            tasks.add(task);
            return () => tasks.delete(task);
          }
          return () => {};
        },
        run() {
          for (const task of Array.from(tasks)) {
            tasks.delete(task);
            try {
              task();
            } catch (err) {
              console.warn('[Ticker] Cleanup task failed', err);
            }
          }
        }
      };
    }

    const cleanupBag = createCleanupBag();

    function addManagedCleanup(fn) {
      return cleanupBag.add(fn);
    }

    function addManagedEventListener(target, type, handler, options) {
      if (!target || typeof target.addEventListener !== 'function' || typeof handler !== 'function') {
        return () => {};
      }
      target.addEventListener(type, handler, options);
      return addManagedCleanup(() => {
        if (target && typeof target.removeEventListener === 'function') {
          target.removeEventListener(type, handler, options);
        }
      });
    }

    const CONTROL_CHARS_SINGLE_LINE = /[\u0000-\u001f\u007f]/g;
    const CONTROL_CHARS_MULTI_LINE = /[\u0000-\u0008\u000b-\u001f\u007f]/g;

    function sanitiseTextInput(value, options = {}) {
      const {
        maxLength = Infinity,
        fallback = '',
        allowMultiline = false
      } = options;
      const pattern = allowMultiline ? CONTROL_CHARS_MULTI_LINE : CONTROL_CHARS_SINGLE_LINE;
      const raw = typeof value === 'string' || typeof value === 'number'
        ? String(value)
        : '';
      const cleaned = raw.replace(pattern, '').trim();
      if (!cleaned) {
        return fallback;
      }
      if (!Number.isFinite(maxLength) || maxLength < 0) {
        return cleaned;
      }
      return cleaned.length > maxLength ? cleaned.slice(0, maxLength) : cleaned;
    }

    function safeSetDataset(target, key, value) {
      if (!target || !target.dataset || !key) return;
      if (value == null) {
        if (Object.prototype.hasOwnProperty.call(target.dataset, key)) {
          delete target.dataset[key];
        }
        return;
      }
      const next = String(value);
      if (target.dataset[key] !== next) {
        target.dataset[key] = next;
      }
    }

    function markErrorHandled(err) {
      if (!err || typeof err !== 'object') return;
      Object.defineProperty(err, '__handled', {
        value: true,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }

    function isErrorHandled(err) {
      return !!(err && typeof err === 'object' && err.__handled);
    }

    function resolveErrorMessage(error, fallback) {
      if (error && typeof error === 'object' && error.message) {
        return String(error.message);
      }
      return fallback;
    }

    function runQueued(queue, task) {
      if (!queue) {
        return task();
      }
      return queue.enqueue(task);
    }

    function isRecord(value) {
      return value !== null && typeof value === 'object' && !Array.isArray(value);
    }

    function validateTickerStateResponse(payload) {
      if (!isRecord(payload)) return 'Invalid ticker payload';
      if (!Array.isArray(payload.messages)) return 'Ticker payload missing messages';
      return true;
    }

    function validateOverlayResponse(payload) {
      return isRecord(payload) ? true : 'Invalid overlay payload';
    }

    function validatePresetList(payload) {
      if (!isRecord(payload)) return 'Invalid presets payload';
      return Array.isArray(payload.presets) ? true : 'Preset list missing';
    }

    function validateSceneList(payload) {
      if (!isRecord(payload)) return 'Invalid scenes payload';
      return Array.isArray(payload.scenes) ? true : 'Scene list missing';
    }

    function validatePopupResponse(payload) {
      return isRecord(payload) ? true : 'Invalid popup payload';
    }

    function validateBrbResponse(payload) {
      return isRecord(payload) ? true : 'Invalid BRB payload';
    }

    function validateSlateResponse(payload) {
      return isRecord(payload) ? true : 'Invalid slate payload';
    }

    function createMutationValidator(key, listKey) {
      return payload => {
        if (!isRecord(payload)) return 'Invalid response payload';
        if (payload.ok !== true) {
          return payload.error || 'Server rejected request';
        }
        if (key && !isRecord(payload[key])) {
          return `Response missing ${key}`;
        }
        if (listKey) {
          const list = payload[listKey];
          if (!Array.isArray(list)) {
            return `Response missing ${listKey}`;
          }
        }
        return true;
      };
    }

    const validateTickerMutation = createMutationValidator('state');
    const validatePopupMutation = createMutationValidator('popup');
    const validateBrbMutation = createMutationValidator('state');
    const validateOverlayMutation = createMutationValidator('overlay');
    const validateSlateMutation = createMutationValidator('slate');
    const validatePresetsMutation = createMutationValidator(null, 'presets');
    const validateScenesMutation = createMutationValidator(null, 'scenes');
    const validateSceneActivation = createMutationValidator();
    const validateStateImport = createMutationValidator('state');

    const FALLBACK_MAX_MESSAGES = Number.isFinite(EXPORTED_MAX_MESSAGES)
      ? EXPORTED_MAX_MESSAGES
      : 50;
    const FALLBACK_MAX_MESSAGE_LENGTH = Number.isFinite(EXPORTED_MAX_MESSAGE_LENGTH)
      ? EXPORTED_MAX_MESSAGE_LENGTH
      : 280;
    const FALLBACK_MAX_POPUP_SECONDS = Number.isFinite(EXPORTED_MAX_POPUP_SECONDS)
      ? EXPORTED_MAX_POPUP_SECONDS
      : 600;
    const FALLBACK_MAX_SLATE_TITLE_LENGTH = Number.isFinite(EXPORTED_MAX_SLATE_TITLE_LENGTH)
      ? EXPORTED_MAX_SLATE_TITLE_LENGTH
      : 64;
    const FALLBACK_MAX_SLATE_TEXT_LENGTH = Number.isFinite(EXPORTED_MAX_SLATE_TEXT_LENGTH)
      ? EXPORTED_MAX_SLATE_TEXT_LENGTH
      : 200;
    const FALLBACK_MAX_SLATE_NOTES = Number.isFinite(EXPORTED_MAX_SLATE_NOTES)
      ? EXPORTED_MAX_SLATE_NOTES
      : 6;
    const FALLBACK_MAX_HIGHLIGHT_LENGTH = 512;
    const FALLBACK_MAX_OVERLAY_LABEL_LENGTH = 64;
    const FALLBACK_MAX_SCENE_NAME_LENGTH = Number.isFinite(EXPORTED_MAX_SCENE_NAME_LENGTH)
      ? EXPORTED_MAX_SCENE_NAME_LENGTH
      : 80;

    const FALLBACK_THEME_OPTIONS_RAW = Array.isArray(BASE_THEME_OPTIONS) && BASE_THEME_OPTIONS.length
      ? BASE_THEME_OPTIONS.filter(entry => typeof entry === 'string' && entry.trim())
      : null;
    const FALLBACK_THEME_SET = new Set(
      (FALLBACK_THEME_OPTIONS_RAW || [])
        .map(entry => entry.trim().toLowerCase())
        .filter(Boolean)
    );

    const FALLBACK_DEFAULT_HIGHLIGHTS = Array.isArray(BASE_DEFAULT_HIGHLIGHTS) && BASE_DEFAULT_HIGHLIGHTS.length
      ? BASE_DEFAULT_HIGHLIGHTS.slice()
      : ['live', 'breaking', 'alert', 'update', 'tonight', 'today'];
    const FALLBACK_DEFAULT_HIGHLIGHT_STRING = typeof BASE_DEFAULT_HIGHLIGHT_STRING === 'string'
      && BASE_DEFAULT_HIGHLIGHT_STRING.trim()
        ? BASE_DEFAULT_HIGHLIGHT_STRING.trim()
        : FALLBACK_DEFAULT_HIGHLIGHTS.join(', ');

    const FALLBACK_DEFAULT_OVERLAY_BASE = BASE_DEFAULT_OVERLAY && typeof BASE_DEFAULT_OVERLAY === 'object'
      ? BASE_DEFAULT_OVERLAY
      : {};
    const FALLBACK_DEFAULT_POPUP_BASE = BASE_DEFAULT_POPUP && typeof BASE_DEFAULT_POPUP === 'object'
      ? BASE_DEFAULT_POPUP
      : {};
    const FALLBACK_DEFAULT_SLATE_SOURCE = {
      isEnabled: true,
      rotationSeconds: 12,
      showClock: true,
      clockLabel: 'UK TIME',
      clockSubtitle: 'UK time',
      nextLabel: 'Next up',
      nextTitle: '',
      nextSubtitle: '',
      sponsorName: '',
      sponsorTagline: '',
      sponsorLabel: 'Sponsor',
      notesLabel: 'Spotlight',
      notes: [],
      ...(BASE_DEFAULT_SLATE && typeof BASE_DEFAULT_SLATE === 'object' ? BASE_DEFAULT_SLATE : {})
    };

    function clampNumberFallback(value, min, max, fallback, precision) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return fallback;
      const clamped = Math.min(Math.max(numeric, min), max);
      if (typeof precision === 'number') {
        const factor = Math.pow(10, precision);
        return Math.round(clamped * factor) / factor;
      }
      return Math.round(clamped);
    }

    const clampDurationSafe = typeof clampDurationSeconds === 'function'
      ? (value, fallback) => clampDurationSeconds(value, fallback)
      : (value, fallback = 5) => clampNumberFallback(value, 2, 90, fallback, 0);
    const clampIntervalSafe = typeof clampIntervalSeconds === 'function'
      ? (value, fallback) => clampIntervalSeconds(value, fallback)
      : (value, fallback = 60) => clampNumberFallback(value, 0, 3600, fallback, 0);
    const clampScaleSafe = typeof clampScaleValue === 'function'
      ? (value, fallback) => clampScaleValue(value, fallback)
      : (value, fallback = 1.75) => clampNumberFallback(value, 0.75, 2.5, fallback, 2);
    const clampPopupScaleSafe = typeof clampPopupScaleValue === 'function'
      ? (value, fallback) => clampPopupScaleValue(value, fallback)
      : (value, fallback = 1) => clampNumberFallback(value, 0.6, 1.5, fallback, 2);
    const clampSlateRotationSafe = typeof clampSlateRotationSeconds === 'function'
      ? (value, fallback) => clampSlateRotationSeconds(value, fallback)
      : (value, fallback = 12) => clampNumberFallback(value, 4, 900, fallback, 0);

    const normaliseModeSafe = typeof sharedNormaliseMode === 'function'
      ? sharedNormaliseMode
      : value => {
          const lower = String(value || '').toLowerCase();
          return ['auto', 'marquee', 'chunk'].includes(lower) ? lower : 'auto';
        };
    const normalisePositionSafe = typeof sharedNormalisePosition === 'function'
      ? sharedNormalisePosition
      : value => (String(value || '').toLowerCase() === 'top' ? 'top' : 'bottom');
    const normaliseThemeSafe = typeof sharedNormaliseTheme === 'function'
      ? sharedNormaliseTheme
      : value => {
          if (typeof value !== 'string') return null;
          const trimmed = value.trim().toLowerCase();
          if (!trimmed) return null;
          return FALLBACK_THEME_SET.has(trimmed) ? trimmed : null;
        };

    const HEX_COLOR_RE = /^#(?:[0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
    const RGB_COLOR_RE = /^rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})(?:\s*,\s*(0|0?\.\d+|1(?:\.0+)?))?\s*\)$/i;
    const HSL_COLOR_RE = /^hsla?\(\s*(-?\d+(?:\.\d+)?)\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%(?:\s*,\s*(0|0?\.\d+|1(?:\.0+)?))?\s*\)$/i;
    const SAFE_COLOR_KEYWORDS = new Set([
      'white', 'black', 'silver', 'gray', 'grey', 'maroon', 'red', 'purple', 'fuchsia',
      'green', 'lime', 'olive', 'yellow', 'navy', 'blue', 'teal', 'aqua', 'orange',
      'gold', 'indigo', 'violet', 'pink', 'plum', 'salmon', 'coral', 'turquoise',
      'cyan', 'magenta', 'brown', 'chocolate', 'tan', 'beige', 'crimson',
      'tomato', 'mintcream', 'honeydew', 'lavender', 'rebeccapurple', 'transparent', 'currentcolor'
    ]);

    const isSafeColour = typeof sharedIsSafeCssColor === 'function'
      ? sharedIsSafeCssColor
      : value => {
          if (typeof value !== 'string') return false;
          const trimmed = value.trim();
          if (!trimmed || trimmed.length > 64) return false;
          if (HEX_COLOR_RE.test(trimmed)) return true;
          const lower = trimmed.toLowerCase();
          if (SAFE_COLOR_KEYWORDS.has(lower)) return true;

          const rgbMatch = trimmed.match(RGB_COLOR_RE);
          if (rgbMatch) {
            const components = [rgbMatch[1], rgbMatch[2], rgbMatch[3]].map(Number);
            const alpha = rgbMatch[4];
            const alphaOk = alpha == null
              ? true
              : (Number.isFinite(Number(alpha)) && Number(alpha) >= 0 && Number(alpha) <= 1);
            if (components.every(component => Number.isFinite(component) && component >= 0 && component <= 255) && alphaOk) {
              return true;
            }
          }

          const hslMatch = trimmed.match(HSL_COLOR_RE);
          if (hslMatch) {
            const h = Number(hslMatch[1]);
            const s = Number(hslMatch[2]);
            const l = Number(hslMatch[3]);
            const alpha = hslMatch[4];
            const alphaOk = alpha == null
              ? true
              : (Number.isFinite(Number(alpha)) && Number(alpha) >= 0 && Number(alpha) <= 1);
            if (
              Number.isFinite(h) && h >= 0 && h <= 360 &&
              Number.isFinite(s) && s >= 0 && s <= 100 &&
              Number.isFinite(l) && l >= 0 && l <= 100 &&
              alphaOk
            ) {
              return true;
            }
          }

          return false;
        };

    const normaliseSlateNotesSafe = typeof normaliseSlateNotes === 'function'
      ? (value, limit = FALLBACK_MAX_SLATE_NOTES, maxLength = FALLBACK_MAX_SLATE_TEXT_LENGTH) => normaliseSlateNotes(value, limit, maxLength)
      : (value, limit = FALLBACK_MAX_SLATE_NOTES, maxLength = FALLBACK_MAX_SLATE_TEXT_LENGTH) => {
          const list = Array.isArray(value)
            ? value
            : String(value == null ? '' : value)
                .split(/\r?\n|[,;]/)
                .map(entry => entry.trim());
          const cleaned = [];
          for (const entry of list) {
            if (!entry) continue;
            const trimmed = String(entry).trim().slice(0, maxLength);
            if (!trimmed) continue;
            cleaned.push(trimmed);
            if (cleaned.length >= limit) break;
          }
          return cleaned;
        };

    const FALLBACK_DEFAULT_OVERLAY = (() => {
      const merged = {
        label: 'LIVE',
        accent: '#38bdf8',
        accentSecondary: '#f472b6',
        highlight: FALLBACK_DEFAULT_HIGHLIGHT_STRING,
        scale: 1.75,
        popupScale: 1,
        position: 'bottom',
        mode: 'auto',
        accentAnim: true,
        sparkle: true,
        theme: 'midnight-glass',
        ...FALLBACK_DEFAULT_OVERLAY_BASE
      };
      merged.highlight = typeof merged.highlight === 'string' && merged.highlight.trim()
        ? merged.highlight.trim()
        : FALLBACK_DEFAULT_HIGHLIGHT_STRING;
      merged.scale = clampScaleSafe(merged.scale, 1.75);
      merged.popupScale = clampPopupScaleSafe(merged.popupScale, 1);
      merged.position = normalisePositionSafe(merged.position);
      const normalisedMode = normaliseModeSafe(merged.mode);
      merged.mode = normalisedMode || 'auto';
      const normalisedTheme = normaliseThemeSafe(merged.theme);
      merged.theme = normalisedTheme || 'midnight-glass';
      return Object.freeze(merged);
    })();

    const FALLBACK_DEFAULT_POPUP = (() => {
      const base = {
        text: '',
        isActive: false,
        durationSeconds: null,
        countdownEnabled: false,
        countdownTarget: null,
        updatedAt: null,
        ...FALLBACK_DEFAULT_POPUP_BASE
      };
      const text = typeof base.text === 'string' ? base.text.trim().slice(0, FALLBACK_MAX_MESSAGE_LENGTH) : '';
      const duration = Number(base.durationSeconds);
      const countdownTarget = Number(base.countdownTarget);
      const updatedAtNumeric = Number(base.updatedAt);
      const countdownNumeric = Number.isFinite(countdownTarget) ? Math.round(countdownTarget) : null;
      return Object.freeze({
        text,
        isActive: !!base.isActive && !!text,
        durationSeconds: Number.isFinite(duration) && duration > 0
          ? Math.max(1, Math.min(FALLBACK_MAX_POPUP_SECONDS, Math.round(duration)))
          : null,
        countdownEnabled: !!base.countdownEnabled && !!text && Number.isFinite(countdownNumeric),
        countdownTarget: Number.isFinite(countdownNumeric) ? countdownNumeric : null,
        updatedAt: Number.isFinite(updatedAtNumeric) ? updatedAtNumeric : null
      });
    })();

    const FALLBACK_DEFAULT_SLATE = (() => {
      const base = { ...FALLBACK_DEFAULT_SLATE_SOURCE };
      return Object.freeze({
        isEnabled: base.isEnabled !== false,
        rotationSeconds: clampSlateRotationSafe(base.rotationSeconds, 12),
        showClock: base.showClock !== false,
        clockLabel: typeof base.clockLabel === 'string'
          ? base.clockLabel.trim().slice(0, FALLBACK_MAX_SLATE_TITLE_LENGTH)
          : 'UK TIME',
        clockSubtitle: typeof base.clockSubtitle === 'string'
          ? base.clockSubtitle.trim().slice(0, FALLBACK_MAX_SLATE_TEXT_LENGTH)
          : 'UK time',
        nextLabel: typeof base.nextLabel === 'string'
          ? base.nextLabel.trim().slice(0, FALLBACK_MAX_SLATE_TITLE_LENGTH)
          : 'Next up',
        nextTitle: typeof base.nextTitle === 'string'
          ? base.nextTitle.trim().slice(0, FALLBACK_MAX_SLATE_TITLE_LENGTH)
          : '',
        nextSubtitle: typeof base.nextSubtitle === 'string'
          ? base.nextSubtitle.trim().slice(0, FALLBACK_MAX_SLATE_TEXT_LENGTH)
          : '',
        sponsorName: typeof base.sponsorName === 'string'
          ? base.sponsorName.trim().slice(0, FALLBACK_MAX_SLATE_TITLE_LENGTH)
          : '',
        sponsorTagline: typeof base.sponsorTagline === 'string'
          ? base.sponsorTagline.trim().slice(0, FALLBACK_MAX_SLATE_TEXT_LENGTH)
          : '',
        sponsorLabel: typeof base.sponsorLabel === 'string'
          ? base.sponsorLabel.trim().slice(0, FALLBACK_MAX_SLATE_TITLE_LENGTH)
          : 'Sponsor',
        notesLabel: typeof base.notesLabel === 'string'
          ? base.notesLabel.trim().slice(0, FALLBACK_MAX_SLATE_TITLE_LENGTH)
          : 'Spotlight',
        notes: normaliseSlateNotesSafe(base.notes, FALLBACK_MAX_SLATE_NOTES, FALLBACK_MAX_SLATE_TEXT_LENGTH),
        updatedAt: Number.isFinite(Number(base.updatedAt)) ? Number(base.updatedAt) : null
      });
    })();

    const bootWarningEl = document.getElementById('bootWarning');
    const missingHelperNames = new Set();

    function reportMissingHelper(helperName) {
      if (!helperName) return;
      const helperId = String(helperName);
      if (!missingHelperNames.has(helperId)) {
        missingHelperNames.add(helperId);
        console.error(`[Ticker] Helper script "${helperId}" is unavailable. Falling back to safe defaults.`);
      }
      if (bootWarningEl) {
        const names = Array.from(missingHelperNames).sort();
        bootWarningEl.textContent = names.length
          ? `Dashboard loaded in degraded mode. Missing helpers: ${names.join(', ')}.`
          : 'Dashboard loaded in degraded mode.';
        bootWarningEl.hidden = false;
      }
    }

    const sanitiseMessagesFn = typeof sanitiseMessages === 'function'
      ? sanitiseMessages
      : (messages, options = {}) => {
          reportMissingHelper('sanitiseMessages');
          const list = Array.isArray(messages) ? messages : [];
          const {
            maxMessages = FALLBACK_MAX_MESSAGES,
            maxLength = FALLBACK_MAX_MESSAGE_LENGTH,
            maxMetaLength = FALLBACK_MAX_MESSAGE_LENGTH,
            includeMeta = false,
            strict = false
          } = options;

          const maxMessageLimit = Number.isFinite(Number(maxMessages))
            ? Math.max(0, Math.round(Number(maxMessages)))
            : FALLBACK_MAX_MESSAGES;
          const maxLengthLimit = Number.isFinite(Number(maxLength))
            ? Math.max(1, Math.round(Number(maxLength)))
            : FALLBACK_MAX_MESSAGE_LENGTH;
          const maxMetaLimit = Number.isFinite(Number(maxMetaLength))
            ? Math.max(0, Math.round(Number(maxMetaLength)))
            : FALLBACK_MAX_MESSAGE_LENGTH;

          const cleaned = [];
          const metadata = [];
          let trimmed = 0;
          let truncated = 0;

          for (const entry of list) {
            let text = '';
            let metaValue = null;

            if (typeof entry === 'string') {
              text = entry.trim();
            } else if (entry && typeof entry === 'object') {
              if (typeof entry.text === 'string') {
                text = entry.text.trim();
              } else if (typeof entry.message === 'string') {
                text = entry.message.trim();
              } else if (typeof entry.value === 'string') {
                text = entry.value.trim();
              } else if (typeof entry.toString === 'function' && entry.toString !== Object.prototype.toString) {
                text = String(entry).trim();
              }

              if (includeMeta) {
                const rawMeta = entry.meta != null ? entry.meta : entry.description;
                if (typeof rawMeta === 'string') {
                  const trimmedMeta = rawMeta.trim();
                  if (trimmedMeta) {
                    metaValue = trimmedMeta.slice(0, maxMetaLimit);
                  }
                }
              }
            } else {
              text = String(entry == null ? '' : entry).trim();
            }

            if (!text) continue;

            if (cleaned.length >= maxMessageLimit) {
              if (strict) {
                throw new Error(`Too many ticker messages (maximum ${maxMessageLimit}).`);
              }
              truncated += 1;
              if (!includeMeta) {
                break;
              }
              continue;
            }

            if (text.length > maxLengthLimit) {
              if (strict) {
                throw new Error(`Ticker messages must be ${maxLengthLimit} characters or fewer.`);
              }
              text = text.slice(0, maxLengthLimit);
              trimmed += 1;
            }

            cleaned.push(text);
            if (includeMeta) {
              metadata.push(metaValue);
            }
          }

          if (includeMeta) {
            return { messages: cleaned, meta: metadata, trimmed, truncated };
          }
          return cleaned;
        };

    const normaliseHighlightInputFn = typeof normaliseHighlightInput === 'function'
      ? normaliseHighlightInput
      : value => {
          reportMissingHelper('normaliseHighlightInput');
          const entries = Array.isArray(value)
            ? value
            : typeof value === 'string'
              ? value.split(/[\n,]/)
              : [];
          const seen = new Set();
          const normalised = [];
          for (const entry of entries) {
            if (typeof entry !== 'string') continue;
            const trimmed = entry.trim();
            if (!trimmed) continue;
            const key = trimmed.toLowerCase();
            if (seen.has(key)) continue;
            seen.add(key);
            normalised.push(trimmed);
          }
          return normalised.join(', ').slice(0, FALLBACK_MAX_HIGHLIGHT_LENGTH);
        };

    const normaliseSlateNotesListFn = typeof normaliseSlateNotesList === 'function'
      ? (value, limit = FALLBACK_MAX_SLATE_NOTES, maxLength = FALLBACK_MAX_SLATE_TEXT_LENGTH) => normaliseSlateNotesList(value, limit, maxLength)
      : (value, limit = FALLBACK_MAX_SLATE_NOTES, maxLength = FALLBACK_MAX_SLATE_TEXT_LENGTH) => {
          reportMissingHelper('normaliseSlateNotesList');
          return normaliseSlateNotesSafe(value, limit, maxLength);
        };

    const normaliseOverlayDataFn = typeof normaliseOverlayData === 'function'
      ? normaliseOverlayData
      : (value = {}, defaults = FALLBACK_DEFAULT_OVERLAY) => {
          reportMissingHelper('normaliseOverlayData');
          const base = defaults && typeof defaults === 'object' ? defaults : FALLBACK_DEFAULT_OVERLAY;
          const result = { ...base };
          if (!value || typeof value !== 'object') {
            return result;
          }

          if (typeof value.label === 'string') {
            const trimmed = value.label.trim().slice(0, FALLBACK_MAX_OVERLAY_LABEL_LENGTH).trim();
            if (trimmed) {
              result.label = trimmed;
            }
          }

          if (typeof value.accent === 'string') {
            const trimmed = value.accent.trim();
            if (!trimmed) {
              result.accent = '';
            } else if (trimmed.length <= 64 && isSafeColour(trimmed)) {
              result.accent = trimmed;
            }
          }

          if (typeof value.accentSecondary === 'string') {
            const trimmedSecondary = value.accentSecondary.trim();
            if (!trimmedSecondary) {
              result.accentSecondary = '';
            } else if (trimmedSecondary.length <= 64 && isSafeColour(trimmedSecondary)) {
              result.accentSecondary = trimmedSecondary;
            }
          }

          if (typeof value.highlight === 'string') {
            const normalisedHighlight = normaliseHighlightInputFn(value.highlight);
            if (typeof normalisedHighlight === 'string') {
              result.highlight = normalisedHighlight;
            } else if (Array.isArray(normalisedHighlight)) {
              result.highlight = normalisedHighlight.join(', ');
            }
            result.highlight = String(result.highlight || '').slice(0, FALLBACK_MAX_HIGHLIGHT_LENGTH);
          }

          if (Number.isFinite(value.scale)) {
            result.scale = clampScaleSafe(value.scale, result.scale);
          }

          if (Number.isFinite(value.popupScale)) {
            result.popupScale = clampPopupScaleSafe(value.popupScale, result.popupScale);
          }

          if (typeof value.position === 'string') {
            result.position = normalisePositionSafe(value.position);
          }

          if (typeof value.mode === 'string') {
            result.mode = normaliseModeSafe(value.mode);
          }

          if (typeof value.accentAnim === 'boolean') {
            result.accentAnim = value.accentAnim;
          }

          if (typeof value.sparkle === 'boolean') {
            result.sparkle = value.sparkle;
          }

          if (typeof value.theme === 'string') {
            const theme = normaliseThemeSafe(value.theme);
            if (theme) {
              result.theme = theme;
            }
          }

          return result;
        };

    const normalisePopupDataFn = typeof normalisePopupData === 'function'
      ? normalisePopupData
      : (value = {}, defaults = FALLBACK_DEFAULT_POPUP, options = {}) => {
          reportMissingHelper('normalisePopupData');
          const { maxDurationSeconds = FALLBACK_MAX_POPUP_SECONDS } = options;
          const base = defaults && typeof defaults === 'object' ? defaults : FALLBACK_DEFAULT_POPUP;
          const sanitisedBaseText = typeof base.text === 'string'
            ? base.text.trim().slice(0, FALLBACK_MAX_MESSAGE_LENGTH)
            : '';
          const baseDuration = Number(base.durationSeconds);
          const baseDurationSeconds = Number.isFinite(baseDuration) && baseDuration > 0
            ? Math.max(1, Math.min(maxDurationSeconds, Math.round(baseDuration)))
            : null;
          const baseCountdownNumeric = Number(base.countdownTarget);
          const baseCountdownTarget = Number.isFinite(baseCountdownNumeric)
            ? Math.round(baseCountdownNumeric)
            : null;
          const baseUpdatedAtNumeric = Number(base.updatedAt);
          const result = {
            text: sanitisedBaseText,
            isActive: !!base.isActive && !!sanitisedBaseText,
            durationSeconds: baseDurationSeconds,
            countdownEnabled: !!base.countdownEnabled && !!sanitisedBaseText && baseCountdownTarget != null,
            countdownTarget: baseCountdownTarget,
            updatedAt: Number.isFinite(baseUpdatedAtNumeric) ? baseUpdatedAtNumeric : null
          };

          const source = value && typeof value === 'object' ? value : {};

          if (typeof source.text === 'string') {
            result.text = source.text.trim().slice(0, FALLBACK_MAX_MESSAGE_LENGTH);
          }

          if (typeof source.isActive === 'boolean') {
            result.isActive = source.isActive;
          }

          if (Object.prototype.hasOwnProperty.call(source, 'durationSeconds')) {
            const numeric = Number(source.durationSeconds);
            result.durationSeconds = Number.isFinite(numeric) && numeric > 0
              ? Math.max(1, Math.min(maxDurationSeconds, Math.round(numeric)))
              : null;
          }

          if (Object.prototype.hasOwnProperty.call(source, 'countdownEnabled')) {
            result.countdownEnabled = !!source.countdownEnabled;
          }

          if (Object.prototype.hasOwnProperty.call(source, 'countdownTarget')) {
            const numeric = Number(source.countdownTarget);
            result.countdownTarget = Number.isFinite(numeric) ? Math.round(numeric) : null;
          }

          if (typeof source.countdownLabel === 'string') {
            result.countdownLabel = source.countdownLabel;
          }

          const updatedAtSource = source.updatedAt != null ? source.updatedAt : source._updatedAt;
          if (updatedAtSource != null) {
            const numeric = Number(updatedAtSource);
            if (Number.isFinite(numeric)) {
              result.updatedAt = numeric;
            }
          }

          if (!result.text) {
            result.isActive = false;
            result.countdownEnabled = false;
            result.countdownTarget = null;
          }

          if (!Number.isFinite(result.countdownTarget)) {
            result.countdownTarget = null;
            result.countdownEnabled = false;
          } else {
            result.countdownEnabled = !!result.countdownEnabled && !!result.text;
            result.countdownTarget = Math.round(result.countdownTarget);
          }

          if (!Number.isFinite(result.updatedAt)) {
            result.updatedAt = Date.now();
          }

          return result;
        };

    const normaliseSlateDataFn = typeof normaliseSlateData === 'function'
      ? normaliseSlateData
      : (value = {}, defaults = FALLBACK_DEFAULT_SLATE) => {
          reportMissingHelper('normaliseSlateData');
          const base = defaults && typeof defaults === 'object'
            ? defaults
            : FALLBACK_DEFAULT_SLATE;
          const result = {
            ...base,
            notes: Array.isArray(base.notes)
              ? base.notes.slice(0, FALLBACK_MAX_SLATE_NOTES)
              : []
          };

          const source = value && typeof value === 'object' ? value : {};

          if (typeof source.isEnabled === 'boolean') {
            result.isEnabled = source.isEnabled;
          }

          if (typeof source.showClock === 'boolean') {
            result.showClock = source.showClock;
          }

          if (Number.isFinite(source.rotationSeconds)) {
            result.rotationSeconds = clampSlateRotationSafe(source.rotationSeconds, result.rotationSeconds);
          }

          const stringFields = [
            ['clockLabel', FALLBACK_MAX_SLATE_TITLE_LENGTH],
            ['clockSubtitle', FALLBACK_MAX_SLATE_TEXT_LENGTH],
            ['nextLabel', FALLBACK_MAX_SLATE_TITLE_LENGTH],
            ['nextTitle', FALLBACK_MAX_SLATE_TITLE_LENGTH],
            ['nextSubtitle', FALLBACK_MAX_SLATE_TEXT_LENGTH],
            ['sponsorLabel', FALLBACK_MAX_SLATE_TITLE_LENGTH],
            ['sponsorName', FALLBACK_MAX_SLATE_TITLE_LENGTH],
            ['sponsorTagline', FALLBACK_MAX_SLATE_TEXT_LENGTH],
            ['notesLabel', FALLBACK_MAX_SLATE_TITLE_LENGTH]
          ];

          for (const [key, limit] of stringFields) {
            if (typeof source[key] === 'string') {
              result[key] = source[key].trim().slice(0, limit).trim();
            }
          }

          if (Array.isArray(source.notes) || typeof source.notes === 'string') {
            result.notes = normaliseSlateNotesListFn(source.notes, FALLBACK_MAX_SLATE_NOTES, FALLBACK_MAX_SLATE_TEXT_LENGTH);
          }

          const updatedAtSource = source.updatedAt != null ? source.updatedAt : source._updatedAt;
          if (updatedAtSource != null) {
            const numeric = Number(updatedAtSource);
            if (Number.isFinite(numeric)) {
              result.updatedAt = numeric;
            }
          }

          return result;
        };

    const normaliseSceneEntryFn = typeof normaliseSceneEntry === 'function'
      ? (entry, helpers) => normaliseSceneEntry(entry, helpers)
      : (entry, helpers = {}) => {
          reportMissingHelper('normaliseSceneEntry');
          if (!entry || typeof entry !== 'object') return null;

          const {
            fallbackDisplayDuration = 5,
            fallbackIntervalSeconds = 60,
            maxMessages = FALLBACK_MAX_MESSAGES,
            maxMessageLength = FALLBACK_MAX_MESSAGE_LENGTH
          } = helpers || {};

          const name = String(entry.name || '').trim().slice(0, FALLBACK_MAX_SCENE_NAME_LENGTH);
          if (!name) return null;

          const tickerSource = entry.ticker && typeof entry.ticker === 'object' ? entry.ticker : entry;
          const messagesSource = tickerSource && tickerSource.messages != null
            ? tickerSource.messages
            : (entry && entry.messages != null ? entry.messages : []);
          const tickerMessages = sanitiseMessagesFn(messagesSource, {
            maxMessages,
            maxLength: maxMessageLength
          });
          const cleanedMessages = Array.isArray(tickerMessages) ? tickerMessages : [];

          const displayDurationSource = tickerSource && tickerSource.displayDuration != null
            ? tickerSource.displayDuration
            : (entry && entry.displayDuration != null ? entry.displayDuration : fallbackDisplayDuration);
          const displayDuration = clampDurationSafe(displayDurationSource, fallbackDisplayDuration);

          const intervalSource = tickerSource && tickerSource.intervalBetween != null
            ? tickerSource.intervalBetween
            : (entry && entry.intervalBetween != null ? entry.intervalBetween : fallbackIntervalSeconds);
          const intervalBetween = clampIntervalSafe(intervalSource, fallbackIntervalSeconds);

          const tickerActiveSource = tickerSource && tickerSource.isActive != null
            ? tickerSource.isActive
            : entry.isActive;
          const ticker = {
            messages: cleanedMessages,
            displayDuration,
            intervalBetween,
            isActive: !!tickerActiveSource && cleanedMessages.length > 0
          };

          const popup = normalisePopupDataFn(entry.popup || {}, FALLBACK_DEFAULT_POPUP, helpers);

          let slate = null;
          if (entry.slate && typeof entry.slate === 'object') {
            const normalisedSlate = normaliseSlateDataFn(entry.slate, FALLBACK_DEFAULT_SLATE);
            slate = {
              isEnabled: !!normalisedSlate.isEnabled,
              rotationSeconds: clampSlateRotationSafe(normalisedSlate.rotationSeconds, normalisedSlate.rotationSeconds),
              showClock: !!normalisedSlate.showClock,
              clockLabel: normalisedSlate.clockLabel || '',
              nextLabel: normalisedSlate.nextLabel || '',
              nextTitle: normalisedSlate.nextTitle || '',
              nextSubtitle: normalisedSlate.nextSubtitle || '',
              sponsorLabel: normalisedSlate.sponsorLabel || '',
              sponsorName: normalisedSlate.sponsorName || '',
              sponsorTagline: normalisedSlate.sponsorTagline || '',
              notesLabel: normalisedSlate.notesLabel || '',
              notes: Array.isArray(normalisedSlate.notes)
                ? normalisedSlate.notes.slice(0, FALLBACK_MAX_SLATE_NOTES)
                : []
            };
          }

          let overlay = null;
          if (entry.overlay && typeof entry.overlay === 'object') {
            const overlayKeys = [
              'label',
              'accent',
              'accentSecondary',
              'highlight',
              'scale',
              'popupScale',
              'position',
              'mode',
              'accentAnim',
              'sparkle',
              'theme'
            ];
            const normalisedOverlay = normaliseOverlayDataFn(entry.overlay, FALLBACK_DEFAULT_OVERLAY);
            for (const key of overlayKeys) {
              if (!Object.prototype.hasOwnProperty.call(entry.overlay, key)) continue;
              if (!(key in normalisedOverlay)) continue;
              const value = normalisedOverlay[key];
              if (value === undefined) continue;
              if (!overlay) overlay = {};
              overlay[key] = value;
            }
            if (!overlay && Object.prototype.hasOwnProperty.call(entry.overlay, 'theme')) {
              const themeCandidate = normaliseThemeSafe(entry.overlay.theme);
              if (themeCandidate) {
                overlay = { theme: themeCandidate };
              }
            }
          }

          const hasSlateContent = !!(slate && Object.keys(slate).length);
          const hasPopupText = !!(popup && popup.text);
          if (!cleanedMessages.length && !hasPopupText && !hasSlateContent) {
            return null;
          }

          const id = typeof entry.id === 'string' && entry.id.trim()
            ? entry.id
            : String(entry.id || 'scene');
          const updatedAtSource = entry.updatedAt != null ? entry.updatedAt : entry._updatedAt;
          const updatedAtNumeric = Number(updatedAtSource);
          const updatedAt = Number.isFinite(updatedAtNumeric) ? updatedAtNumeric : Date.now();

          return { id, name, ticker, popup, overlay, slate, updatedAt };
        };

    [
      ['sanitiseMessages', sanitiseMessages],
      ['normaliseHighlightInput', normaliseHighlightInput],
      ['normaliseOverlayData', normaliseOverlayData],
      ['normalisePopupData', normalisePopupData],
      ['normaliseSlateNotesList', normaliseSlateNotesList],
      ['normaliseSlateData', normaliseSlateData],
      ['normaliseSceneEntry', normaliseSceneEntry]
    ].forEach(([name, impl]) => {
      if (typeof impl !== 'function') {
        reportMissingHelper(name);
      }
    });

    const DEFAULT_SERVER_URL = 'http://127.0.0.1:3000';
    const normaliseServerBase = typeof sharedNormaliseServerBase === 'function'
      ? (value, fallback) => sharedNormaliseServerBase(value, fallback == null ? DEFAULT_SERVER_URL : fallback)
      : (value, fallback = DEFAULT_SERVER_URL) => {
            const fallbackValue = typeof fallback === 'string' && fallback.trim()
              ? fallback.trim()
              : DEFAULT_SERVER_URL;
            const raw = typeof value === 'string' ? value.trim() : '';
            const target = raw || fallbackValue;
            const cleaned = target
              .replace(/(?:\/ticker)+\/?$/i, '')
              .replace(/\/+$/g, '');
            const fallbackClean = fallbackValue.replace(/\/+$/g, '');
            return cleaned || fallbackClean;
          };

    function normaliseThemeList(list) {
      if (!Array.isArray(list)) return [];
      const seen = new Set();
      const normalised = [];
      for (const entry of list) {
        if (typeof entry !== 'string') continue;
        const trimmed = entry.trim().toLowerCase();
        if (!trimmed || seen.has(trimmed)) continue;
        seen.add(trimmed);
        normalised.push(trimmed);
      }
      return normalised;
    }

    const STORAGE_KEY = 'ticker-dashboard-v3';
    const MAX_MESSAGES = EXPORTED_MAX_MESSAGES || 50;
    const MAX_MESSAGE_LENGTH = EXPORTED_MAX_MESSAGE_LENGTH || 280;
    const MAX_POPUP_SECONDS = EXPORTED_MAX_POPUP_SECONDS || 600;
    const MAX_POPUP_LENGTH = 280;
    const MAX_SLATE_TITLE_LENGTH = EXPORTED_MAX_SLATE_TITLE_LENGTH || 64;
    const MAX_SLATE_TEXT_LENGTH = EXPORTED_MAX_SLATE_TEXT_LENGTH || 200;
    const MAX_SLATE_NOTES = EXPORTED_MAX_SLATE_NOTES || 6;
    const MAX_HIGHLIGHT_LENGTH = 512;
    const HIGHLIGHT_WARNING_THRESHOLD = 32;
    const MAX_BRB_LENGTH = 280;
    const MESSAGE_PLACEHOLDER = 'Add a ticker message…';
    const THEME_OPTIONS = Array.isArray(BASE_THEME_OPTIONS) && BASE_THEME_OPTIONS.length
        ? BASE_THEME_OPTIONS.slice()
        : (Array.isArray(OVERLAY_THEMES) && OVERLAY_THEMES.length
            ? OVERLAY_THEMES.slice()
            : normaliseThemeList(sharedConfigWindow.OVERLAY_THEMES));
    const THEME_CLASSNAMES = THEME_OPTIONS.map(theme => `ticker--${theme}`);
    const MAX_PRESET_NAME_LENGTH = 80;
    const MAX_SCENE_NAME_LENGTH = 80;
    const MAX_OVERLAY_LABEL_LENGTH = 64;

    const ScenesModule = window.TickerScenes || {};
    const normaliseSceneEntryImpl = typeof ScenesModule.normaliseSceneEntry === 'function'
      ? ScenesModule.normaliseSceneEntry
      : null;
    const serialiseOverlayForSceneImpl = typeof ScenesModule.serialiseOverlayForScene === 'function'
      ? ScenesModule.serialiseOverlayForScene
      : null;
    const SCENE_OVERLAY_KEYS = [
      'label',
      'accent',
      'accentSecondary',
      'highlight',
      'scale',
      'popupScale',
      'position',
      'mode',
      'accentAnim',
      'sparkle',
      'theme'
    ];

    const buildSceneOverlayPayload = serialiseOverlayForSceneImpl
      ? (overlayPrefs = {}) => serialiseOverlayForSceneImpl(
          overlayPrefs && typeof overlayPrefs === 'object' ? overlayPrefs : {},
          {
            normaliseOverlayData: normaliseOverlayDataFn,
            overlayKeys: SCENE_OVERLAY_KEYS,
            includeEmptyStrings: false
          }
        )
      : (overlayPrefs = {}) => {
          const source = overlayPrefs && typeof overlayPrefs === 'object' ? overlayPrefs : {};
          const payload = {};
          SCENE_OVERLAY_KEYS.forEach(key => {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              payload[key] = source[key];
            }
          });
          return payload;
        };

    const sharedConfig = window.SharedConfig || {};
    const DEFAULT_HIGHLIGHTS = Array.isArray(BASE_DEFAULT_HIGHLIGHTS) && BASE_DEFAULT_HIGHLIGHTS.length
      ? BASE_DEFAULT_HIGHLIGHTS.slice()
      : (Array.isArray(sharedConfig.DEFAULT_HIGHLIGHTS) && sharedConfig.DEFAULT_HIGHLIGHTS.length
          ? sharedConfig.DEFAULT_HIGHLIGHTS.slice()
          : FALLBACK_DEFAULT_HIGHLIGHTS.slice());
    const DEFAULT_HIGHLIGHT_STRING = typeof BASE_DEFAULT_HIGHLIGHT_STRING === 'string' && BASE_DEFAULT_HIGHLIGHT_STRING.trim()
      ? BASE_DEFAULT_HIGHLIGHT_STRING.trim()
      : (typeof sharedConfig.DEFAULT_HIGHLIGHT_STRING === 'string' && sharedConfig.DEFAULT_HIGHLIGHT_STRING.trim()
          ? sharedConfig.DEFAULT_HIGHLIGHT_STRING.trim()
          : FALLBACK_DEFAULT_HIGHLIGHT_STRING);

    const DEFAULT_OVERLAY = {
      ...FALLBACK_DEFAULT_OVERLAY,
      ...(BASE_DEFAULT_OVERLAY || {}),
      ...(sharedConfig.DEFAULT_OVERLAY || {})
    };

    if (typeof DEFAULT_OVERLAY.accent === 'string') {
      const accentTrimmed = DEFAULT_OVERLAY.accent.trim();
      DEFAULT_OVERLAY.accent = accentTrimmed && isSafeColour(accentTrimmed)
        ? accentTrimmed
        : FALLBACK_DEFAULT_OVERLAY.accent;
    } else {
      DEFAULT_OVERLAY.accent = FALLBACK_DEFAULT_OVERLAY.accent;
    }

    if (typeof DEFAULT_OVERLAY.accentSecondary === 'string') {
      const accentSecondaryTrimmed = DEFAULT_OVERLAY.accentSecondary.trim();
      DEFAULT_OVERLAY.accentSecondary = accentSecondaryTrimmed && isSafeColour(accentSecondaryTrimmed)
        ? accentSecondaryTrimmed
        : FALLBACK_DEFAULT_OVERLAY.accentSecondary;
    } else {
      DEFAULT_OVERLAY.accentSecondary = FALLBACK_DEFAULT_OVERLAY.accentSecondary;
    }

    if (typeof DEFAULT_OVERLAY.highlight === 'string' && DEFAULT_OVERLAY.highlight.trim()) {
      const normalisedHighlight = normaliseHighlightInputFn(DEFAULT_OVERLAY.highlight);
      const highlightString = typeof normalisedHighlight === 'string'
        ? normalisedHighlight
        : Array.isArray(normalisedHighlight)
          ? normalisedHighlight.join(', ')
          : DEFAULT_HIGHLIGHT_STRING;
      DEFAULT_OVERLAY.highlight = highlightString.slice(0, FALLBACK_MAX_HIGHLIGHT_LENGTH);
    } else {
      DEFAULT_OVERLAY.highlight = DEFAULT_HIGHLIGHT_STRING;
    }

    DEFAULT_OVERLAY.scale = clampScaleSafe(DEFAULT_OVERLAY.scale, FALLBACK_DEFAULT_OVERLAY.scale);
    DEFAULT_OVERLAY.popupScale = clampPopupScaleSafe(DEFAULT_OVERLAY.popupScale, FALLBACK_DEFAULT_OVERLAY.popupScale);
    DEFAULT_OVERLAY.position = normalisePositionSafe(DEFAULT_OVERLAY.position);
    DEFAULT_OVERLAY.mode = normaliseModeSafe(DEFAULT_OVERLAY.mode);
    const defaultThemeCandidate = normaliseThemeSafe(DEFAULT_OVERLAY.theme);
    DEFAULT_OVERLAY.theme = defaultThemeCandidate || FALLBACK_DEFAULT_OVERLAY.theme;

    const DEFAULT_ACCENT = DEFAULT_OVERLAY.accent && DEFAULT_OVERLAY.accent.trim()
      ? DEFAULT_OVERLAY.accent.trim()
      : '#38bdf8';
    const DEFAULT_ACCENT_SECONDARY = DEFAULT_OVERLAY.accentSecondary && DEFAULT_OVERLAY.accentSecondary.trim()
      ? DEFAULT_OVERLAY.accentSecondary.trim()
      : '';
    const ACCENT_FALLBACK_HEX = parseHexForPicker(DEFAULT_ACCENT) || '#38bdf8';
    const ACCENT_SECONDARY_FALLBACK_HEX = DEFAULT_ACCENT_SECONDARY
      ? (parseHexForPicker(DEFAULT_ACCENT_SECONDARY) || ACCENT_FALLBACK_HEX)
      : ACCENT_FALLBACK_HEX;
    const ACCENT_HINT_DEFAULT = 'Accepts hex (#ff0000), rgb(a), hsl(a), or named colours.';
    const ACCENT_SECONDARY_HINT_DEFAULT = 'Optional second highlight used by Duotone Fusion and blended gradients.';
    const ACCENT_MAX_LENGTH = 64;
    const PRESET_NAME_HINT = 'Preset names can be up to 80 characters.';

    const DEFAULT_STATE = {
      isActive: false,
      messages: [],
      displayDuration: 5,
      intervalMinutes: 0,
      updatedAt: null
    };

    const DEFAULT_POPUP = normalisePopupDataFn(
      {
        ...FALLBACK_DEFAULT_POPUP,
        ...(BASE_DEFAULT_POPUP || {}),
        ...(sharedConfig.DEFAULT_POPUP || {})
      },
      FALLBACK_DEFAULT_POPUP,
      { maxDurationSeconds: MAX_POPUP_SECONDS }
    );

    const DEFAULT_SLATE_TEMPLATE = {
      ...FALLBACK_DEFAULT_SLATE,
      ...(BASE_DEFAULT_SLATE || {}),
      ...(sharedConfig.DEFAULT_SLATE || {})
    };

    const DEFAULT_SLATE_NORMALISED = normaliseSlateDataFn(DEFAULT_SLATE_TEMPLATE, FALLBACK_DEFAULT_SLATE);
    const DEFAULT_SLATE = {
      ...DEFAULT_SLATE_NORMALISED,
      notes: Array.isArray(DEFAULT_SLATE_NORMALISED.notes) ? [...DEFAULT_SLATE_NORMALISED.notes] : [],
      updatedAt: DEFAULT_SLATE_NORMALISED.updatedAt != null ? DEFAULT_SLATE_NORMALISED.updatedAt : null
    };

    const DEFAULT_BRB = {
      text: 'Be Right Back',
      isActive: false,
      updatedAt: null
    };

    const hasRandomUUID = typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function';

    function generateClientId(prefix) {
      const base = hasRandomUUID
        ? crypto.randomUUID()
        : `${Math.random().toString(36).slice(2)}${Date.now().toString(36)}`;
      return prefix ? `${prefix}-${base}` : base;
    }

    const SPECIAL_MAP = {
      '~~': 'rainbow',
      '%%': 'sparkle',
      '^^': 'bounce',
      '==': 'neon',
      '!!': 'glitch'
    };

    let state = deepClone(DEFAULT_STATE);
    let overlayPrefs = deepClone(DEFAULT_OVERLAY);
    let popupState = deepClone(DEFAULT_POPUP);
    let slateState = deepClone(DEFAULT_SLATE);
    let brbState = deepClone(DEFAULT_BRB);
    let presets = [];
    let scenes = [];

    const uiState = {
      editingIndex: -1,
      editingDraft: '',
      pendingPresetMessage: null,
      lastPreviewUrl: '',
      previewUpdateTimer: null,
      previewLoadingTimer: null,
      previewLoading: false
    };

    let eventSource = null;
    let eventSourceListeners = [];

    function createStateNotifier(callback, { debounce = 0, raf = true } = {}) {
      let timer = null;
      let frame = null;
      return function trigger() {
        if (debounce > 0) {
          clearTimeout(timer);
          timer = setTimeout(() => {
            timer = null;
            callback();
          }, debounce);
          return;
        }
        if (raf && typeof requestAnimationFrame === 'function') {
          if (frame !== null) cancelAnimationFrame(frame);
          frame = requestAnimationFrame(() => {
            frame = null;
            callback();
          });
          return;
        }
        callback();
      };
    }

    const PROXY_ARRAY_MUTATORS = new Set([
      'copyWithin',
      'fill',
      'pop',
      'push',
      'reverse',
      'shift',
      'sort',
      'splice',
      'unshift'
    ]);

    const proxyTargetMap = new WeakMap();

    function deepClone(value) {
      if (Array.isArray(value)) {
        return value.map(entry => deepClone(entry));
      }
      if (value && typeof value === 'object') {
        const clone = {};
        for (const key of Object.keys(value)) {
          clone[key] = deepClone(value[key]);
        }
        return clone;
      }
      return value;
    }

    function createDeepProxy(target, commit, cache = new WeakMap()) {
      if (!target || typeof target !== 'object') {
        return target;
      }
      if (cache.has(target)) {
        return cache.get(target);
      }
      const proxy = new Proxy(target, {
        get(obj, prop, receiver) {
          if (prop === '__raw__') {
            return target;
          }
          const value = Reflect.get(obj, prop, receiver);
          if (typeof value === 'function' && Array.isArray(obj) && PROXY_ARRAY_MUTATORS.has(prop)) {
            return function proxyArrayMutation(...args) {
              const result = value.apply(obj, args);
              commit();
              return result;
            };
          }
          if (value && typeof value === 'object') {
            return createDeepProxy(value, commit, cache);
          }
          return value;
        },
        set(obj, prop, value, receiver) {
          const nextValue = value && typeof value === 'object'
            ? proxyTargetMap.get(value) || value
            : value;
          const changed = Reflect.set(obj, prop, nextValue, receiver);
          if (changed) {
            commit();
          }
          return changed;
        },
        deleteProperty(obj, prop) {
          const deleted = Reflect.deleteProperty(obj, prop);
          if (deleted) {
            commit();
          }
          return deleted;
        }
      });
      cache.set(target, proxy);
      proxyTargetMap.set(proxy, target);
      return proxy;
    }

    function createStateStore() {
      const rawState = new Map();
      const proxies = new Map();
      const configs = new Map();

      function commit(key) {
        const base = rawState.get(key);
        const proxy = proxies.get(key);
        if (!base || !proxy) return;
        const config = configs.get(key) || {};
        if (typeof config.normalise === 'function') {
          config.normalise(base);
        }
        if (typeof config.validate === 'function') {
          const result = config.validate(base);
          if (result !== true && result !== undefined) {
            console.warn(`[Ticker] ${key} state validation failed`, result);
          }
        }
        if (typeof config.onChange === 'function') {
          try {
            config.onChange(proxy, base);
          } catch (err) {
            console.error('State listener failed', err);
          }
        }
      }

      return {
        register(key, value, options = {}) {
          configs.set(key, options);
          const clone = deepClone(value);
          rawState.set(key, clone);
          const proxy = createDeepProxy(clone, () => commit(key));
          proxies.set(key, proxy);
          commit(key);
          return proxy;
        },
        snapshot() {
          const snapshot = {};
          for (const [key, value] of rawState.entries()) {
            snapshot[key] = deepClone(value);
          }
          return snapshot;
        },
        get(key) {
          return proxies.get(key);
        }
      };
    }

    function createDebounced(fn, wait = 16) {
      let timer = null;
      return (...args) => {
        if (timer) {
          clearTimeout(timer);
        }
        timer = setTimeout(() => {
          timer = null;
          fn(...args);
        }, Math.max(0, wait));
      };
    }

    function normaliseTickerState(target) {
      const fallbackDuration = Number.isFinite(target.displayDuration)
        ? Number(target.displayDuration)
        : DEFAULT_STATE.displayDuration;
      const fallbackInterval = Number.isFinite(target.intervalMinutes)
        ? Number(target.intervalMinutes)
        : DEFAULT_STATE.intervalMinutes;

      if (Array.isArray(target.messages)) {
        const sanitised = sanitiseMessagesFn(target.messages);
        target.messages.length = 0;
        target.messages.push(...sanitised);
      } else {
        const sanitised = sanitiseMessagesFn([]);
        target.messages = sanitised;
      }

      target.displayDuration = clampDuration(target.displayDuration, fallbackDuration);

      if (Object.prototype.hasOwnProperty.call(target, 'intervalBetween')) {
        const seconds = Number(target.intervalBetween);
        const minutes = Number.isFinite(seconds) ? secondsToMinutes(seconds) : fallbackInterval;
        delete target.intervalBetween;
        target.intervalMinutes = clampMinutesValue(minutes, fallbackInterval);
      } else {
        target.intervalMinutes = clampMinutesValue(target.intervalMinutes, fallbackInterval);
      }

      target.isActive = !!target.isActive && target.messages.length > 0;

      const stampSource = target._updatedAt != null ? target._updatedAt : target.updatedAt;
      const stamp = Number(stampSource);
      target.updatedAt = Number.isFinite(stamp) ? stamp : Date.now();
      delete target._updatedAt;
    }

    function normaliseOverlayState(target) {
      const next = normaliseOverlayDataFn ? normaliseOverlayDataFn({ ...target }) : { ...target };
      Object.keys(target).forEach(key => {
        if (!Object.prototype.hasOwnProperty.call(next, key)) {
          delete target[key];
        }
      });
      Object.assign(target, next);
      const overlayStampSource = target._updatedAt != null ? target._updatedAt : target.updatedAt;
      const stamp = Number(overlayStampSource);
      target.updatedAt = Number.isFinite(stamp) ? stamp : Date.now();
      delete target._updatedAt;
    }

    function normalisePopupState(target) {
      const next = normalisePopupDataFn ? normalisePopupDataFn({ ...target }) : { ...target };
      Object.keys(target).forEach(key => {
        if (!Object.prototype.hasOwnProperty.call(next, key)) {
          delete target[key];
        }
      });
      Object.assign(target, next);
      const popupStampSource = target._updatedAt != null ? target._updatedAt : target.updatedAt;
      const stamp = Number(popupStampSource);
      target.updatedAt = Number.isFinite(stamp) ? stamp : Date.now();
      delete target._updatedAt;
    }

    function normaliseSlateState(target) {
      const next = normaliseSlateDataFn ? normaliseSlateDataFn({ ...target }) : { ...target };
      if (Array.isArray(next.notes)) {
        next.notes = normaliseSlateNotes(next.notes, EXPORTED_MAX_SLATE_NOTES, EXPORTED_MAX_SLATE_TEXT_LENGTH);
      }
      Object.keys(target).forEach(key => {
        if (!Object.prototype.hasOwnProperty.call(next, key)) {
          delete target[key];
        }
      });
      Object.assign(target, next);
      const slateStampSource = target._updatedAt != null ? target._updatedAt : target.updatedAt;
      const stamp = Number(slateStampSource);
      target.updatedAt = Number.isFinite(stamp) ? stamp : Date.now();
      delete target._updatedAt;
    }

    function normaliseBrbState(target) {
      const text = typeof target.text === 'string' ? target.text.trim() : '';
      target.text = text.slice(0, MAX_BRB_LENGTH);
      target.isActive = !!target.isActive && !!target.text;
      const brbStampSource = target._updatedAt != null ? target._updatedAt : target.updatedAt;
      const stamp = Number(brbStampSource);
      target.updatedAt = Number.isFinite(stamp) ? stamp : Date.now();
      delete target._updatedAt;
    }

    function validateTickerStateShape(target) {
      if (!isRecord(target)) return 'Ticker state must be an object';
      if (!Array.isArray(target.messages)) return 'Ticker state messages must be an array';
      if (!Number.isFinite(target.displayDuration)) return 'Ticker display duration is invalid';
      if (!Number.isFinite(target.intervalMinutes)) return 'Ticker interval is invalid';
      return true;
    }

    function validateOverlayStateShape(target) {
      return isRecord(target) ? true : 'Overlay preferences must be an object';
    }

    function validatePopupStateShape(target) {
      if (!isRecord(target)) return 'Popup state must be an object';
      if (target.durationSeconds != null && !Number.isFinite(target.durationSeconds)) {
        return 'Popup duration must be a number';
      }
      if (target.countdownTarget != null && !Number.isFinite(target.countdownTarget)) {
        return 'Popup countdown target must be numeric';
      }
      return true;
    }

    function validateSlateStateShape(target) {
      if (!isRecord(target)) return 'Slate state must be an object';
      if (target.notes != null && !Array.isArray(target.notes)) {
        return 'Slate notes must be an array';
      }
      return true;
    }

    function validateBrbStateShape(target) {
      return isRecord(target) ? true : 'BRB state must be an object';
    }

    function validatePresetStateShape(target) {
      return Array.isArray(target) ? true : 'Preset list must be an array';
    }

    function validateSceneStateShape(target) {
      return Array.isArray(target) ? true : 'Scene list must be an array';
    }

    function normalisePresetList(list) {
      const sanitised = [];
      if (Array.isArray(list)) {
        list.forEach(entry => {
          if (!entry || typeof entry !== 'object') return;
          const id = String(entry.id || generateClientId('preset'));
          const name = String(entry.name || 'Preset').slice(0, MAX_PRESET_NAME_LENGTH);
          const messages = sanitiseMessagesFn(entry.messages || []);
          const updatedAt = Number.isFinite(entry.updatedAt) ? Number(entry.updatedAt) : Date.now();
          sanitised.push({ id, name, messages, updatedAt });
        });
      }
      return sanitised;
    }

    function normaliseSceneList(list) {
      if (!Array.isArray(list)) return [];
      if (normaliseSceneEntryImpl) {
        return list
          .map(entry => normaliseSceneEntryImpl(entry, { normaliseOverlayData: normaliseOverlayDataFn }))
          .filter(Boolean);
      }
      return list.map(entry => {
        const source = entry && typeof entry === 'object' ? entry : {};
        return {
          id: String(source.id || generateClientId('scene')),
          name: String(source.name || 'Scene').slice(0, MAX_SCENE_NAME_LENGTH),
          overlay: buildSceneOverlayPayload(source.overlay)
        };
      });
    }

    const notifyTickerChange = createStateNotifier(() => {
      renderTicker();
      updateQueueControls();
      renderMessages();
      saveLocal();
    });

    const notifyOverlayChange = createStateNotifier(() => {
      renderOverlayControls();
      updateHighlightRegex();
      renderSlateControls();
      renderMessages();
      renderPopupControls();
      updateOverlayChip();
      saveLocal();
    }, { debounce: 16 });

    const notifyPopupChange = createStateNotifier(() => {
      renderPopupControls();
      updatePopupPreview();
      updatePopupMeta();
      saveLocal();
    }, { debounce: 16 });

    const notifySlateChange = createStateNotifier(() => {
      renderSlateControls();
      scheduleSlatePreviewNext();
      saveLocal();
    }, { debounce: 32 });

    const notifyBrbChange = createStateNotifier(() => {
      renderBrbControls();
      saveLocal();
    }, { debounce: 16 });

    const notifyPresetsChange = createStateNotifier(() => {
      renderPresets();
    }, { debounce: 16, raf: false });

    const notifyScenesChange = createStateNotifier(() => {
      renderScenes();
    }, { debounce: 16, raf: false });


    const el = {
      overlayChip: document.getElementById('overlayUrlChip'),
      overlayText: document.getElementById('overlayUrlText'),
      serverUrl: document.getElementById('serverUrl'),
      serverUrlStatus: document.getElementById('serverUrlStatus'),
      stateExport: document.getElementById('exportState'),
      stateImport: document.getElementById('importState'),
      stateImportInput: document.getElementById('importStateInput'),
      statusServerDot: document.getElementById('statusServerDot'),
      statusServer: document.getElementById('statusServer'),
      statusActive: document.getElementById('statusActive'),
      statusActiveText: document.getElementById('statusActiveText'),
      statusCount: document.getElementById('statusMessageCount'),
      statusUpdated: document.getElementById('statusUpdated'),
      autoStart: document.getElementById('autoStart'),
      duration: document.getElementById('displayDuration'),
      interval: document.getElementById('intervalMinutes'),
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      refreshBtn: document.getElementById('refreshBtn'),
      overlayLabel: document.getElementById('overlayLabel'),
      overlayAccent: document.getElementById('overlayAccent'),
      overlayAccentPicker: document.getElementById('overlayAccentPicker'),
      overlayAccentGroup: document.getElementById('overlayAccentGroup'),
      overlayAccentHint: document.getElementById('overlayAccentHint'),
      overlayAccentSecondary: document.getElementById('overlayAccentSecondary'),
      overlayAccentSecondaryPicker: document.getElementById('overlayAccentSecondaryPicker'),
      overlayAccentSecondaryGroup: document.getElementById('overlayAccentSecondaryGroup'),
      overlayAccentSecondaryHint: document.getElementById('overlayAccentSecondaryHint'),
      highlightWords: document.getElementById('highlightWords'),
      highlightWordsHint: document.getElementById('highlightWordsHint'),
      scaleRange: document.getElementById('scaleRange'),
      scaleNumber: document.getElementById('scaleNumber'),
      popupScaleRange: document.getElementById('popupScaleRange'),
      popupScaleNumber: document.getElementById('popupScaleNumber'),
      positionButtons: document.getElementById('positionButtons'),
      modeButtons: document.getElementById('modeButtons'),
      themeButtons: document.getElementById('themeButtons'),
      accentAnim: document.getElementById('accentAnimToggle'),
      sparkle: document.getElementById('sparkleToggle'),
      openOverlay: document.getElementById('openOverlay'),
      copyOverlay: document.getElementById('copyOverlay'),
      reloadPreview: document.getElementById('reloadPreview'),
      previewFrame: document.getElementById('overlayPreview'),
      previewFrameContainer: document.querySelector('.preview-frame'),
      messageForm: document.getElementById('messageForm'),
      newMessage: document.getElementById('newMessage'),
      addMessageButton: document.getElementById('addMessageButton'),
      clearMessages: document.getElementById('clearMessages'),
      exportMessages: document.getElementById('exportMessages'),
      importMessages: document.getElementById('importMessages'),
      messageList: document.getElementById('messageList'),
      presetName: document.getElementById('presetName'),
      savePreset: document.getElementById('savePreset'),
      presetList: document.getElementById('presetList'),
      sceneName: document.getElementById('sceneName'),
      saveScene: document.getElementById('saveScene'),
      sceneList: document.getElementById('sceneList'),
      toast: document.getElementById('toast'),
      popupText: document.getElementById('popupText'),
      popupActive: document.getElementById('popupActive'),
      popupPreview: document.getElementById('popupPreview'),
      popupMeta: document.getElementById('popupMeta'),
      popupDuration: document.getElementById('popupDuration'),
      popupCountdownEnabled: document.getElementById('popupCountdownEnabled'),
      popupCountdownTarget: document.getElementById('popupCountdownTarget'),
      popupPanel: document.getElementById('popupPanel'),
      popupActiveLabel: document.querySelector('#popupPanel .popup-toggle'),
      savePopup: document.getElementById('savePopup'),
      clearPopup: document.getElementById('clearPopup'),
      slateEnabled: document.getElementById('slateEnabled'),
      slateShowClock: document.getElementById('slateShowClock'),
      slateRotation: document.getElementById('slateRotation'),
      slateRotationNumber: document.getElementById('slateRotationNumber'),
      slateClockLabel: document.getElementById('slateClockLabel'),
      slateClockSubtitle: document.getElementById('slateClockSubtitle'),
      slateNextLabel: document.getElementById('slateNextLabel'),
      slateNextTitle: document.getElementById('slateNextTitle'),
      slateNextSubtitle: document.getElementById('slateNextSubtitle'),
      slateSponsorLabel: document.getElementById('slateSponsorLabel'),
      slateSponsorName: document.getElementById('slateSponsorName'),
      slateSponsorTagline: document.getElementById('slateSponsorTagline'),
      slateNotesLabel: document.getElementById('slateNotesLabel'),
      slateNotes: document.getElementById('slateNotes'),
      slateNotesHint: document.getElementById('slateNotesHint'),
      slatePreview: document.getElementById('slatePreview'),
      slatePreviewDots: document.getElementById('slatePreviewDots'),
      slatePreviewContent: document.getElementById('slatePreviewContent'),
      slatePreviewPill: document.querySelector('#slatePreviewContent .slate-preview-pill'),
      slatePreviewTitle: document.querySelector('#slatePreviewContent .slate-preview-title'),
      slatePreviewSubtitle: document.querySelector('#slatePreviewContent .slate-preview-subtitle'),
      slatePreviewMeta: document.querySelector('#slatePreviewContent .slate-preview-meta'),
      brbText: document.getElementById('brbText'),
      brbActive: document.getElementById('brbActive'),
      brbSave: document.getElementById('brbSave'),
      brbClear: document.getElementById('brbClear'),
      brbStatus: document.getElementById('brbStatus'),
      brbPanel: document.getElementById('brbPanel'),
      brbActiveLabel: document.querySelector('#brbPanel .brb-toggle'),
      statusBrb: document.getElementById('statusBrb'),
      statusBrbDot: document.getElementById('statusBrbDot'),
      presetModal: document.getElementById('presetMessageModal'),
      presetModalName: document.getElementById('presetModalName'),
      presetModalPreview: document.getElementById('presetModalPreview'),
      presetModalHint: document.getElementById('presetModalHint'),
      presetModalSave: document.getElementById('presetModalSave'),
      presetModalCancel: document.getElementById('presetModalCancel')
    };

    const PANEL_IDS = ['overlayPanel', 'slatePanel', 'popupPanel', 'brbPanel'];
    const panelSections = new Map(
      PANEL_IDS.map(id => [id, document.getElementById(id)])
        .filter(([, panel]) => !!panel)
    );
    const panelTabButtons = new Map(
      PANEL_IDS.map(id => [id, document.querySelector(`[data-panel-target="${id}"]`)])
        .filter(([, tab]) => !!tab)
    );
    let activePanelId = (() => {
      for (const [id, panel] of panelSections.entries()) {
        if (panel.classList.contains('is-active')) {
          return id;
        }
      }
      return panelSections.size ? panelSections.keys().next().value : PANEL_IDS[0];
    })();

    const stateStore = createStateStore();

    function initialiseStateStore() {
      if (stateStoreInitialised) {
        return;
      }

      stateStoreInitialised = true;

      state = stateStore.register('ticker', state, {
        normalise: normaliseTickerState,
        validate: validateTickerStateShape,
        onChange: () => {
          console.log('[DEBUG] Ticker state changed');
          notifyTickerChange();
        }
      });

      overlayPrefs = stateStore.register('overlay', overlayPrefs, {
        normalise: normaliseOverlayState,
        validate: validateOverlayStateShape,
        onChange: () => {
          console.log('[DEBUG] Overlay state changed');
          notifyOverlayChange();
        }
      });

      popupState = stateStore.register('popup', popupState, {
        normalise: normalisePopupState,
        validate: validatePopupStateShape,
        onChange: () => {
          console.log('[DEBUG] Popup state changed');
          notifyPopupChange();
        }
      });

      slateState = stateStore.register('slate', slateState, {
        normalise: normaliseSlateState,
        validate: validateSlateStateShape,
        onChange: () => {
          console.log('[DEBUG] Slate state changed');
          notifySlateChange();
        }
      });

      brbState = stateStore.register('brb', brbState, {
        normalise: normaliseBrbState,
        validate: validateBrbStateShape,
        onChange: () => {
          console.log('[DEBUG] BRB state changed');
          notifyBrbChange();
        }
      });

      presets = stateStore.register('presets', presets, {
        normalise: target => {
          const next = normalisePresetList(target);
          target.length = 0;
          target.push(...next);
        },
        validate: validatePresetStateShape,
        onChange: () => {
          console.log('[DEBUG] Presets state changed');
          notifyPresetsChange();
        }
      });

      scenes = stateStore.register('scenes', scenes, {
        normalise: target => {
          const next = normaliseSceneList(target);
          target.length = 0;
          target.push(...next);
        },
        validate: validateSceneStateShape,
        onChange: () => {
          console.log('[DEBUG] Scenes state changed');
          notifyScenesChange();
        }
      });
    }

    function orderedPanelIds() {
      return PANEL_IDS.filter(id => panelSections.has(id) && panelTabButtons.has(id));
    }

    function setActivePanel(panelId, options = {}) {
      const { skipSave = false, force = false } = options;
      const available = orderedPanelIds();
      if (!available.length) return null;
      const nextId = available.includes(panelId) ? panelId : available[0];
      if (!force && activePanelId === nextId) return activePanelId;

      activePanelId = nextId;

      for (const id of available) {
        const panel = panelSections.get(id);
        const tab = panelTabButtons.get(id);
        const isActive = id === nextId;
        if (panel) {
          panel.classList.toggle('is-active', isActive);
          if (isActive) {
            panel.removeAttribute('hidden');
            panel.setAttribute('aria-hidden', 'false');
            panel.tabIndex = 0;
          } else {
            panel.setAttribute('hidden', '');
            panel.setAttribute('aria-hidden', 'true');
            panel.tabIndex = -1;
          }
        }
        if (tab) {
          tab.classList.toggle('is-active', isActive);
          tab.setAttribute('aria-selected', isActive ? 'true' : 'false');
          tab.tabIndex = isActive ? 0 : -1;
        }
      }

      if (!skipSave) saveLocal();
      return nextId;
    }

    function focusAdjacentPanel(currentId, direction) {
      const available = orderedPanelIds();
      if (!available.length) return;
      const currentIndex = available.indexOf(currentId);
      const index = currentIndex === -1
        ? (direction > 0 ? 0 : available.length - 1)
        : (currentIndex + available.length + direction) % available.length;
      const targetId = available[index];
      if (targetId) {
        setActivePanel(targetId);
        const tab = panelTabButtons.get(targetId);
        if (tab && typeof tab.focus === 'function') {
          tab.focus();
        }
      }
    }

    const compositeSlateNotesLimit = MAX_SLATE_NOTES * MAX_SLATE_TEXT_LENGTH;

    if (el.slateClockLabel) el.slateClockLabel.maxLength = MAX_SLATE_TITLE_LENGTH;
    if (el.slateClockSubtitle) el.slateClockSubtitle.maxLength = MAX_SLATE_TEXT_LENGTH;
    if (el.slateNextLabel) el.slateNextLabel.maxLength = MAX_SLATE_TITLE_LENGTH;
    if (el.slateNextTitle) el.slateNextTitle.maxLength = MAX_SLATE_TITLE_LENGTH;
    if (el.slateNextSubtitle) el.slateNextSubtitle.maxLength = MAX_SLATE_TEXT_LENGTH;
    if (el.slateSponsorLabel) el.slateSponsorLabel.maxLength = MAX_SLATE_TITLE_LENGTH;
    if (el.slateSponsorName) el.slateSponsorName.maxLength = MAX_SLATE_TITLE_LENGTH;
    if (el.slateSponsorTagline) el.slateSponsorTagline.maxLength = MAX_SLATE_TEXT_LENGTH;
    if (el.slateNotesLabel) el.slateNotesLabel.maxLength = MAX_SLATE_TITLE_LENGTH;
    if (el.slateNotes) el.slateNotes.maxLength = compositeSlateNotesLimit;
    if (el.slateNotesHint) {
      el.slateNotesHint.textContent = `Up to ${MAX_SLATE_NOTES} lines (${MAX_SLATE_TEXT_LENGTH} characters each) rotate alongside the clock card.`;
    }
    if (el.sceneName) el.sceneName.maxLength = MAX_SCENE_NAME_LENGTH;

    let fetchInFlight = false;
    let fetchPending = false;
    let fetchPendingSilent = true;
    let saveTimer = null;
    let overlaySaveTimer = null;
    let overlaySaveInFlight = false;
    let pendingOverlayPayload = null;
    let overlayHasPendingLocalChanges = false;
    let overlayAwaitingServerCommit = false;
    let overlayAwaitingServerCommitStamp = null;
    let popupSaveTimer = null;
    let popupSaveInFlight = false;
    let pendingPopupPayload = null;
    let popupHasPendingLocalChanges = false;
    let popupAwaitingServerCommit = false;
    let popupAwaitingServerCommitStamp = null;
    let slateSaveTimer = null;
    let slateSaveInFlight = false;
    let pendingSlatePayload = null;
    let slateHasPendingLocalChanges = false;
    let slateAwaitingServerCommit = false;
    let slatePreviewTimer = null;
    let slatePreviewDisplayTimer = null;
    let slatePreviewClockTimer = null;
    let slatePreviewIndex = 0;
    let slatePreviewCards = [];
    let popupPreviewCountdownTimer = null;
    let popupPreviewCountdownTarget = null;
    let popupPreviewAnimator = null;
    let popupPreviewLastText = '';
    let slatePreviewAnimator = null;
    let brbSaveTimer = null;
    let brbSaveInFlight = false;
    let scenesSaveInFlight = false;
    let pendingSceneMessage = null;
    let highlightRegex = null;
    let streamPrimed = false;
    let streamFallbackTimer = null;
    let connectionRetryTimer = null;
    let connectionRetryAttempt = 0;
    let healthCheckTimer = null;
    let consecutiveHealthFailures = 0;
    let pollingTimer = null;
    let currentServerStatus = 'checking';
    let isPollingActive = false;
    let handlersRegistered = false;
    let initStarted = false;
    let stateStoreInitialised = false;

    const stateRequestQueue = createAsyncQueue({ concurrency: 1 });
    const mutationQueues = {
      ticker: createAsyncQueue({ concurrency: 1 }),
      presets: createAsyncQueue({ concurrency: 1 }),
      overlay: createAsyncQueue({ concurrency: 1 }),
      popup: createAsyncQueue({ concurrency: 1 }),
      brb: createAsyncQueue({ concurrency: 1 }),
      slate: createAsyncQueue({ concurrency: 1 }),
      scenes: createAsyncQueue({ concurrency: 1 })
    };

    function setPanelBusy(panelId, busy, options = {}) {
      const panel = panelSections.get(panelId);
      if (!panel) return;
      if (busy) {
        const { label, state } = options;
        panel.dataset.busy = 'true';
        panel.setAttribute('aria-busy', 'true');
        panel.dataset.busyLabel = label || 'Saving…';
        if (state) {
          panel.dataset.busyState = state;
        } else {
          delete panel.dataset.busyState;
        }
      } else {
        delete panel.dataset.busy;
        panel.removeAttribute('aria-busy');
        delete panel.dataset.busyLabel;
        delete panel.dataset.busyState;
      }
    }

    function updatePanelBusyStates() {
      let overlayState = null;
      if (overlaySaveInFlight || overlayAwaitingServerCommit) {
        overlayState = 'saving';
      } else if (overlaySaveTimer) {
        overlayState = 'pending';
      } else if (overlayHasPendingLocalChanges) {
        overlayState = 'draft';
      }
      setPanelBusy('overlayPanel', Boolean(overlayState), {
        label: overlayState === 'pending'
          ? 'Queued…'
          : overlayState === 'saving'
            ? 'Saving…'
            : 'Unsaved changes',
        state: overlayState
      });

      const slateStateBusy = slateSaveInFlight ? 'saving' : (slateSaveTimer ? 'pending' : null);
      setPanelBusy('slatePanel', Boolean(slateStateBusy), {
        label: slateStateBusy === 'pending' ? 'Queued…' : 'Saving…',
        state: slateStateBusy
      });

      let popupStateBusy = null;
      if (popupSaveInFlight || popupAwaitingServerCommit) {
        popupStateBusy = 'saving';
      } else if (popupSaveTimer) {
        popupStateBusy = 'pending';
      } else if (popupHasPendingLocalChanges) {
        popupStateBusy = 'draft';
      }
      setPanelBusy('popupPanel', Boolean(popupStateBusy), {
        label: popupStateBusy === 'pending'
          ? 'Queued…'
          : popupStateBusy === 'saving'
            ? 'Updating…'
            : 'Unsaved changes',
        state: popupStateBusy
      });

      const brbStateBusy = brbSaveInFlight ? 'saving' : (brbSaveTimer ? 'pending' : null);
      setPanelBusy('brbPanel', Boolean(brbStateBusy), {
        label: brbStateBusy === 'pending' ? 'Queued…' : 'Updating…',
        state: brbStateBusy
      });
    }

    const STREAM_STATES = Object.freeze({
      IDLE: 'idle',
      CONNECTING: 'connecting',
      OPEN: 'open',
      ERROR: 'error',
      POLLING: 'polling'
    });
    let streamConnectionState = STREAM_STATES.IDLE;

    function setStreamState(nextState, meta = {}) {
      if (!Object.values(STREAM_STATES).includes(nextState)) return;
      if (streamConnectionState === nextState) return;
      streamConnectionState = nextState;
      switch (nextState) {
        case STREAM_STATES.CONNECTING:
          stopHealthChecks();
          break;
        case STREAM_STATES.OPEN:
          connectionRetryAttempt = 0;
          clearReconnectTimer();
          stopPolling();
          startHealthChecks();
          applyServerStatus('online', { force: true });
          break;
        case STREAM_STATES.ERROR:
          stopHealthChecks();
          if (meta && meta.message) {
            console.warn('[Ticker] stream error state', meta);
          }
          break;
        case STREAM_STATES.POLLING:
          stopHealthChecks();
          break;
        case STREAM_STATES.IDLE:
        default:
          stopHealthChecks();
          break;
      }
    }

    const HEALTH_CHECK_INTERVAL_MS = 30000;
    const HEALTH_CHECK_TIMEOUT_MS = 5000;
    const HEALTH_CHECK_FAILURE_THRESHOLD = 2;
    const STREAM_BACKOFF_BASE_MS = 1000;
    const STREAM_BACKOFF_MAX_MS = 15000;
    const STREAM_MAX_FAILURES_BEFORE_POLLING = 3;
    const STREAM_PRIME_TIMEOUT_MS = 1500;
    const POLLING_INTERVAL_MS = 6000;

    const SERVER_STATUS_CONFIG = {
      checking: {
        text: 'Checking…',
        valueClass: 'status-value--warning',
        dotClass: 'status-dot--warning',
        hint: 'Validating server health…',
        tone: 'warning'
      },
      online: {
        text: 'Online',
        valueClass: 'status-value--success',
        dotClass: 'status-dot--success',
        hint: 'Connected to server.',
        tone: 'success'
      },
      reconnecting: {
        text: 'Reconnecting…',
        valueClass: 'status-value--warning',
        dotClass: 'status-dot--warning',
        hint: 'Attempting to reconnect…',
        tone: 'warning'
      },
      offline: {
        text: 'Offline',
        valueClass: 'status-value--offline',
        dotClass: 'status-dot--offline',
        hint: 'Unable to reach server at the configured URL.',
        tone: 'error'
      },
      polling: {
        text: 'Polling…',
        valueClass: 'status-value--warning',
        dotClass: 'status-dot--warning',
        hint: 'Realtime stream unavailable; using polling fallback.',
        tone: 'warning'
      },
      invalid: {
        text: 'Invalid URL',
        valueClass: 'status-value--error',
        dotClass: 'status-dot--error',
        hint: 'Enter a valid HTTP(S) URL.',
        tone: 'error',
        invalid: true
      },
      error: {
        text: 'Stream error',
        valueClass: 'status-value--error',
        dotClass: 'status-dot--error',
        hint: 'Realtime stream error. Retrying…',
        tone: 'error'
      },
      degraded: {
        text: 'Degraded',
        valueClass: 'status-value--warning',
        dotClass: 'status-dot--warning',
        hint: 'Health checks failing intermittently.',
        tone: 'warning'
      }
    };

    const DEFAULT_SERVER_STATUS = {
      text: 'Status unknown',
      valueClass: 'status-value--neutral',
      dotClass: 'status-dot--neutral',
      hint: 'Server status unknown.',
      tone: 'neutral'
    };

    const STATUS_VALUE_CLASSNAMES = [
      'status-value--success',
      'status-value--warning',
      'status-value--error',
      'status-value--offline',
      'status-value--neutral'
    ];

    const STATUS_DOT_CLASSNAMES = [
      'status-dot--success',
      'status-dot--warning',
      'status-dot--error',
      'status-dot--offline',
      'status-dot--neutral'
    ];

    const HEALTH_REASON_MESSAGES = {
      timeout: 'Server health check timed out.',
      network: 'Unable to reach server at the configured URL.',
      'http-error': 'Server responded with an error.',
      'invalid-response': 'Health endpoint returned unexpected payload.',
      unsupported: 'Health check unsupported in this environment.',
      'invalid-url': 'Enter a valid HTTP(S) URL.'
    };

    function resolveHealthMessage(reason, status) {
      if (typeof reason === 'string' && HEALTH_REASON_MESSAGES[reason]) {
        return HEALTH_REASON_MESSAGES[reason];
      }
      if (status && SERVER_STATUS_CONFIG[status] && SERVER_STATUS_CONFIG[status].hint) {
        return SERVER_STATUS_CONFIG[status].hint;
      }
      return 'Server health check failed.';
    }

    function updateServerUrlStatus(status, message, statusConfig = DEFAULT_SERVER_STATUS) {
      if (!el.serverUrlStatus) return;
      const config = statusConfig || DEFAULT_SERVER_STATUS;
      const hasExplicitMessage = message !== undefined && message !== null;
      const resolvedMessage = hasExplicitMessage
        ? String(message).trim()
        : (config.hint || DEFAULT_SERVER_STATUS.hint || '');

      if (resolvedMessage) {
        safeSetText(el.serverUrlStatus, resolvedMessage);
        el.serverUrlStatus.hidden = false;
      } else {
        safeSetText(el.serverUrlStatus, '');
        el.serverUrlStatus.hidden = true;
      }

      if (el.serverUrlStatus.dataset) {
        const tone = config.tone || DEFAULT_SERVER_STATUS.tone || 'neutral';
        if (tone) {
          el.serverUrlStatus.dataset.tone = tone;
        } else {
          delete el.serverUrlStatus.dataset.tone;
        }
      }

      if (el.serverUrl) {
        const shouldMarkInvalid = config.invalid === true && status === 'invalid';
        if (shouldMarkInvalid) {
          el.serverUrl.setAttribute('aria-invalid', 'true');
        } else {
          el.serverUrl.removeAttribute('aria-invalid');
        }
      }
    }

    function applyServerStatus(status, options = {}) {
      const { message, label, force = false } = options;
      if (!force && isPollingActive && status !== 'polling') {
        return;
      }
      const config = SERVER_STATUS_CONFIG[status] || DEFAULT_SERVER_STATUS;
      if (!force && currentServerStatus === status && !message && !label) {
        return;
      }
      currentServerStatus = status;
      const fallbackText = config.text || DEFAULT_SERVER_STATUS.text || '';
      const statusLabel = typeof label === 'string' && label.trim()
        ? label.trim()
        : fallbackText || (typeof message === 'string' && message.trim() ? message.trim() : fallbackText);
      if (el.statusServer) {
        safeSetText(el.statusServer, statusLabel);
        safeSetDataset(el.statusServer, 'status', status);
        if (el.statusServer.style) {
          el.statusServer.style.removeProperty('color');
        }
        if (el.statusServer.classList) {
          el.statusServer.classList.remove(...STATUS_VALUE_CLASSNAMES);
          const valueClass = config.valueClass || DEFAULT_SERVER_STATUS.valueClass;
          if (valueClass) {
            el.statusServer.classList.add(valueClass);
          }
        }
      }
      if (el.statusServerDot && el.statusServerDot.classList) {
        safeSetDataset(el.statusServerDot, 'status', status);
        el.statusServerDot.classList.remove(...STATUS_DOT_CLASSNAMES);
        const dotClass = config.dotClass || DEFAULT_SERVER_STATUS.dotClass;
        if (dotClass) {
          el.statusServerDot.classList.add(dotClass);
        }
      }

      updateServerUrlStatus(status, message, config);
    }

    function clearReconnectTimer() {
      if (connectionRetryTimer) {
        clearTimeout(connectionRetryTimer);
        connectionRetryTimer = null;
      }
    }

    function stopHealthChecks() {
      if (healthCheckTimer) {
        clearInterval(healthCheckTimer);
        healthCheckTimer = null;
      }
      consecutiveHealthFailures = 0;
    }

    function startHealthChecks() {
      stopHealthChecks();
      healthCheckTimer = setInterval(async () => {
        const result = await checkServerHealth();
        if (!result.ok) {
          consecutiveHealthFailures = Math.min(consecutiveHealthFailures + 1, 50);
          if (!isPollingActive) {
            const nextStatus = currentServerStatus === 'online' ? 'degraded' : 'offline';
            const message = resolveHealthMessage(result.reason, nextStatus);
            applyServerStatus(nextStatus, { message, force: true });
          }
          if (consecutiveHealthFailures >= HEALTH_CHECK_FAILURE_THRESHOLD) {
            console.warn('[Ticker] Health checks failing, degrading stream connection', {
              failures: consecutiveHealthFailures,
              reason: result.reason
            });
            if (streamConnectionState === STREAM_STATES.OPEN || streamConnectionState === STREAM_STATES.CONNECTING) {
              disconnectStream({ preservePolling: true });
            }
            if (!isPollingActive) {
              startPolling('health-check');
            }
            scheduleReconnect('health-check');
            void fetchState({ silent: true });
          }
        } else {
          consecutiveHealthFailures = 0;
          if (!isPollingActive && currentServerStatus !== 'online') {
            applyServerStatus('online', { force: true });
          }
        }
      }, HEALTH_CHECK_INTERVAL_MS);
    }

    function stopPolling() {
      if (pollingTimer) {
        clearInterval(pollingTimer);
        pollingTimer = null;
      }
      isPollingActive = false;
      if (streamConnectionState === STREAM_STATES.POLLING) {
        setStreamState(STREAM_STATES.IDLE);
      }
    }

    function startPolling(reason = 'sse-failure') {
      const alreadyPolling = Boolean(pollingTimer);
      if (!alreadyPolling) {
        const poll = () => {
          void fetchState({ silent: true });
        };
        poll();
        pollingTimer = setInterval(poll, POLLING_INTERVAL_MS);
      }
      isPollingActive = true;
      setStreamState(STREAM_STATES.POLLING, { reason });
      applyServerStatus('polling', { force: true });
      if (!alreadyPolling) {
        console.warn('[Ticker] Falling back to polling mode', { reason });
      }
    }

    function validateServerUrlFormat(value) {
      if (typeof value !== 'string' || !value.trim()) {
        return { ok: false, reason: 'empty' };
      }
      try {
        const parsed = new URL(value);
        if (!/^https?:$/.test(parsed.protocol)) {
          return { ok: false, reason: 'protocol', url: value };
        }
        const pathname = parsed.pathname.replace(/\/+$/, '');
        const normalised = `${parsed.origin}${pathname || ''}`;
        return { ok: true, url: normalised || parsed.origin };
      } catch (error) {
        return { ok: false, reason: 'invalid', error };
      }
    }

    function getValidatedServerBase() {
      const base = serverBase();
      const validation = validateServerUrlFormat(base);
      return { base, ...validation };
    }

    function deriveHealthErrorReason(error) {
      if (!error || typeof error !== 'object') {
        return 'network';
      }
      const nestedCause = error && error.cause ? error.cause : null;
      const code = error.code || (nestedCause && nestedCause.code);
      if (code === 'timeout' || error.name === 'AbortError' || error.name === 'TimeoutError') {
        return 'timeout';
      }
      if (code === 'http_error') {
        return 'http-error';
      }
      if (code === 'invalid_response' || code === 'parse_error') {
        return 'invalid-response';
      }
      if (code === 'unsupported') {
        return 'unsupported';
      }
      if (code === 'network') {
        return 'network';
      }
      if (typeof error.status === 'number' && error.status >= 400) {
        return 'http-error';
      }
      if (typeof error.message === 'string') {
        if (/^HTTP\s+\d+/i.test(error.message)) {
          return 'http-error';
        }
        if (/timed out/i.test(error.message)) {
          return 'timeout';
        }
      }
      return 'network';
    }

    async function checkServerHealth() {
      const { ok, url, reason } = getValidatedServerBase();
      if (!ok || !url) {
        return { ok: false, reason: reason || 'invalid-url', url: url || null };
      }
      try {
        await requestJson(`${url}/health`, {
          init: { cache: 'no-store' },
          timeoutMs: HEALTH_CHECK_TIMEOUT_MS,
          validate: payload => (payload && payload.ok === true ? true : 'Invalid health payload'),
          dedupe: true
        });
        return { ok: true, url };
      } catch (error) {
        return { ok: false, url, error, reason: deriveHealthErrorReason(error) };
      }
    }

    function scheduleReconnect(reason = 'unknown') {
      if (connectionRetryTimer) {
        return;
      }
      const baseDelay = Math.min(
        STREAM_BACKOFF_BASE_MS * Math.pow(2, connectionRetryAttempt),
        STREAM_BACKOFF_MAX_MS
      );
      const jitterMultiplier = 0.8 + Math.random() * 0.4;
      const delay = Math.max(
        STREAM_BACKOFF_BASE_MS,
        Math.round(baseDelay * jitterMultiplier)
      );
      connectionRetryAttempt = Math.min(connectionRetryAttempt + 1, 32);
      if (connectionRetryAttempt >= STREAM_MAX_FAILURES_BEFORE_POLLING && !isPollingActive) {
        startPolling(reason);
      }
      if (streamConnectionState !== STREAM_STATES.ERROR && streamConnectionState !== STREAM_STATES.POLLING) {
        setStreamState(STREAM_STATES.ERROR, { reason });
      }
      applyServerStatus('reconnecting', { force: true });
      connectionRetryTimer = setTimeout(() => {
        connectionRetryTimer = null;
        void connectStream({ isRetry: true, reason });
      }, delay);
      console.warn('[Ticker] Event stream reconnect scheduled', {
        attempt: connectionRetryAttempt,
        delay,
        baseDelay,
        jitterMultiplier,
        reason
      });
    }

    function toast(message) {
      if (!el.toast) {
        console.warn('[Ticker] Toast container missing; message:', message);
        return;
      }
      const text = sanitiseTextInput(message, { fallback: '' }) || '';
      el.toast.textContent = text;
      el.toast.classList.add('show');
      if (el.toast._hideTimer) {
        clearTimeout(el.toast._hideTimer);
      }
      el.toast._hideTimer = setTimeout(() => {
        if (!el.toast) return;
        el.toast.classList.remove('show');
        el.toast._hideTimer = null;
      }, 1800);
    }

    function sanitiseServerUrlInput(value) {
      if (typeof value !== 'string') return '';
      const trimmed = value.trim();
      if (!trimmed) return '';
      const cleaned = trimmed.replace(/^[`'"]+/, '').replace(/[`'"]+$/, '');
      const lowered = cleaned.toLowerCase();
      const tokenCandidate = lowered.replace(/^[\\/]+|[\\/]+$/g, '');
      if (tokenCandidate === 'undefined' || tokenCandidate === 'null') {
        return '';
      }
      if (/\/(?:undefined|null)(?:[/?#]|$)/.test(lowered)) {
        return '';
      }
      return cleaned;
    }

    function serverBase() {
      const previous = el.serverUrl && typeof el.serverUrl.value === 'string'
        ? el.serverUrl.value
        : '';

      const fallbackOrigin = (() => {
        if (typeof location === 'object' && location && typeof location.origin === 'string') {
          const origin = location.origin.trim();
          if (origin && origin !== 'null') {
            try {
              const parsed = new URL(origin);
              if (/^https?:$/.test(parsed.protocol)) {
                return parsed.origin;
              }
            } catch (error) {
              console.warn('[Ticker] Ignoring invalid location.origin', { origin, error });
            }
          }
        }
        return DEFAULT_SERVER_URL;
      })();

      const sanitisedPrevious = sanitiseServerUrlInput(previous);
      const candidate = sanitisedPrevious || fallbackOrigin;
      let base = normaliseServerBase(candidate, fallbackOrigin);
      if (typeof base !== 'string' || !base.trim()) {
        base = fallbackOrigin;
      } else {
        base = base.trim();
      }

      base = base
        .replace(/\/ticker\/?$/i, '')
        .replace(/\/+$/g, '');

      if (!base) {
        base = fallbackOrigin || DEFAULT_SERVER_URL;
      }

      if (el.serverUrl && el.serverUrl.value !== base) {
        safeSetValue(el.serverUrl, base);
        try {
          if (typeof saveLocal === 'function') {
            saveLocal();
          }
        } catch (err) {
          console.warn('Failed to persist server URL', err);
        }
      }

      return base;
    }

    function secondsToMinutes(seconds) {
      return Math.max(0, Math.min(60, Math.round((Number(seconds) || 0) * 100 / 60) / 100));
    }

    function minutesToSeconds(minutes) {
      const numeric = Number(minutes);
      if (!Number.isFinite(numeric)) return 0;
      return Math.max(0, Math.min(3600, Math.round(numeric * 60)));
    }

    function isSafeColour(value) {
      if (typeof sharedIsSafeCssColor === 'function') {
        return sharedIsSafeCssColor(value);
      }
      return /^#(?:[0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(String(value || ''));
    }

    function parseHexForPicker(value) {
      if (typeof value !== 'string') return null;
      const trimmed = value.trim();
      const match = trimmed.match(/^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i);
      if (!match) return null;
      const hex = match[1];
      if (hex.length === 3) {
        return `#${hex.split('').map(ch => `${ch}${ch}`).join('').toLowerCase()}`;
      }
      if (hex.length === 4) {
        const rgb = hex.slice(0, 3).split('').map(ch => `${ch}${ch}`).join('');
        return `#${rgb.toLowerCase()}`;
      }
      if (hex.length === 6) {
        return `#${hex.toLowerCase()}`;
      }
      if (hex.length === 8) {
        return `#${hex.slice(0, 6).toLowerCase()}`;
      }
      return null;
    }

    function clampSlateRotation(value) {
      if (typeof clampSlateRotationSeconds === 'function') {
        return clampSlateRotationSeconds(value, DEFAULT_SLATE.rotationSeconds || 12);
      }
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return DEFAULT_SLATE.rotationSeconds || 12;
      return Math.min(Math.max(Math.round(numeric), 4), 900);
    }

    function computeSlateVisibleSeconds(rotationSeconds) {
      const rotation = clampSlateRotation(rotationSeconds);
      if (!Number.isFinite(rotation) || rotation <= 0) return 0;
      const candidate = rotation - 1;
      const visible = Math.min(6, Math.max(2, candidate));
      return visible;
    }

    function computeSlateGapMs(rotationSeconds) {
      const rotation = clampSlateRotation(rotationSeconds);
      if (!Number.isFinite(rotation) || rotation <= 0) return 0;
      const visibleSeconds = computeSlateVisibleSeconds(rotation);
      const totalMs = rotation * 1000;
      const visibleMs = visibleSeconds * 1000;
      const gap = Math.max(1000, totalMs - visibleMs);
      return gap;
    }

    function serialiseSlateState(source = slateState) {
      const normalised = normaliseSlateDataFn(source);
      return {
        isEnabled: !!normalised.isEnabled,
        rotationSeconds: clampSlateRotation(normalised.rotationSeconds),
        showClock: !!normalised.showClock,
        clockLabel: normalised.clockLabel || '',
        clockSubtitle: normalised.clockSubtitle || '',
        nextLabel: normalised.nextLabel || '',
        nextTitle: normalised.nextTitle || '',
        nextSubtitle: normalised.nextSubtitle || '',
        sponsorLabel: normalised.sponsorLabel || '',
        sponsorName: normalised.sponsorName || '',
        sponsorTagline: normalised.sponsorTagline || '',
        notesLabel: normalised.notesLabel || '',
        notes: Array.isArray(normalised.notes) ? normalised.notes.slice(0, MAX_SLATE_NOTES) : []
      };
    }

    function buildSceneOverlayPayload(source) {
      if (!source || typeof source !== 'object') return null;

      if (serialiseOverlayForSceneImpl) {
        return serialiseOverlayForSceneImpl(source, {
          normaliseOverlayData: normaliseOverlayDataFn,
          overlayKeys: SCENE_OVERLAY_KEYS,
          includeEmptyStrings: true
        });
      }

      const normalised = normaliseOverlayDataFn(source);
      const result = {};
      let hasValue = false;

      for (const key of SCENE_OVERLAY_KEYS) {
        if (!Object.prototype.hasOwnProperty.call(source, key)) continue;
        if (!(key in normalised)) continue;
        const value = normalised[key];
        if (value === undefined) continue;
        result[key] = value;
        hasValue = true;
      }

      if (!hasValue && Object.prototype.hasOwnProperty.call(source, 'theme')) {
        const themeOnly = normaliseOverlayDataFn({ theme: source.theme });
        if (themeOnly && typeof themeOnly.theme === 'string' && themeOnly.theme) {
          result.theme = themeOnly.theme;
          hasValue = true;
        }
      }

      return hasValue ? result : null;
    }

    function deriveSlateCardsForPreview(slate, _overlay = overlayPrefs) {
      const cards = [];
      const activeSlate = normaliseSlateDataFn(slate);

      const pushCard = (type, pill, title, subtitle = '') => {
        const safeTitle = typeof title === 'string' ? title.trim().slice(0, MAX_SLATE_TITLE_LENGTH) : '';
        const safeSubtitle = typeof subtitle === 'string' ? subtitle.trim().slice(0, MAX_SLATE_TEXT_LENGTH) : '';
        if (!safeTitle && !safeSubtitle) return;
        cards.push({
          type,
          pill: pill && typeof pill === 'string' ? pill.trim() : '',
          title: safeTitle,
          subtitle: safeSubtitle,
          meta: ''
        });
      };

      if (activeSlate.showClock) {
        const now = new Date();
        const time = now.toLocaleTimeString('en-GB', {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false,
          timeZone: 'Europe/London'
        });
        cards.push({
          type: 'clock',
          pill: (activeSlate.clockLabel || 'UK TIME').trim(),
          title: time,
          subtitle: (activeSlate.clockSubtitle || 'UK time').trim(),
          meta: ''
        });
      }

      if (activeSlate.nextTitle || activeSlate.nextSubtitle) {
        pushCard(
          'next',
          activeSlate.nextLabel || 'Next up',
          activeSlate.nextTitle || activeSlate.nextLabel || 'Next up',
          activeSlate.nextSubtitle || ''
        );
      }

      if (activeSlate.sponsorName) {
        pushCard(
          'sponsor',
          activeSlate.sponsorLabel || 'Sponsor',
          activeSlate.sponsorName,
          activeSlate.sponsorTagline || ''
        );
      }

      if (Array.isArray(activeSlate.notes)) {
        for (const note of activeSlate.notes) {
          pushCard('note', activeSlate.notesLabel || 'Spotlight', note, '');
        }
      }

      return cards;
    }

    function clearSlatePreviewTimers() {
      if (slatePreviewTimer) {
        clearTimeout(slatePreviewTimer);
        slatePreviewTimer = null;
      }
      if (slatePreviewDisplayTimer) {
        clearTimeout(slatePreviewDisplayTimer);
        slatePreviewDisplayTimer = null;
      }
      stopSlatePreviewClock();
    }

    function startSlatePreviewClock(card) {
      stopSlatePreviewClock();
      if (!card || card.type !== 'clock') return;
      slatePreviewClockTimer = setInterval(() => {
        const cards = deriveSlateCardsForPreview(slateState, overlayPrefs);
        slatePreviewCards = cards;
        if (!slateState.isEnabled || !cards.length) {
          updateSlatePreview();
          return;
        }
        if (slatePreviewIndex >= cards.length) {
          slatePreviewIndex = 0;
        }
        applySlatePreviewCard(cards[slatePreviewIndex], { updateDots: true, animate: false });
      }, 1000);
    }

    function stopSlatePreviewClock() {
      if (slatePreviewClockTimer) {
        clearInterval(slatePreviewClockTimer);
        slatePreviewClockTimer = null;
      }
    }

    function renderSlatePreviewDots() {
      if (!el.slatePreviewDots) return;
      if (!slateState.isEnabled || slatePreviewCards.length <= 1) {
        el.slatePreviewDots.innerHTML = '';
        return;
      }
      const dots = slatePreviewCards.map((_, index) => {
        const active = index === slatePreviewIndex ? ' is-active' : '';
        return `<button type="button" class="slate-preview-dot${active}" data-index="${index}" aria-label="Show slate card ${index + 1}"></button>`;
      }).join('');
      el.slatePreviewDots.innerHTML = dots;
    }

    function showSlatePreview() {
    if (el.slatePreview) {
        el.slatePreview.classList.add('is-visible');
      }
    }

    function hideSlatePreview() {
    if (el.slatePreview) {
        el.slatePreview.classList.remove('is-visible');
      }
      destroySlatePreviewAnimator();
    }

    function applySlatePreviewCard(card, { updateDots = true, animate = true } = {}) {
      if (!el.slatePreview || !el.slatePreviewContent || !card) return;
      destroySlatePreviewAnimator();
      el.slatePreview.classList.remove('is-empty');
      el.slatePreview.dataset.type = card.type || '';
      el.slatePreviewContent.dataset.type = card.type || '';
    if (el.slatePreviewPill) el.slatePreviewPill.textContent = card.pill || 'Slate';
    if (el.slatePreviewTitle) el.slatePreviewTitle.textContent = card.title || '';
    if (el.slatePreviewSubtitle) {
        if (card.subtitle) {
          el.slatePreviewSubtitle.textContent = card.subtitle;
          el.slatePreviewSubtitle.classList.remove('is-hidden');
        } else {
          el.slatePreviewSubtitle.textContent = '';
          el.slatePreviewSubtitle.classList.add('is-hidden');
        }
      }
    if (el.slatePreviewMeta) {
        if (card.meta) {
          el.slatePreviewMeta.textContent = card.meta;
          el.slatePreviewMeta.classList.remove('is-hidden');
        } else {
          el.slatePreviewMeta.textContent = '';
          el.slatePreviewMeta.classList.add('is-hidden');
        }
      }
      if (animate && el.slatePreviewContent) {
        el.slatePreviewContent.classList.remove('refresh');
        if (el.slatePreviewContent._refreshTimer) {
          clearTimeout(el.slatePreviewContent._refreshTimer);
          el.slatePreviewContent._refreshTimer = null;
        }
        void el.slatePreviewContent.offsetWidth;
        el.slatePreviewContent.classList.add('refresh');
        el.slatePreviewContent._refreshTimer = setTimeout(() => {
          el.slatePreviewContent.classList.remove('refresh');
          el.slatePreviewContent._refreshTimer = null;
        }, 400);
      }
      stopSlatePreviewClock();
      if (updateDots) {
        renderSlatePreviewDots();
      }
      if (card.type === 'clock') {
        startSlatePreviewClock(card);
      }
      if (animate && card.type !== 'clock') {
        const headerEl = el.slatePreviewTitle && el.slatePreviewTitle.textContent.trim() ? el.slatePreviewTitle : null;
        const bodyTargets = [];
        if (el.slatePreviewSubtitle && !el.slatePreviewSubtitle.classList.contains('is-hidden') && el.slatePreviewSubtitle.textContent.trim()) {
          bodyTargets.push(el.slatePreviewSubtitle);
        }
        if (el.slatePreviewMeta && !el.slatePreviewMeta.classList.contains('is-hidden') && el.slatePreviewMeta.textContent.trim()) {
          bodyTargets.push(el.slatePreviewMeta);
        }
        if (headerEl) {
          const animator = createTextAnimator(headerEl, bodyTargets);
          if (animator) {
            slatePreviewAnimator = animator;
            animator.playIn().catch(() => destroySlatePreviewAnimator());
          }
        }
      }
    }

    function playSlatePreviewCard(index = slatePreviewIndex, { animate = true, updateDots = true } = {}) {
      if (!slatePreviewCards.length) return;
      const rotationSeconds = clampSlateRotation(slateState.rotationSeconds);
      clearSlatePreviewTimers();
      const nextIndex = index % slatePreviewCards.length;
      slatePreviewIndex = nextIndex < 0 ? slatePreviewCards.length - 1 : nextIndex;
      applySlatePreviewCard(slatePreviewCards[slatePreviewIndex], { updateDots, animate });
      showSlatePreview();
      const visibleSeconds = computeSlateVisibleSeconds(rotationSeconds);
      if (visibleSeconds <= 0) {
        scheduleSlatePreviewNext(rotationSeconds);
        return;
      }
      slatePreviewDisplayTimer = setTimeout(() => {
        slatePreviewDisplayTimer = null;
        stopSlatePreviewClock();
        hideSlatePreview();
        scheduleSlatePreviewNext(rotationSeconds);
      }, visibleSeconds * 1000);
    }

    function scheduleSlatePreviewNext(rotationSeconds = clampSlateRotation(slateState.rotationSeconds)) {
      if (!slateState.isEnabled || slatePreviewCards.length === 0) return;
      const gapMs = computeSlateGapMs(rotationSeconds);
      slatePreviewTimer = setTimeout(() => {
        slatePreviewTimer = null;
        if (!slateState.isEnabled || slatePreviewCards.length === 0) return;
        slatePreviewIndex = (slatePreviewIndex + 1) % slatePreviewCards.length;
        playSlatePreviewCard(slatePreviewIndex, { animate: true, updateDots: true });
      }, gapMs > 0 ? gapMs : 1000);
    }

    function updateSlatePreview() {
      if (!el.slatePreview) return;
      clearSlatePreviewTimers();
      destroySlatePreviewAnimator();
      slatePreviewCards = deriveSlateCardsForPreview(slateState, overlayPrefs);
      if (!slateState.isEnabled) {
        el.slatePreview.classList.add('is-disabled', 'is-empty');
        if (el.slatePreviewPill) el.slatePreviewPill.textContent = 'Slate disabled';
        if (el.slatePreviewTitle) el.slatePreviewTitle.textContent = 'Enable the segment slate to show rotating cards.';
        if (el.slatePreviewSubtitle) {
          el.slatePreviewSubtitle.textContent = 'Use the toggles above to reactivate the slate.';
          el.slatePreviewSubtitle.classList.remove('is-hidden');
        }
        if (el.slatePreviewMeta) {
          el.slatePreviewMeta.textContent = '';
          el.slatePreviewMeta.classList.add('is-hidden');
        }
        renderSlatePreviewDots();
        showSlatePreview();
        return;
      }
      el.slatePreview.classList.remove('is-disabled');
      if (!slatePreviewCards.length) {
        el.slatePreview.classList.add('is-empty');
        if (el.slatePreviewPill) el.slatePreviewPill.textContent = 'Segment slate';
        if (el.slatePreviewTitle) el.slatePreviewTitle.textContent = 'Add headline, sponsor, or spotlight notes to preview cards.';
        if (el.slatePreviewSubtitle) {
          el.slatePreviewSubtitle.textContent = 'Clock and highlight cards appear automatically when enabled.';
          el.slatePreviewSubtitle.classList.remove('is-hidden');
        }
        if (el.slatePreviewMeta) {
          el.slatePreviewMeta.textContent = 'Rotation preview';
          el.slatePreviewMeta.classList.remove('is-hidden');
        }
        renderSlatePreviewDots();
        showSlatePreview();
        return;
      }
      el.slatePreview.classList.remove('is-empty');
      if (slatePreviewIndex >= slatePreviewCards.length) {
        slatePreviewIndex = 0;
      }
      playSlatePreviewCard(slatePreviewIndex, { animate: false, updateDots: true });
    }

    function renderSlateControls() {
    if (el.slateEnabled) el.slateEnabled.checked = !!slateState.isEnabled;
    if (el.slateShowClock) el.slateShowClock.checked = !!slateState.showClock;
      const rotation = clampSlateRotation(slateState.rotationSeconds);
    if (el.slateRotation) el.slateRotation.value = rotation;
    if (el.slateRotationNumber) el.slateRotationNumber.value = rotation;
    if (el.slateClockLabel) el.slateClockLabel.value = slateState.clockLabel || '';
    if (el.slateClockSubtitle) el.slateClockSubtitle.value = slateState.clockSubtitle || '';
    if (el.slateNextLabel) el.slateNextLabel.value = slateState.nextLabel || '';
    if (el.slateNextTitle) el.slateNextTitle.value = slateState.nextTitle || '';
    if (el.slateNextSubtitle) el.slateNextSubtitle.value = slateState.nextSubtitle || '';
    if (el.slateSponsorLabel) el.slateSponsorLabel.value = slateState.sponsorLabel || '';
    if (el.slateSponsorName) el.slateSponsorName.value = slateState.sponsorName || '';
    if (el.slateSponsorTagline) el.slateSponsorTagline.value = slateState.sponsorTagline || '';
    if (el.slateNotesLabel) el.slateNotesLabel.value = slateState.notesLabel || '';
    if (el.slateNotes) el.slateNotes.value = Array.isArray(slateState.notes) ? slateState.notes.join('\n') : '';
      updateSlatePreview();
      updatePanelBusyStates();
    }

    function applySlatePatch(patch, { skipUpdatedAt = false } = {}) {
      if (!patch || typeof patch !== 'object') return false;
      let changed = false;
      for (const [key, value] of Object.entries(patch)) {
        if (slateState[key] === value) continue;
        slateState[key] = value;
        changed = true;
      }
      if (changed && !skipUpdatedAt) {
        slateState.updatedAt = Date.now();
      }
      return changed;
    }

    function updateSlateBoolean(key, value) {
      const next = !!value;
      if (!applySlatePatch({ [key]: next })) return;
      slateHasPendingLocalChanges = true;
      updateSlatePreview();
      queueSlateSave();
    }

    function updateSlateRotationInput(value) {
      const clamped = clampSlateRotation(value);
    if (el.slateRotation && Number(el.slateRotation.value) !== clamped) {
        el.slateRotation.value = clamped;
      }
    if (el.slateRotationNumber && Number(el.slateRotationNumber.value) !== clamped) {
        el.slateRotationNumber.value = clamped;
      }
      if (!applySlatePatch({ rotationSeconds: clamped })) return;
      slateHasPendingLocalChanges = true;
      updateSlatePreview();
      queueSlateSave();
    }

    function updateSlateTextField(key, rawValue, limit) {
      const trimmed = sanitiseTextInput(rawValue, {
        maxLength: limit,
        fallback: ''
      });
      if (!applySlatePatch({ [key]: trimmed })) {
        return trimmed;
      }
      slateHasPendingLocalChanges = true;
      updateSlatePreview();
      queueSlateSave();
      return trimmed;
    }

    function updateSlateNotes(rawValue) {
      const notes = normaliseSlateNotesListFn(rawValue);
      const previous = Array.isArray(slateState.notes) ? slateState.notes : [];
      const changed = notes.length !== previous.length || notes.some((note, index) => note !== previous[index]);
      if (!changed) return notes;
      applySlatePatch({ notes });
      slateHasPendingLocalChanges = true;
      updateSlatePreview();
      queueSlateSave();
      return notes;
    }

    function normaliseBrbData(data) {
      const raw = data && typeof data.text === 'string' ? data.text : '';
      const text = raw.trim().slice(0, MAX_BRB_LENGTH);
      const isActive = !!(data && data.isActive) && !!text;
      const updatedAtSource = data && data._updatedAt != null ? data._updatedAt : data && data.updatedAt;
      const updatedAtRaw = Number(updatedAtSource);
      return {
        text,
        isActive,
        updatedAt: Number.isFinite(updatedAtRaw) ? updatedAtRaw : null
      };
    }

    function updateHighlightRegex() {
      const custom = (overlayPrefs.highlight || '')
        .split(',')
        .map(s => s.trim())
        .filter(Boolean);
      const merged = Array.from(new Set([...DEFAULT_HIGHLIGHTS, ...custom]));
      const tokens = merged
        .map(entry => entry.trim())
        .filter(Boolean)
        .sort((a, b) => b.length - a.length);
      if (!tokens.length) {
        highlightRegex = null;
        return;
      }
      const escaped = tokens
        .map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
        .join('|');
      const boundaryClass = '[\\p{L}\\p{N}_]';
      highlightRegex = escaped
        ? new RegExp(`(?<!${boundaryClass})(${escaped})(?!${boundaryClass})`, 'giu')
        : null;
    }

    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, match => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      })[match]);
    }

    function applyEmphasis(html) {
      return html
        .replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>')
        .replace(/(^|[^*])\*([^*]+?)\*(?!\*)/g, (match, prefix, inner) => `${prefix}<em>${inner}</em>`);
    }

    function applyHighlights(html) {
      if (!highlightRegex) return html;
      return html.replace(highlightRegex, '<span class="highlight">$1</span>');
    }

    function buildLetters(text) {
      let index = 0;
      let result = '';
      for (const char of text) {
        if (/\s/.test(char)) {
          result += escapeHtml(char);
        } else {
          result += `<span class="fx-letter" style="--i:${index++}">${escapeHtml(char)}</span>`;
        }
      }
      return result;
    }

    function renderSegment(type, text) {
      const clean = escapeHtml(text);
      switch (type) {
        case 'rainbow':
          return `<span class="fx fx-rainbow">${buildLetters(text)}</span>`;
        case 'sparkle':
          return `<span class="fx fx-sparkle">${buildLetters(text)}</span>`;
        case 'bounce':
          return `<span class="fx fx-bounce">${clean}</span>`;
        case 'neon':
          return `<span class="fx fx-neon">${clean}</span>`;
        case 'glitch':
          return `<span class="fx fx-glitch" data-text="${clean}">${clean}</span>`;
        default: {
          const emphasised = applyEmphasis(clean);
          return applyHighlights(emphasised);
        }
      }
    }

    function formatMessage(raw) {
      const str = String(raw || '').trim();
      if (!str) return '';
      const segments = [];
      const regex = /(%%|~~|\^\^|==|!!)([\s\S]+?)\1/g;
      let lastIndex = 0;
      let match;
      while ((match = regex.exec(str))) {
        if (match.index > lastIndex) {
          segments.push({ type: 'text', text: str.slice(lastIndex, match.index) });
        }
        const mapped = SPECIAL_MAP[match[1]] || 'text';
        segments.push({ type: mapped, text: match[2] });
        lastIndex = match.index + match[0].length;
      }
      if (lastIndex < str.length) {
        segments.push({ type: 'text', text: str.slice(lastIndex) });
      }
      return segments.map(seg => renderSegment(seg.type, seg.text)).join('');
    }

    function registerTextAnimationPlugins() {
      if (typeof window === 'undefined' || typeof gsap === 'undefined' || typeof SplitText === 'undefined') {
        return false;
      }
      if (!registerTextAnimationPlugins._registered) {
        const plugins = [SplitText];
        if (typeof ScrambleTextPlugin !== 'undefined') {
          plugins.push(ScrambleTextPlugin);
        }
        if (plugins.length) {
          gsap.registerPlugin(...plugins);
        }
        registerTextAnimationPlugins._registered = true;
      }
      return true;
    }

    function createTextAnimator(headerEl, bodyEls = []) {
      if (!headerEl) return null;
      if (!registerTextAnimationPlugins()) return null;
      const groups = Array.isArray(bodyEls) ? bodyEls : [bodyEls];
      const activeBodies = groups.filter(el => el && typeof el.textContent === 'string' && el.textContent.trim().length);
      let headerSplit;
      let bodySplit;
      try {
        headerSplit = SplitText.create(headerEl, { type: 'chars', mask: 'chars' });
        if (activeBodies.length) {
          bodySplit = SplitText.create(activeBodies, { type: 'lines', mask: 'lines' });
        }
      } catch (err) {
        console.warn('[dashboard] text animation setup failed', err);
        return null;
      }

      const headerChars = Array.isArray(headerSplit && headerSplit.chars) ? headerSplit.chars : [];
      const bodyLines = Array.isArray(bodySplit && bodySplit.lines) ? bodySplit.lines : [];
      const timeline = gsap.timeline({ paused: true });
      const scrambleConfig = typeof ScrambleTextPlugin !== 'undefined' ? { text: '#', speed: 0.15 } : null;

      timeline.from(headerChars, {
        filter: 'blur(6px)',
        y: '-15%',
        opacity: 0,
        scale: 0.95,
        duration: 1.2,
        ease: 'power2.out',
        ...(scrambleConfig ? { scrambleText: scrambleConfig } : {}),
        stagger: { each: 0.3, from: 'left' }
      });

      if (bodyLines.length) {
        timeline.from(bodyLines, {
          filter: 'blur(10px)',
          delay: 0.55,
          opacity: 0,
          scale: 0.95,
          y: '100%',
          duration: 0.55,
          ease: 'power1.out'
        }, '-=0.9');
      }

      timeline.to(headerChars, {
        opacity: 1,
        y: '0%',
        duration: 0.2
      });

      const playIn = () => new Promise(resolve => {
        timeline.eventCallback('onComplete', () => {
          timeline.eventCallback('onComplete', null);
          resolve();
        });
        timeline.play(0);
      });

      const playOut = () => new Promise(resolve => {
        const outTimeline = gsap.timeline({
          defaults: { ease: 'power2.in', duration: 0.45 },
          onComplete: resolve
        });
        outTimeline.to(headerChars, {
          filter: 'blur(6px)',
          y: '-15%',
          opacity: 0,
          scale: 0.95,
          stagger: { each: 0.12, from: 'right' }
        });
        if (bodyLines.length) {
          outTimeline.to(bodyLines, {
            filter: 'blur(10px)',
            opacity: 0,
            y: '100%',
            duration: 0.4
          }, '<');
        }
      });

      const revert = () => {
        try {
          if (bodySplit && typeof bodySplit.revert === 'function') {
            bodySplit.revert();
          }
          if (headerSplit && typeof headerSplit.revert === 'function') {
            headerSplit.revert();
          }
        } catch (err) {
          console.warn('[dashboard] text animation revert failed', err);
        }
      };

      return {
        playIn() {
          return playIn();
        },
        playOut() {
          timeline.pause(0);
          timeline.kill();
          return playOut().finally(() => {
            revert();
          });
        },
        kill() {
          timeline.kill();
          revert();
        }
      };
    }

    function setPreviewLoading(loading, options = {}) {
      if (!el.previewFrame) return;
      const container = el.previewFrameContainer || el.previewFrame.parentElement;
      if (!container) return;
      const { timeoutMs = 9000, onTimeout } = options;

      if (loading) {
        if (uiState.previewLoadingTimer) {
          clearTimeout(uiState.previewLoadingTimer);
          uiState.previewLoadingTimer = null;
        }
        uiState.previewLoading = true;
        container.classList.add('is-loading');
        el.previewFrame.setAttribute('aria-busy', 'true');
        if (Number.isFinite(timeoutMs) && timeoutMs > 0) {
          uiState.previewLoadingTimer = setTimeout(() => {
            uiState.previewLoadingTimer = null;
            uiState.previewLoading = false;
            container.classList.remove('is-loading');
            el.previewFrame.removeAttribute('aria-busy');
            if (typeof onTimeout === 'function') {
              try {
                onTimeout();
              } catch (err) {
                console.warn('Preview timeout handler failed', err);
              }
            }
          }, timeoutMs);
        }
      } else {
        if (uiState.previewLoadingTimer) {
          clearTimeout(uiState.previewLoadingTimer);
          uiState.previewLoadingTimer = null;
        }
        if (uiState.previewLoading) {
          container.classList.remove('is-loading');
          el.previewFrame.removeAttribute('aria-busy');
        }
        uiState.previewLoading = false;
      }
    }

    function updateOverlayChip() {
      const url = buildOverlayUrl();
      if (!url) return;
      safeSetText(el.overlayText, url);
      safeSetDataset(el.overlayText, 'url', url);
      if (url !== uiState.lastPreviewUrl) {
        uiState.lastPreviewUrl = url;
        schedulePreviewUpdate(url);
      }
    }

    function buildOverlayUrl() {
      const origin = typeof location === 'object' && location ? location.origin || '' : '';
      const pathname = typeof location === 'object' && location ? location.pathname || '' : '';
      const normalisedPath = pathname ? pathname.replace(/index\.html$/, '') : '';
      const basePath = `${origin || ''}${normalisedPath}output.html` || 'output.html';
      const params = new URLSearchParams();
      params.set('server', serverBase());
      params.set('label', overlayPrefs.label || 'LIVE');
      if (overlayPrefs.accent && isSafeColour(overlayPrefs.accent)) params.set('accent', overlayPrefs.accent);
      if (overlayPrefs.accentSecondary && isSafeColour(overlayPrefs.accentSecondary)) {
        params.set('accentSecondary', overlayPrefs.accentSecondary);
      }
      const highlights = (overlayPrefs.highlight || '')
        .split(',')
        .map(s => s.trim())
        .filter(Boolean)
        .join(',');
      if (highlights) params.set('hl', highlights);
      params.set('scale', String(overlayPrefs.scale));
      params.set('popupScale', String(overlayPrefs.popupScale));
      params.set('position', overlayPrefs.position);
      params.set('mode', overlayPrefs.mode);
      params.set('theme', overlayPrefs.theme);
      if (!overlayPrefs.accentAnim) params.set('accentAnim', '0');
      if (!overlayPrefs.sparkle) params.set('sparkle', '0');
      return `${basePath}?${params.toString()}`;
    }

    function saveLocal() {
      const storage = getLocalStorage();
      if (!storage) return;
      const payload = {
        overlay: overlayPrefs,
        autoStart: el.autoStart ? !!el.autoStart.checked : false,
        serverUrl: el.serverUrl ? el.serverUrl.value : '',
        panel: activePanelId
      };
      try {
        storage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (err) {
        console.warn('Failed to save local preferences', err);
      }
    }

    function loadLocal() {
      const storage = getLocalStorage();
      if (!storage) return;
      try {
        const raw = storage.getItem(STORAGE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (parsed.overlay) {
          const nextOverlay = typeof normaliseOverlayDataFn === 'function'
            ? normaliseOverlayDataFn({ ...overlayPrefs, ...parsed.overlay })
            : { ...overlayPrefs, ...parsed.overlay };
          Object.keys(overlayPrefs).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(nextOverlay, key)) {
              delete overlayPrefs[key];
            }
          });
          Object.assign(overlayPrefs, nextOverlay);
        }
        if (typeof parsed.autoStart === 'boolean' && el.autoStart) {
          el.autoStart.checked = parsed.autoStart;
        }
        if (typeof parsed.serverUrl === 'string') {
          const storedServerUrl = parsed.serverUrl;
          const cleanedServerUrl = sanitiseServerUrlInput(storedServerUrl);
          if (el.serverUrl) {
            el.serverUrl.value = cleanedServerUrl || '';
          }
          if (cleanedServerUrl !== storedServerUrl) {
            saveLocal();
          }
        }
        if (typeof parsed.panel === 'string') setActivePanel(parsed.panel, { skipSave: true });
      } catch (err) {
        console.warn('Failed to read local preferences', err);
      }
    }

    function clearEditing() {
      uiState.editingIndex = -1;
      uiState.editingDraft = '';
    }

    function clampDuration(value, fallback = state.displayDuration) {
      if (typeof clampDurationSeconds === 'function') {
        return clampDurationSeconds(value, fallback);
      }
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return fallback;
      return Math.min(Math.max(Math.round(numeric), 2), 90);
    }

    function clampMinutesValue(value, fallback = state.intervalMinutes) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return fallback;
      if (typeof clampIntervalSeconds === 'function') {
        const seconds = clampIntervalSeconds(minutesToSeconds(numeric), minutesToSeconds(fallback));
        return secondsToMinutes(seconds);
      }
      return Math.max(0, Math.min(60, Math.round(numeric * 100) / 100));
    }

    function formatMinutesValue(value) {
      const numeric = clampMinutesValue(value);
      if (numeric === 0) return '0';
      const fixed = numeric.toFixed(2);
      return fixed.replace(/(\.\d*?[1-9])0+$/, '$1').replace(/\.0+$/, '');
    }

    function formatDurationSeconds(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric) || numeric <= 0) return '';
      const seconds = Math.max(1, Math.min(MAX_POPUP_SECONDS, Math.round(numeric)));
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      const remainder = seconds % 60;
      return remainder ? `${minutes}m ${remainder}s` : `${minutes}m`;
    }

    function parseCountdownTarget(value) {
      if (value === null || value === undefined) return null;
      const raw = String(value).trim();
      if (!raw) return null;
      const numeric = Number(raw);
      if (Number.isFinite(numeric) && numeric > 0) {
        return Math.round(numeric);
      }
      const parsed = new Date(raw);
      const ms = parsed.getTime();
      return Number.isNaN(ms) ? null : ms;
    }

    function formatCountdownLabel(targetMs) {
      const numeric = Number(targetMs);
      if (!Number.isFinite(numeric)) return '';
      const diff = Math.round(numeric - Date.now());
      if (diff <= 0) return 'now';
      const seconds = Math.floor(diff / 1000);
      if (seconds >= 60) {
        const minutes = Math.floor(seconds / 60);
        return `${minutes} min${minutes === 1 ? '' : 's'}`;
      }
      const clampedSeconds = Math.max(1, seconds);
      return `${clampedSeconds}s`;
    }

    function formatDatetimeLocal(timestamp) {
      const numeric = Number(timestamp);
      if (!Number.isFinite(numeric)) return '';
      const date = new Date(numeric);
      if (Number.isNaN(date.getTime())) return '';
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      return `${year}-${month}-${day}T${hours}:${minutes}`;
    }

    function schedulePreviewUpdate(url) {
      const frame = el.previewFrame;
      if (!frame) {
        return;
      }
      const nextUrl = typeof url === 'string' ? url : '';
      if (!nextUrl) {
        setPreviewLoading(false);
        return;
      }
      setPreviewLoading(true, {
        timeoutMs: 12000,
        onTimeout: () => {
          toast('Preview is taking longer than expected. Check the overlay URL.');
        }
      });

      if (uiState.previewUpdateTimer) clearTimeout(uiState.previewUpdateTimer);
      uiState.previewUpdateTimer = setTimeout(() => {
        uiState.previewUpdateTimer = null;
        try {
          if (frame.src !== nextUrl) {
            frame.src = nextUrl;
          } else if (frame.contentWindow && typeof frame.contentWindow.location.replace === 'function') {
            frame.contentWindow.location.replace(nextUrl);
          } else if (frame.contentWindow && frame.contentWindow.location) {
            frame.contentWindow.location.href = nextUrl;
          }
        } catch (err) {
          // Ignore navigation errors (cross-origin etc.) and fall back silently.
        }
      }, 180);
    }

    function renderTicker() {
      safeSetValue(el.duration, state.displayDuration);
      safeSetValue(el.interval, formatMinutesValue(state.intervalMinutes));
      if (el.statusActive && el.statusActive.classList) {
        el.statusActive.classList.toggle('active', !!state.isActive);
      }
      const activeLabel = state.isActive ? 'Active' : 'Inactive';
      safeSetText(el.statusActiveText, activeLabel);
      if (el.statusActiveText && el.statusActiveText.classList) {
        el.statusActiveText.classList.toggle('is-active', !!state.isActive);
        el.statusActiveText.classList.toggle('is-inactive', !state.isActive);
      }
      const count = state.messages.length;
      const queueFull = count >= MAX_MESSAGES;
      safeSetText(el.statusCount, `${count}/${MAX_MESSAGES}`);
      if (el.statusCount && el.statusCount.classList) {
        el.statusCount.classList.toggle('is-full', queueFull);
      }
      const updatedLabel = state.updatedAt ? new Date(state.updatedAt).toLocaleTimeString() : '–';
      safeSetText(el.statusUpdated, updatedLabel);
      updateQueueControls(queueFull);
    }

    function updateQueueControls(queueFull = state.messages.length >= MAX_MESSAGES) {
      if (el.newMessage) {
        el.newMessage.disabled = queueFull;
        el.newMessage.placeholder = queueFull
          ? `Queue full — max ${MAX_MESSAGES} messages`
          : MESSAGE_PLACEHOLDER;
      }
      if (el.addMessageButton) {
        el.addMessageButton.disabled = queueFull;
      }
    }

    function updateAccentInputsFromPrefs() {
      const accent = overlayPrefs.accent || '';
      safeSetValue(el.overlayAccent, accent);
      if (el.overlayAccentPicker) {
        el.overlayAccentPicker.value = parseHexForPicker(accent) || ACCENT_FALLBACK_HEX;
      }
      const secondary = overlayPrefs.accentSecondary || '';
      safeSetValue(el.overlayAccentSecondary, secondary);
      if (el.overlayAccentSecondaryPicker) {
        el.overlayAccentSecondaryPicker.value = parseHexForPicker(secondary) || ACCENT_SECONDARY_FALLBACK_HEX;
      }
    }

    function setAccentError(message) {
      const hasError = Boolean(message);
    if (el.overlayAccentGroup) {
        el.overlayAccentGroup.classList.toggle('has-error', hasError);
      }
    if (el.overlayAccentHint) {
        el.overlayAccentHint.textContent = hasError ? message : ACCENT_HINT_DEFAULT;
        el.overlayAccentHint.classList.toggle('is-error', hasError);
      }
    }

    function setAccentSecondaryError(message) {
      const hasError = Boolean(message);
    if (el.overlayAccentSecondaryGroup) {
        el.overlayAccentSecondaryGroup.classList.toggle('has-error', hasError);
      }
    if (el.overlayAccentSecondaryHint) {
        el.overlayAccentSecondaryHint.textContent = hasError ? message : ACCENT_SECONDARY_HINT_DEFAULT;
        el.overlayAccentSecondaryHint.classList.toggle('is-error', hasError);
      }
    }

    function updateHighlightHint(value) {
      if (!el.highlightWordsHint) return;
      const raw = typeof value === 'string'
        ? value
        : (el.highlightWords ? el.highlightWords.value : '');
      const remaining = Math.max(0, MAX_HIGHLIGHT_LENGTH - raw.length);
      const message = remaining === 0
        ? `Highlight words can be up to ${MAX_HIGHLIGHT_LENGTH} characters. Limit reached.`
        : `Highlight words can be up to ${MAX_HIGHLIGHT_LENGTH} characters. ${remaining} characters remaining.`;
      el.highlightWordsHint.textContent = message;
      el.highlightWordsHint.classList.toggle('is-warning', remaining <= HIGHLIGHT_WARNING_THRESHOLD);
    }

    function applyPreviewTheme() {
      if (!el.popupPreview) return;
      const theme = overlayPrefs.theme && THEME_OPTIONS.includes(overlayPrefs.theme)
        ? overlayPrefs.theme
        : THEME_OPTIONS[0];
      const body = typeof document !== 'undefined' ? document.body : null;
      el.popupPreview.classList.remove(...THEME_CLASSNAMES);
      if (body) {
        body.classList.remove(...THEME_CLASSNAMES);
      }
      if (theme) {
        const className = `ticker--${theme}`;
        el.popupPreview.classList.add(className);
        if (body) {
          body.classList.add(className);
          body.dataset.previewTheme = theme;
        }
      } else if (body && body.dataset && body.dataset.previewTheme) {
        delete body.dataset.previewTheme;
      }
      const defaultAccent = isSafeColour(DEFAULT_ACCENT) ? DEFAULT_ACCENT : '#38bdf8';
      const defaultAccentSecondary = isSafeColour(DEFAULT_ACCENT_SECONDARY)
        ? DEFAULT_ACCENT_SECONDARY
        : defaultAccent;
      const previewAccent = overlayPrefs.accent && isSafeColour(overlayPrefs.accent)
        ? overlayPrefs.accent.trim()
        : defaultAccent;
      const previewAccentSecondary = overlayPrefs.accentSecondary && isSafeColour(overlayPrefs.accentSecondary)
        ? overlayPrefs.accentSecondary.trim()
        : (overlayPrefs.accent && isSafeColour(overlayPrefs.accent)
            ? overlayPrefs.accent.trim()
            : defaultAccentSecondary);
      el.popupPreview.style.setProperty('--preview-accent', previewAccent);
      el.popupPreview.style.setProperty('--preview-accent-secondary', previewAccentSecondary);
      el.popupPreview.style.setProperty('--overlay-accent', previewAccent);
      el.popupPreview.style.setProperty('--overlay-accent-secondary', previewAccentSecondary);
      if (typeof document !== 'undefined' && document.documentElement) {
        document.documentElement.style.setProperty('--overlay-accent', previewAccent);
        document.documentElement.style.setProperty('--overlay-accent-secondary', previewAccentSecondary);
      }
    }

    function renderOverlayControls() {
      el.overlayLabel.value = overlayPrefs.label;
      updateAccentInputsFromPrefs();
      setAccentError('');
      setAccentSecondaryError('');
      el.highlightWords.value = overlayPrefs.highlight;
      updateHighlightHint(overlayPrefs.highlight);
      el.scaleRange.value = overlayPrefs.scale;
      el.scaleNumber.value = overlayPrefs.scale;
    if (el.popupScaleRange) el.popupScaleRange.value = overlayPrefs.popupScale;
    if (el.popupScaleNumber) el.popupScaleNumber.value = overlayPrefs.popupScale;
      el.accentAnim.checked = overlayPrefs.accentAnim;
      el.sparkle.checked = overlayPrefs.sparkle;
      updateSegmentSelection(el.positionButtons, 'position', overlayPrefs.position);
      updateSegmentSelection(el.modeButtons, 'mode', overlayPrefs.mode);
      updateSegmentSelection(el.themeButtons, 'theme', overlayPrefs.theme);
      applyPreviewTheme();
      renderPopupPreviewScale();
      updatePanelBusyStates();
    }

    function renderMessages() {
      if (uiState.editingIndex >= state.messages.length) clearEditing();
      if (!state.messages.length) {
        clearEditing();
        el.messageList.innerHTML = '<div class="empty-state">No messages yet — add a line above or load a preset.</div>';
        return;
      }
      const rows = state.messages.map((msg, index) => {
        if (index === uiState.editingIndex) {
          const editorValue = uiState.editingDraft;
          const preview = formatMessage(editorValue);
          const previewHtml = preview || '<span class="small">Preview updates as you type.</span>';
          return `<div class="message-item is-editing" data-index="${index}">
            <div class="message-editor">
              <textarea class="message-edit-input" data-role="editor">${escapeHtml(editorValue)}</textarea>
              <div class="message-preview">${previewHtml}</div>
            </div>
            <div class="message-actions">
              <button type="button" data-action="save">Save</button>
              <button type="button" data-action="cancel">Cancel</button>
            </div>
          </div>`;
        }
        const formatted = formatMessage(msg);
        return `<div class="message-item" data-index="${index}">
          <div class="message-preview">${formatted}</div>
          <div class="message-actions">
            <button type="button" data-action="edit" title="Edit">Edit</button>
            <button type="button" data-action="save-preset" title="Save to presets">Save preset</button>
            <button type="button" data-action="up" title="Move up">↑</button>
            <button type="button" data-action="down" title="Move down">↓</button>
            <button type="button" data-action="delete" title="Remove">Delete</button>
          </div>
        </div>`;
      }).join('');
      el.messageList.innerHTML = rows;
      updateQueueControls();
    }

    function formatPresetMeta(preset) {
      const date = new Date(preset.updatedAt);
      const count = Array.isArray(preset.messages) ? preset.messages.length : 0;
      const parts = [];
      parts.push(count === 1 ? 'Single message' : `${count} messages`);
      parts.push(date.toLocaleString());
      return parts.join(' • ');
    }

    function renderPresets() {
      if (!presets.length) {
        el.presetList.innerHTML = '<div class="empty-state">No presets saved yet.</div>';
        return;
      }
      const cards = presets.map(preset => {
        return `<div class="preset-card" data-id="${preset.id}">
          <div>
            <div class="preset-title">${escapeHtml(preset.name)}</div>
            <div class="preset-meta">${formatPresetMeta(preset)}</div>
          </div>
          <div class="preset-actions">
            <button type="button" data-action="load">Load</button>
            <button type="button" data-action="append">Append</button>
            <button type="button" data-action="delete">Delete</button>
          </div>
          <div class="preset-hint">Ticker stays idle unless Auto-start is enabled or you press Start.</div>
        </div>`;
      }).join('');
      el.presetList.innerHTML = cards;
    }

    function formatSceneMeta(scene) {
      const parts = [];
      const tickerMessages = scene && scene.ticker && Array.isArray(scene.ticker.messages)
        ? scene.ticker.messages
        : [];
      const messageCount = tickerMessages.length;
      parts.push(`${messageCount} message${messageCount === 1 ? '' : 's'}`);
      const tickerDisplayDuration = scene && scene.ticker && typeof scene.ticker.displayDuration === 'number'
        ? scene.ticker.displayDuration
        : null;
      if (tickerDisplayDuration !== null) {
        parts.push(`${tickerDisplayDuration}s on`);
      }
      const tickerInterval = scene && scene.ticker && typeof scene.ticker.intervalBetween === 'number'
        ? scene.ticker.intervalBetween
        : null;
      if (tickerInterval !== null) {
        const minutes = secondsToMinutes(tickerInterval);
        parts.push(minutes ? `${formatMinutesValue(minutes)}m interval` : 'loop');
      }
      const popupText = scene && scene.popup && scene.popup.text ? scene.popup.text : '';
      if (popupText) {
        const popupActive = scene && scene.popup && scene.popup.isActive;
        parts.push(popupActive ? 'popup active' : 'popup ready');
      }
      if (scene && scene.overlay) {
        const overlayLabel = typeof scene.overlay.label === 'string'
          ? scene.overlay.label.trim()
          : '';
        if (overlayLabel) {
          parts.push(`label: ${overlayLabel}`);
        }
        if (scene.overlay.theme) {
          parts.push(`theme: ${scene.overlay.theme}`);
        }
        if (typeof scene.overlay.scale === 'number' && Number.isFinite(scene.overlay.scale)
          && scene.overlay.scale !== DEFAULT_OVERLAY.scale) {
          parts.push(`scale ${scene.overlay.scale}×`);
        }
        if (typeof scene.overlay.popupScale === 'number' && Number.isFinite(scene.overlay.popupScale)
          && scene.overlay.popupScale !== DEFAULT_OVERLAY.popupScale) {
          parts.push(`popup ${scene.overlay.popupScale}×`);
        }
        if (scene.overlay.mode && scene.overlay.mode !== DEFAULT_OVERLAY.mode) {
          parts.push(`mode: ${scene.overlay.mode}`);
        }
        if (scene.overlay.position && scene.overlay.position !== DEFAULT_OVERLAY.position) {
          parts.push(`${scene.overlay.position} overlay`);
        }
      }
      if (scene && scene.slate) {
        if (scene.slate.isEnabled) {
          parts.push('slate on');
          if (scene.slate.nextTitle) {
            const nextSummary = scene.slate.nextTitle.length > 32
              ? `${scene.slate.nextTitle.slice(0, 32)}…`
              : scene.slate.nextTitle;
            parts.push(`next: ${nextSummary}`);
          } else if (scene.slate.showClock) {
            parts.push('clock card');
          }
          if (scene.slate.sponsorName) {
            const sponsorSummary = scene.slate.sponsorName.length > 28
              ? `${scene.slate.sponsorName.slice(0, 28)}…`
              : scene.slate.sponsorName;
            parts.push(`sponsor: ${sponsorSummary}`);
          }
        } else {
          parts.push('slate off');
        }
      }
      const updatedAt = Number(scene && scene.updatedAt);
      if (Number.isFinite(updatedAt)) {
        parts.push(new Date(updatedAt).toLocaleString());
      }
      return parts.join(' • ');
    }

    function renderScenes() {
      if (!scenes.length) {
        el.sceneList.innerHTML = '<div class="empty-state">No scenes saved yet.</div>';
        return;
      }
      const cards = scenes.map(scene => {
        return `<div class="scene-card" data-id="${scene.id}">
          <div>
            <div class="scene-title">${escapeHtml(scene.name)}</div>
            <div class="scene-meta">${escapeHtml(formatSceneMeta(scene))}</div>
          </div>
          <div class="scene-actions">
            <button type="button" data-action="activate">Activate</button>
            <button type="button" data-action="replace">Replace</button>
            <button type="button" data-action="delete">Delete</button>
          </div>
        </div>`;
      }).join('');
      el.sceneList.innerHTML = cards;
    }

    function stopPopupPreviewCountdown() {
      if (popupPreviewCountdownTimer) {
        clearInterval(popupPreviewCountdownTimer);
        popupPreviewCountdownTimer = null;
      }
    }

    function refreshPopupPreviewCountdown() {
      if (!el.popupPreview) return true;
      const countdownEl = el.popupPreview.querySelector('[data-popup-countdown]');
      if (!countdownEl) return true;
      if (!Number.isFinite(popupPreviewCountdownTarget)) {
        countdownEl.textContent = '';
        return true;
      }
      const label = formatCountdownLabel(popupPreviewCountdownTarget);
      countdownEl.textContent = label;
      return label === 'now';
    }

    function startPopupPreviewCountdown() {
      stopPopupPreviewCountdown();
      if (!Number.isFinite(popupPreviewCountdownTarget)) return;
      const finished = refreshPopupPreviewCountdown();
      if (popupState.countdownEnabled) {
        updatePopupMeta();
      }
      if (finished) return;
      popupPreviewCountdownTimer = setInterval(() => {
        const done = refreshPopupPreviewCountdown();
        if (popupState.countdownEnabled) {
          updatePopupMeta();
        }
        if (done) {
          stopPopupPreviewCountdown();
          if (popupState.countdownEnabled) {
            updatePopupMeta();
          }
        }
      }, 1000);
    }

    function destroyPopupPreviewAnimator() {
      if (popupPreviewAnimator && typeof popupPreviewAnimator.kill === 'function') {
        try {
          popupPreviewAnimator.kill();
        } catch (err) {
          console.warn('[dashboard] popup preview animation cleanup failed', err);
        }
      }
      popupPreviewAnimator = null;
    }

    function destroySlatePreviewAnimator() {
      if (slatePreviewAnimator && typeof slatePreviewAnimator.kill === 'function') {
        try {
          slatePreviewAnimator.kill();
        } catch (err) {
          console.warn('[dashboard] slate preview animation cleanup failed', err);
        }
      }
      slatePreviewAnimator = null;
    }

    function updatePopupPreview() {
      if (!el.popupPreview) return;
      destroyPopupPreviewAnimator();
      stopPopupPreviewCountdown();
      popupPreviewCountdownTarget = null;
      const raw = el.popupText ? el.popupText.value : '';
      const text = raw.trim().slice(0, MAX_POPUP_LENGTH);
      if (el.popupText && raw !== text) {
        el.popupText.value = text;
      }
      const previous = popupPreviewLastText;
      let messageNode = null;
      let shouldAnimate = false;
      if (text) {
        el.popupPreview.innerHTML = '';
        el.popupPreview.classList.remove('is-empty');
        messageNode = document.createElement('div');
        messageNode.className = 'popup-preview-message';
        messageNode.innerHTML = formatMessage(text);
        el.popupPreview.appendChild(messageNode);
        shouldAnimate = text !== previous;
        if (el.popupCountdownEnabled && el.popupCountdownEnabled.checked) {
          const target = el.popupCountdownTarget ? parseCountdownTarget(el.popupCountdownTarget.value) : null;
          if (Number.isFinite(target)) {
            popupPreviewCountdownTarget = target;
            const countdownChip = document.createElement('span');
            countdownChip.className = 'popup-countdown-chip';
            countdownChip.dataset.popupCountdown = 'true';
            el.popupPreview.appendChild(countdownChip);
            startPopupPreviewCountdown();
          }
        }
        popupPreviewLastText = text;
      } else {
        popupPreviewLastText = '';
        el.popupPreview.textContent = 'Popup preview';
        el.popupPreview.classList.add('is-empty');
        if (el.popupCountdownEnabled) {
          el.popupCountdownEnabled.checked = false;
        }
        if (el.popupCountdownTarget) {
          el.popupCountdownTarget.disabled = true;
        }
      }
    if (el.popupCountdownTarget && el.popupCountdownEnabled) {
        const countdownActive = el.popupCountdownEnabled.checked;
        el.popupCountdownTarget.disabled = popupSaveInFlight || !countdownActive;
      }
      if (shouldAnimate && messageNode) {
        const animator = createTextAnimator(messageNode);
        if (animator) {
          popupPreviewAnimator = animator;
          animator.playIn().catch(() => destroyPopupPreviewAnimator());
        }
      }
    }

    function updatePopupMeta() {
      if (!el.popupMeta) return;
      const status = popupState.isActive && popupState.text ? 'Popup live' : 'Popup hidden';
      const durationLabel = formatDurationSeconds(popupState.durationSeconds);
      const parts = [status];
      if (durationLabel) {
        parts.push(`Auto-hide ${durationLabel}`);
      }
      if (popupState.countdownEnabled && Number.isFinite(popupState.countdownTarget)) {
        parts.push(`Countdown ${formatCountdownLabel(popupState.countdownTarget)}`);
      }
      if (popupState.updatedAt) {
        parts.push(`Updated ${new Date(popupState.updatedAt).toLocaleTimeString()}`);
      }
      el.popupMeta.textContent = parts.join(' • ');
    }

    function renderPopupPreviewScale() {
      if (!el.popupPreview) return;
      el.popupPreview.style.setProperty('--popup-scale', String(overlayPrefs.popupScale));
      document.documentElement.style.setProperty('--popup-scale', String(overlayPrefs.popupScale));
    }

    function renderPopupControls() {
      if (!el.popupText) return;
      const isLive = popupState.isActive && !!popupState.text;
    if (el.popupPanel) el.popupPanel.classList.toggle('is-live', isLive);
    if (el.popupActiveLabel) el.popupActiveLabel.classList.toggle('is-live', isLive);
      el.popupText.value = popupState.text;
      el.popupActive.checked = isLive;
    if (el.popupDuration) {
        el.popupDuration.value = popupState.durationSeconds ? String(popupState.durationSeconds) : '';
      }
    if (el.popupCountdownEnabled) {
        const hasCountdown = popupState.countdownEnabled && Number.isFinite(popupState.countdownTarget);
        el.popupCountdownEnabled.checked = hasCountdown && !!popupState.text;
      }
    if (el.popupCountdownTarget) {
        el.popupCountdownTarget.value = popupState.countdownEnabled && Number.isFinite(popupState.countdownTarget)
          ? formatDatetimeLocal(popupState.countdownTarget)
          : '';
      }
      updatePopupPreview();
      updatePopupMeta();
      renderPopupPreviewScale();
      const disabled = popupSaveInFlight;
      el.popupText.disabled = disabled;
      el.popupActive.disabled = disabled;
    if (el.popupDuration) el.popupDuration.disabled = disabled;
    if (el.popupCountdownEnabled) el.popupCountdownEnabled.disabled = disabled;
      if (el.popupCountdownTarget) {
        const countdownEnabled = el.popupCountdownEnabled && el.popupCountdownEnabled.checked;
        el.popupCountdownTarget.disabled = disabled || !countdownEnabled;
      }
    if (el.savePopup) el.savePopup.disabled = disabled;
    if (el.clearPopup) el.clearPopup.disabled = disabled;
      updatePanelBusyStates();
    }

    function renderBrbControls() {
      const isLive = brbState.isActive && !!brbState.text;
    if (el.brbPanel) el.brbPanel.classList.toggle('is-live', isLive);
    if (el.brbActiveLabel) el.brbActiveLabel.classList.toggle('is-live', isLive);
    if (el.brbText) {
        el.brbText.value = brbState.text;
        el.brbText.disabled = brbSaveInFlight;
      }
    if (el.brbActive) {
        el.brbActive.checked = isLive;
        el.brbActive.disabled = brbSaveInFlight;
      }
    if (el.brbSave) el.brbSave.disabled = brbSaveInFlight;
    if (el.brbClear) el.brbClear.disabled = brbSaveInFlight;

    if (el.brbStatus) {
        const parts = [];
        parts.push(isLive ? 'BRB live' : 'BRB hidden');
        if (brbState.updatedAt) {
          parts.push(`Updated ${new Date(brbState.updatedAt).toLocaleTimeString()}`);
        }
        el.brbStatus.textContent = parts.join(' • ');
      }

      const brbActive = isLive;
    if (el.statusBrb) {
        el.statusBrb.textContent = brbActive ? 'Active' : 'Hidden';
      }
    if (el.statusBrbDot) {
        el.statusBrbDot.classList.toggle('active', brbActive);
      }
      updatePanelBusyStates();
    }

    function renderAll() {
      renderTicker();
      renderOverlayControls();
      updateHighlightRegex();
      renderPopupControls();
      renderBrbControls();
      renderMessages();
      renderPresets();
      updateOverlayChip();
      saveLocal();
      updatePanelBusyStates();
    }

    function applyTickerData(payload) {
      if (!payload || typeof payload !== 'object') return;
      const nextStampSource = payload._updatedAt != null ? payload._updatedAt : payload.updatedAt;
      const nextStampRaw = Number(nextStampSource);
      const hasStamp = Number.isFinite(nextStampRaw);
      if (hasStamp && typeof state.updatedAt === 'number' && state.updatedAt === nextStampRaw) {
        return;
      }

      state.messages = Array.isArray(payload.messages) ? payload.messages.slice() : [];
      state.isActive = !!payload.isActive;
      if (payload.displayDuration != null) {
        state.displayDuration = payload.displayDuration;
      }
      if (Number.isFinite(payload.intervalBetween)) {
        state.intervalBetween = payload.intervalBetween;
      } else if (Number.isFinite(payload.intervalMinutes)) {
        state.intervalMinutes = payload.intervalMinutes;
      }
      state._updatedAt = hasStamp ? nextStampRaw : Date.now();
    }

    function flushPendingOverlayPayload() {
      if (!pendingOverlayPayload) return;
      if (overlaySaveTimer) return;
      if (overlaySaveInFlight && !overlayAwaitingServerCommit) return;
      const latest = pendingOverlayPayload;
      pendingOverlayPayload = null;
      applyOverlayData(latest);
    }

    function applyOverlayData(payload) {
      if (!payload || typeof payload !== 'object') return;

      const remoteStampSource = payload._updatedAt != null ? payload._updatedAt : payload.updatedAt;
      const remoteStamp = Number(remoteStampSource);
      const localStamp = Number(overlayPrefs.updatedAt);
      const hasRemoteStamp = Number.isFinite(remoteStamp);
      const hasLocalStamp = Number.isFinite(localStamp);
      const expectingCommit = overlayAwaitingServerCommit;

      if (overlaySaveTimer || (overlaySaveInFlight && !expectingCommit)) {
        pendingOverlayPayload = payload;
        return;
      }

      pendingOverlayPayload = null;

      const remoteIsStale = hasRemoteStamp && hasLocalStamp && remoteStamp < localStamp;
      if (remoteIsStale) {
        if (expectingCommit && overlayAwaitingServerCommitStamp !== null && remoteStamp >= overlayAwaitingServerCommitStamp) {
          overlayAwaitingServerCommit = false;
          overlayAwaitingServerCommitStamp = null;
          if (!overlaySaveTimer && !overlaySaveInFlight) {
            overlayHasPendingLocalChanges = false;
          }
          updatePanelBusyStates();
        }
        return;
      }

      const remoteIsSame = hasRemoteStamp && hasLocalStamp && remoteStamp === localStamp;
      if (remoteIsSame) {
        if (expectingCommit && overlayAwaitingServerCommitStamp !== null && remoteStamp >= overlayAwaitingServerCommitStamp) {
          overlayAwaitingServerCommit = false;
          overlayAwaitingServerCommitStamp = null;
        }
        if (!overlaySaveTimer && !overlaySaveInFlight && !overlayAwaitingServerCommit) {
          overlayHasPendingLocalChanges = false;
        }
        pendingOverlayPayload = null;
        updatePanelBusyStates();
        return;
      }

      if (expectingCommit) {
        overlayAwaitingServerCommit = false;
        overlayAwaitingServerCommitStamp = null;
      } else if (overlayHasPendingLocalChanges) {
        overlayHasPendingLocalChanges = false;
        toast('Overlay updated on another device. Latest version loaded.');
      }

      const next = normaliseOverlayDataFn(payload);
      Object.keys(overlayPrefs).forEach(key => {
        if (!Object.prototype.hasOwnProperty.call(next, key)) {
          delete overlayPrefs[key];
        }
      });
      const resolvedStamp = hasRemoteStamp ? remoteStamp : Date.now();
      Object.assign(overlayPrefs, next, { updatedAt: resolvedStamp });

      if (!overlaySaveTimer && !overlaySaveInFlight && !overlayAwaitingServerCommit) {
        overlayHasPendingLocalChanges = false;
      }
      updatePanelBusyStates();
    }

    function flushPendingPopupPayload() {
      if (!pendingPopupPayload) return;
      if (popupSaveTimer) return;
      if (popupSaveInFlight && !popupAwaitingServerCommit) return;
      const latest = pendingPopupPayload;
      pendingPopupPayload = null;
      applyPopupData(latest);
    }

    function flushPendingSlatePayload() {
      if (!pendingSlatePayload || slateSaveTimer || slateSaveInFlight) return;
      const latest = pendingSlatePayload;
      pendingSlatePayload = null;
      applySlateData(latest);
    }

    function applySlateData(payload) {
      if (!payload || typeof payload !== 'object') return;
      const slateRemoteStampSource = payload._updatedAt != null ? payload._updatedAt : payload.updatedAt;
      const remoteStamp = Number(slateRemoteStampSource);
      const localStamp = Number(slateState.updatedAt);
      const hasRemoteStamp = Number.isFinite(remoteStamp);
      const hasLocalStamp = Number.isFinite(localStamp);

      if (slateSaveInFlight) {
        pendingSlatePayload = payload;
        return;
      }

      const remoteIsStale = hasRemoteStamp && hasLocalStamp && remoteStamp < localStamp;
      if (remoteIsStale) {
        console.warn('[dashboard] Ignoring stale slate update', { remoteStamp, localStamp });
        return;
      }

      const remoteIsSame = hasRemoteStamp && hasLocalStamp && remoteStamp === localStamp;
      const remoteIsNewer = hasRemoteStamp && (!hasLocalStamp || remoteStamp > localStamp);

      if (slateSaveTimer && (remoteIsSame || remoteIsNewer)) {
        clearTimeout(slateSaveTimer);
        slateSaveTimer = null;
      }

      pendingSlatePayload = null;

      if (remoteIsNewer) {
        if (slateAwaitingServerCommit) {
          slateHasPendingLocalChanges = false;
          slateAwaitingServerCommit = false;
        } else if (slateHasPendingLocalChanges) {
          slateHasPendingLocalChanges = false;
          toast('Slate updated on another device. Latest version loaded.');
        }
      }

      if (remoteIsSame) {
        slateHasPendingLocalChanges = false;
        slateAwaitingServerCommit = false;
        updatePanelBusyStates();
        return;
      }

      const next = normaliseSlateDataFn(payload);
      Object.keys(slateState).forEach(key => {
        if (!Object.prototype.hasOwnProperty.call(next, key)) {
          delete slateState[key];
        }
      });
      const resolvedStamp = hasRemoteStamp ? remoteStamp : Date.now();
      Object.assign(slateState, next, { updatedAt: resolvedStamp });
      slateHasPendingLocalChanges = false;
      slateAwaitingServerCommit = false;
      updatePanelBusyStates();
    }

    function applyPopupData(payload) {
      if (!payload || typeof payload !== 'object') return;

      const popupRemoteStampSource = payload._updatedAt != null ? payload._updatedAt : payload.updatedAt;
      const remoteStamp = Number(popupRemoteStampSource);
      const localStamp = Number(popupState.updatedAt);
      const hasRemoteStamp = Number.isFinite(remoteStamp);
      const hasLocalStamp = Number.isFinite(localStamp);
      const expectingCommit = popupAwaitingServerCommit;

      if (popupSaveTimer || (popupSaveInFlight && !expectingCommit)) {
        pendingPopupPayload = payload;
        return;
      }

      pendingPopupPayload = null;

      const remoteIsStale = hasRemoteStamp && hasLocalStamp && remoteStamp < localStamp;
      if (remoteIsStale) {
        if (expectingCommit && popupAwaitingServerCommitStamp !== null && remoteStamp >= popupAwaitingServerCommitStamp) {
          popupAwaitingServerCommit = false;
          popupAwaitingServerCommitStamp = null;
          if (!popupSaveTimer && !popupSaveInFlight) {
            popupHasPendingLocalChanges = false;
          }
          updatePanelBusyStates();
        }
        return;
      }

      const remoteIsSame = hasRemoteStamp && hasLocalStamp && remoteStamp === localStamp;
      if (remoteIsSame) {
        if (expectingCommit && popupAwaitingServerCommitStamp !== null && remoteStamp >= popupAwaitingServerCommitStamp) {
          popupAwaitingServerCommit = false;
          popupAwaitingServerCommitStamp = null;
        }
        if (!popupSaveTimer && !popupSaveInFlight && !popupAwaitingServerCommit) {
          popupHasPendingLocalChanges = false;
        }
        pendingPopupPayload = null;
        updatePanelBusyStates();
        return;
      }

      if (expectingCommit) {
        popupAwaitingServerCommit = false;
        popupAwaitingServerCommitStamp = null;
      } else if (popupHasPendingLocalChanges) {
        popupHasPendingLocalChanges = false;
        toast('Popup updated on another device. Latest version loaded.');
      }

      const next = normalisePopupDataFn(payload);
      Object.keys(popupState).forEach(key => {
        if (!Object.prototype.hasOwnProperty.call(next, key)) {
          delete popupState[key];
        }
      });
      const resolvedStamp = hasRemoteStamp ? remoteStamp : Date.now();
      Object.assign(popupState, next, { updatedAt: resolvedStamp });

      if (!popupSaveTimer && !popupSaveInFlight && !popupAwaitingServerCommit) {
        popupHasPendingLocalChanges = false;
      }
      updatePanelBusyStates();
    }

    function applyBrbData(payload) {
      if (!payload || typeof payload !== 'object') return;
      const next = normaliseBrbData(payload);
      Object.assign(brbState, next);
    }

    function applyPresetsData(list) {
      if (!Array.isArray(list)) return;
      const mapped = list.map(entry => ({
        id: String(entry.id || generateClientId('preset')),
        name: String(entry.name || 'Preset'),
        messages: sanitiseMessagesFn(entry.messages || []),
        updatedAt: Number(entry.updatedAt) || Date.now()
      }));
      presets.length = 0;
      presets.push(...mapped);
    }

    function applyScenesData(list) {
      if (!Array.isArray(list)) return;
      const mapped = [];
      for (const entry of list) {
        const normalised = normaliseSceneEntryFn(entry, {
          fallbackDisplayDuration: state.displayDuration,
          fallbackIntervalSeconds: minutesToSeconds(state.intervalMinutes),
          maxMessages: MAX_MESSAGES,
          maxMessageLength: MAX_MESSAGE_LENGTH
        });
        if (normalised) mapped.push(normalised);
      }
      scenes.length = 0;
      scenes.push(...mapped);
    }

    async function fetchState({ silent = false } = {}) {
      if (fetchInFlight) {
        fetchPending = true;
        fetchPendingSilent = fetchPendingSilent && silent;
        return;
      }
      fetchInFlight = true;
      fetchPendingSilent = true;
      try {
        await runQueued(stateRequestQueue, async () => {
          const base = serverBase();
          try {
            const tickerData = await requestJson(`${base}/ticker/state`, {
              init: { cache: 'no-store' },
              validate: validateTickerStateResponse,
              dedupe: true
            });
            applyTickerData(tickerData);

            await Promise.all([
              requestJson(`${base}/ticker/overlay`, {
                init: { cache: 'no-store' },
                validate: validateOverlayResponse,
                dedupe: true
              }).then(data => applyOverlayData(data)).catch(err => {
                console.warn('Failed to fetch overlay state', err);
              }),
              requestJson(`${base}/ticker/presets`, {
                init: { cache: 'no-store' },
                validate: validatePresetList,
                dedupe: true
              }).then(data => {
                if (Array.isArray(data.presets)) {
                  applyPresetsData(data.presets);
                }
              }).catch(err => {
                console.warn('Failed to fetch presets', err);
              }),
              requestJson(`${base}/ticker/scenes`, {
                init: { cache: 'no-store' },
                validate: validateSceneList,
                dedupe: true
              }).then(data => {
                if (Array.isArray(data.scenes)) {
                  applyScenesData(data.scenes);
                }
              }).catch(err => {
                console.warn('Failed to fetch scenes', err);
              }),
              requestJson(`${base}/popup/state`, {
                init: { cache: 'no-store' },
                validate: validatePopupResponse,
                dedupe: true
              }).then(data => applyPopupData(data)).catch(err => {
                console.warn('Failed to fetch popup state', err);
              }),
              requestJson(`${base}/brb/state`, {
                init: { cache: 'no-store' },
                validate: validateBrbResponse,
                dedupe: true
              }).then(data => applyBrbData(data)).catch(err => {
                console.warn('Failed to fetch BRB state', err);
              }),
              requestJson(`${base}/slate/state`, {
                init: { cache: 'no-store' },
                validate: validateSlateResponse,
                dedupe: true
              }).then(data => applySlateData(data)).catch(err => {
                console.warn('Failed to fetch slate state', err);
              })
            ]);

            applyServerStatus('online');
            if (!silent) {
              renderOverlayControls();
              updateOverlayChip();
            }
          } catch (err) {
            console.error('Failed to fetch state', err);
            applyServerStatus('offline', {
              message: resolveHealthMessage('network', 'offline'),
              force: true
            });
            if (!silent) toast('Server unreachable');
            markErrorHandled(err);
            throw err;
          }
        });
      } catch (err) {
        console.error('State refresh failed', err);
        if (!silent && !isErrorHandled(err)) {
          toast(resolveErrorMessage(err, 'Failed to refresh state'));
        }
      } finally {
        fetchInFlight = false;
        if (fetchPending) {
          const shouldBeSilent = fetchPendingSilent;
          fetchPending = false;
          fetchPendingSilent = true;
          void fetchState({ silent: shouldBeSilent });
        }
      }
    }

    async function persistState() {
      const base = serverBase();
      const timestamp = Number(state.updatedAt ?? state._updatedAt);
      const payload = {
        isActive: state.isActive,
        messages: state.messages,
        displayDuration: state.displayDuration,
        intervalBetween: minutesToSeconds(state.intervalMinutes),
        updatedAt: Number.isFinite(timestamp) ? timestamp : null
      };
      try {
        await runQueued(mutationQueues.ticker, async () => {
          try {
            const data = await requestJson(`${base}/ticker/state`, {
              init: {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              },
              validate: validateTickerMutation
            });
            if (data && data.state) {
              applyTickerData(data.state);
            }
            applyServerStatus('online');
          } catch (err) {
            console.error('Failed to save state', err);
            if (err && err.status === 409) {
              markErrorHandled(err);
              const latest = err.response && err.response.state;
              if (latest) {
                applyTickerData(latest);
              } else {
                void fetchState({ silent: true });
              }
              toast('Ticker updated on another device. Latest version loaded.');
            } else {
              toast(err && err.message ? err.message : 'Failed to save ticker state');
              applyServerStatus('error', { force: true });
              markErrorHandled(err);
            }
            throw err;
          }
        });
      } catch (err) {
        if (!isErrorHandled(err)) {
          console.error('Ticker state persistence failed', err);
          toast(resolveErrorMessage(err, 'Failed to save ticker state'));
        }
      }
    }

    async function persistPresets(options = {}) {
      const { notify = true } = options;
      const base = serverBase();
      try {
        await runQueued(mutationQueues.presets, async () => {
          try {
            const data = await requestJson(`${base}/ticker/presets`, {
              init: {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ presets })
              },
              validate: validatePresetsMutation
            });
            if (data && Array.isArray(data.presets)) {
              const mappedPresets = data.presets.map(entry => ({
                id: String(entry.id || generateClientId('preset')),
                name: String(entry.name || 'Preset'),
                messages: sanitiseMessagesFn(entry.messages || []),
                updatedAt: Number(entry.updatedAt) || Date.now()
              }));
              presets.length = 0;
              presets.push(...mappedPresets);
            }
            if (notify) toast('Presets saved');
          } catch (err) {
            console.error('Failed to save presets', err);
            if (notify) toast(err.message || 'Failed to save presets');
            markErrorHandled(err);
            throw err;
          }
        });
      } catch (err) {
        if (!isErrorHandled(err)) {
          console.error('Preset persistence failed', err);
          if (notify) toast(resolveErrorMessage(err, 'Failed to save presets'));
        }
      }
    }

    function queueSave() {
      clearTimeout(saveTimer);
      saveTimer = setTimeout(() => {
        persistState();
      }, 250);
    }

    function queuePopupSave() {
      clearTimeout(popupSaveTimer);
      popupSaveTimer = setTimeout(() => {
        popupSaveTimer = null;
        updatePanelBusyStates();
        void persistPopup();
      }, 220);
      popupHasPendingLocalChanges = true;
      updatePanelBusyStates();
    }

    async function persistPopup() {
      const base = serverBase();
      const raw = el.popupText ? el.popupText.value : '';
      const text = sanitiseTextInput(raw, {
        maxLength: MAX_POPUP_LENGTH,
        fallback: '',
        allowMultiline: true
      });
      if (el.popupText && raw !== text) {
        el.popupText.value = text;
      }
      const isActive = el.popupActive.checked && !!text;
      el.popupActive.checked = isActive;

      let durationSeconds = popupState.durationSeconds;
    if (el.popupDuration) {
        const rawDuration = el.popupDuration.value.trim();
        if (!rawDuration) {
          durationSeconds = null;
        } else {
          const numeric = Number(rawDuration);
          if (Number.isFinite(numeric)) {
            const rounded = Math.round(numeric);
            const clamped = Math.max(0, Math.min(MAX_POPUP_SECONDS, rounded));
            durationSeconds = clamped > 0 ? clamped : null;
          } else {
            durationSeconds = null;
          }
        }
        const displayValue = durationSeconds ? String(durationSeconds) : '';
        if (el.popupDuration.value !== displayValue) {
          el.popupDuration.value = displayValue;
        }
      }

      let countdownEnabled = el.popupCountdownEnabled ? el.popupCountdownEnabled.checked : false;
      if (!text) {
        countdownEnabled = false;
      }
      let countdownTarget = popupState.countdownTarget;
      if (countdownEnabled) {
        const rawCountdown = el.popupCountdownTarget ? el.popupCountdownTarget.value : '';
        if (rawCountdown) {
          const parsedCountdown = parseCountdownTarget(rawCountdown);
          if (Number.isFinite(parsedCountdown)) {
            countdownTarget = parsedCountdown;
            if (el.popupCountdownTarget) {
              const formatted = formatDatetimeLocal(parsedCountdown);
              if (formatted) {
                el.popupCountdownTarget.value = formatted;
              }
            }
          } else {
            countdownEnabled = false;
            countdownTarget = null;
            toast('Enter a valid countdown target');
          }
        } else if (!Number.isFinite(countdownTarget)) {
          countdownEnabled = false;
          countdownTarget = null;
          toast('Select a countdown target time');
        }
      } else {
        countdownTarget = null;
      }
    if (el.popupCountdownEnabled && !countdownEnabled) {
        el.popupCountdownEnabled.checked = false;
      }

      const nextState = {
        ...popupState,
        text,
        isActive,
        durationSeconds,
        countdownEnabled,
        countdownTarget
      };

      const changed =
        popupState.text !== nextState.text ||
        popupState.isActive !== nextState.isActive ||
        popupState.durationSeconds !== nextState.durationSeconds ||
        popupState.countdownEnabled !== nextState.countdownEnabled ||
        popupState.countdownTarget !== nextState.countdownTarget;

      Object.assign(popupState, nextState, {
        updatedAt: changed ? Date.now() : popupState.updatedAt
      });

      if (!changed) {
        popupHasPendingLocalChanges = false;
        updatePanelBusyStates();
        return;
      }

      popupAwaitingServerCommit = true;
      popupAwaitingServerCommitStamp = Number(popupState.updatedAt) || Date.now();
      popupHasPendingLocalChanges = true;
      popupSaveInFlight = true;
      updatePanelBusyStates();
      renderPopupControls();
      const payload = {
        text: popupState.text,
        isActive: popupState.isActive,
        durationSeconds: popupState.durationSeconds,
        countdownEnabled: popupState.countdownEnabled,
        countdownTarget: popupState.countdownTarget,
        updatedAt: Number(popupState.updatedAt) || null
      };
      try {
        await runQueued(mutationQueues.popup, async () => {
          try {
            const data = await requestJson(`${base}/popup/state`, {
              init: {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              },
              validate: validatePopupMutation
            });
            if (data && data.popup) {
              applyPopupData(data.popup);
            } else {
              popupAwaitingServerCommit = false;
              popupAwaitingServerCommitStamp = null;
              Object.assign(popupState, payload, { updatedAt: Date.now() });
              renderPopupControls();
              popupHasPendingLocalChanges = false;
            }
            toast(isActive ? 'Popup updated' : 'Popup cleared');
          } catch (err) {
            console.error('Failed to save popup state', err);
            popupAwaitingServerCommit = false;
            popupAwaitingServerCommitStamp = null;
            if (err && err.status === 409) {
              popupHasPendingLocalChanges = false;
              const latest = err.response && err.response.popup;
              if (latest) {
                applyPopupData(latest);
              } else {
                void fetchState({ silent: true });
              }
              toast('Popup updated on another device. Latest version loaded.');
            } else {
              toast(err.message || 'Failed to update popup');
            }
            markErrorHandled(err);
            throw err;
          }
        });
      } catch (err) {
        if (!isErrorHandled(err)) {
          console.error('Popup persistence failed', err);
          toast(resolveErrorMessage(err, 'Failed to update popup'));
        }
      } finally {
        popupSaveInFlight = false;
        updatePanelBusyStates();
        renderPopupControls();
        flushPendingPopupPayload();
        if (!popupSaveTimer && !popupSaveInFlight && !popupAwaitingServerCommit) {
          popupHasPendingLocalChanges = false;
        }
      }
    }

    function queueBrbSave() {
      clearTimeout(brbSaveTimer);
      brbSaveTimer = setTimeout(() => {
        brbSaveTimer = null;
        updatePanelBusyStates();
        void persistBrb();
      }, 220);
      updatePanelBusyStates();
    }

    async function persistBrb() {
      const base = serverBase();
      const raw = el.brbText ? el.brbText.value : '';
      const text = sanitiseTextInput(raw, {
        maxLength: MAX_BRB_LENGTH,
        fallback: '',
        allowMultiline: true
      });
      if (el.brbText && raw !== text) {
        el.brbText.value = text;
      }
      const isActive = el.brbActive && el.brbActive.checked && !!text;
      if (el.brbActive) {
        el.brbActive.checked = isActive;
      }

      const payload = { text, isActive };
      brbSaveInFlight = true;
      updatePanelBusyStates();
      renderBrbControls();
      try {
        await runQueued(mutationQueues.brb, async () => {
          try {
            const data = await requestJson(`${base}/brb/state`, {
              init: {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              },
              validate: validateBrbMutation
            });
            if (data && data.state) {
              applyBrbData(data.state);
            } else {
              Object.assign(brbState, { text, isActive, updatedAt: Date.now() });
              renderBrbControls();
            }
            toast(isActive ? 'BRB updated' : 'BRB hidden');
          } catch (err) {
            console.error('Failed to save BRB state', err);
            toast(err.message || 'Failed to update BRB state');
            markErrorHandled(err);
            throw err;
          }
        });
      } catch (err) {
        if (!isErrorHandled(err)) {
          console.error('BRB persistence failed', err);
          toast(resolveErrorMessage(err, 'Failed to update BRB state'));
        }
      } finally {
        brbSaveInFlight = false;
        updatePanelBusyStates();
        renderBrbControls();
      }
    }

    function markStreamPrimed() {
      if (streamPrimed) return;
      streamPrimed = true;
      if (streamFallbackTimer) {
        clearTimeout(streamFallbackTimer);
        streamFallbackTimer = null;
      }
    }

    function handleStreamPayloadError(kind, error) {
      console.warn(`[Ticker] Failed to process ${kind} stream payload`, error);
      if (!isPollingActive) {
        startPolling(`${kind}-parse`);
      } else {
        setStreamState(STREAM_STATES.POLLING, { reason: `${kind}-parse` });
      }
      applyServerStatus('reconnecting', { force: true });
      disconnectStream({ preservePolling: true });
      void fetchState({ silent: true });
      scheduleReconnect(`${kind}-parse`);
    }

    function processStreamPayload(kind, event, handler) {
      if (!event || typeof event.data !== 'string') {
        handleStreamPayloadError(kind, new Error('Missing event payload'));
        return;
      }
      let parsed;
      try {
        parsed = JSON.parse(event.data);
      } catch (error) {
        handleStreamPayloadError(kind, error);
        return;
      }
      try {
        const applied = handler(parsed);
        if (applied !== false) {
          markStreamPrimed();
        }
      } catch (error) {
        handleStreamPayloadError(kind, error);
      }
    }

    function detachEventSourceListeners(source = eventSource) {
      if (!source || !Array.isArray(eventSourceListeners)) {
        eventSourceListeners = [];
        return;
      }
      for (const entry of eventSourceListeners) {
        const { type, handler } = entry || {};
        if (!type || typeof handler !== 'function') continue;
        try {
          source.removeEventListener(type, handler);
        } catch (err) {
          // Ignore removal errors.
        }
      }
      eventSourceListeners = [];
    }

    function disconnectStream(options = {}) {
      const { preservePolling = false } = options;
      if (eventSource) {
        detachEventSourceListeners(eventSource);
        try {
          eventSource.close();
        } catch (err) {
          // Ignore close errors.
        }
        eventSource = null;
      }
      if (streamFallbackTimer) {
        clearTimeout(streamFallbackTimer);
        streamFallbackTimer = null;
      }
      clearReconnectTimer();
      stopHealthChecks();
      if (!preservePolling) {
        stopPolling();
        setStreamState(STREAM_STATES.IDLE);
      } else if (isPollingActive) {
        setStreamState(STREAM_STATES.POLLING, { reason: 'preserve' });
      } else {
        setStreamState(STREAM_STATES.IDLE);
      }
      streamPrimed = false;
    }

    function cancelAllTimers() {
      clearTimeout(saveTimer);
      saveTimer = null;
      clearTimeout(popupSaveTimer);
      popupSaveTimer = null;
      clearTimeout(brbSaveTimer);
      brbSaveTimer = null;
      clearTimeout(overlaySaveTimer);
      overlaySaveTimer = null;
      clearTimeout(slateSaveTimer);
      slateSaveTimer = null;
      if (uiState.previewUpdateTimer) {
        clearTimeout(uiState.previewUpdateTimer);
        uiState.previewUpdateTimer = null;
      }
      if (uiState.previewLoadingTimer) {
        clearTimeout(uiState.previewLoadingTimer);
        uiState.previewLoadingTimer = null;
      }
      if (el.toast && el.toast._hideTimer) {
        clearTimeout(el.toast._hideTimer);
        el.toast._hideTimer = null;
      }
      if (streamFallbackTimer) {
        clearTimeout(streamFallbackTimer);
        streamFallbackTimer = null;
      }
      clearSlatePreviewTimers();
      stopSlatePreviewClock();
      clearReconnectTimer();
      stopHealthChecks();
      stopPolling();
    }

    function destroyDashboard() {
      cancelAllTimers();
      disconnectStream();
      cleanupBag.run();
      handlersRegistered = false;
    }

    async function connectStream(options = {}) {
      try {
        const { isRetry = false, reason = 'manual' } = options;
        console.log('[DEBUG] Connecting stream:', { isRetry, reason, server: serverBase() });
        disconnectStream({ preservePolling: true });
        if (!isRetry) {
          connectionRetryAttempt = 0;
        }

        const validation = getValidatedServerBase();
        console.log('[DEBUG] Server validation:', validation);
        if (!validation.ok || !validation.url) {
          console.error('[DEBUG] Invalid server URL:', validation);
          applyServerStatus('invalid', { force: true });
          stopPolling();
          return;
        }

      clearReconnectTimer();
      setStreamState(STREAM_STATES.CONNECTING);
      applyServerStatus(isRetry ? 'reconnecting' : 'checking', { force: true });

      const health = await checkServerHealth();
      if (!health.ok || !health.url) {
        console.warn('[Ticker] Health check failed before stream connection', health);
        const status = health.reason === 'invalid-url' ? 'invalid' : 'offline';
        const message = resolveHealthMessage(health.reason, status);
        applyServerStatus(status, { message, force: true });
        if (status === 'invalid') {
          setStreamState(STREAM_STATES.IDLE, { reason: 'health-check' });
          stopPolling();
        } else {
          setStreamState(STREAM_STATES.ERROR, { reason: 'health-check', status });
        }
        if (status !== 'invalid') {
          scheduleReconnect('health-check');
        }
        return;
      }

      if (typeof EventSource !== 'function') {
        console.warn('[Ticker] EventSource unsupported, using polling fallback.');
        startPolling('unsupported');
        return;
      }

      try {
        const streamUrl = `${health.url}/ticker/stream`;
        const source = new EventSource(streamUrl);
        eventSource = source;
        eventSourceListeners = [];
        streamPrimed = false;

        if (streamFallbackTimer) clearTimeout(streamFallbackTimer);
        streamFallbackTimer = setTimeout(() => {
          streamFallbackTimer = null;
          if (!streamPrimed) {
            void fetchState({ silent: true });
            if (!isPollingActive) {
              startPolling('prime-timeout');
            }
          }
        }, STREAM_PRIME_TIMEOUT_MS);

        const register = (type, handler) => {
          if (!type || typeof handler !== 'function') return;
          source.addEventListener(type, handler);
          eventSourceListeners.push({ type, handler });
        };

        register('open', () => {
          setStreamState(STREAM_STATES.OPEN);
        });

        register('error', () => {
          if (eventSource !== source) return;
          setStreamState(STREAM_STATES.ERROR, { reason: 'stream-error' });
          applyServerStatus('reconnecting', { force: true });
          if (!streamPrimed) {
            void fetchState({ silent: true });
          }
          if (!isPollingActive) {
            startPolling('stream-error');
          }
          disconnectStream({ preservePolling: true });
          scheduleReconnect('stream-error');
        });

        register('ticker', event => {
          processStreamPayload('ticker', event, data => {
            applyTickerData(data);
          });
        });

        register('overlay', event => {
          processStreamPayload('overlay', event, data => {
            applyOverlayData(data);
          });
        });

        register('presets', event => {
          processStreamPayload('presets', event, data => {
            if (Array.isArray(data)) {
              applyPresetsData(data);
              return true;
            }
            return false;
          });
        });

        register('scenes', event => {
          processStreamPayload('scenes', event, data => {
            if (Array.isArray(data)) {
              applyScenesData(data);
              return true;
            }
            return false;
          });
        });

        register('popup', event => {
          processStreamPayload('popup', event, data => {
            applyPopupData(data);
          });
        });

        register('slate', event => {
          processStreamPayload('slate', event, data => {
            applySlateData(data);
          });
        });

        register('brb', event => {
          processStreamPayload('brb', event, data => {
            applyBrbData(data);
          });
        });
      } catch (err) {
        console.error('Failed to connect to event stream', err);
        disconnectStream({ preservePolling: true });
        const failureReason = reason || 'exception';
        setStreamState(STREAM_STATES.ERROR, { reason: failureReason });
        applyServerStatus('error', { force: true });
        if (!isPollingActive) {
          startPolling('stream-error');
        }
        scheduleReconnect(failureReason);
        void fetchState({ silent: true });
        markErrorHandled(err);
      }
    } catch (err) {
      console.error('[DEBUG] Stream connection failed:', err);
      applyServerStatus('error', { force: true });
      if (!isErrorHandled(err)) {
        toast(resolveErrorMessage(err, 'Failed to connect to stream'));
      }
    }

    async function persistOverlay() {
      const base = serverBase();
      const payload = {
        label: overlayPrefs.label,
        accent: overlayPrefs.accent,
        accentSecondary: overlayPrefs.accentSecondary,
        highlight: overlayPrefs.highlight,
        scale: overlayPrefs.scale,
        popupScale: overlayPrefs.popupScale,
        position: overlayPrefs.position,
        mode: overlayPrefs.mode,
        accentAnim: overlayPrefs.accentAnim,
        sparkle: overlayPrefs.sparkle,
        theme: overlayPrefs.theme,
        updatedAt: Number(overlayPrefs.updatedAt) || null
      };
      overlayAwaitingServerCommit = true;
      overlayAwaitingServerCommitStamp = Number(overlayPrefs.updatedAt) || Date.now();
      overlaySaveInFlight = true;
      updatePanelBusyStates();
      try {
        await runQueued(mutationQueues.overlay, async () => {
          try {
            const data = await requestJson(`${base}/ticker/overlay`, {
              init: {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              },
              validate: validateOverlayMutation
            });
            if (data && data.overlay) {
              applyOverlayData(data.overlay);
            } else {
              overlayAwaitingServerCommit = false;
              overlayAwaitingServerCommitStamp = null;
            }
          } catch (err) {
            console.error('Failed to save overlay preferences', err);
            overlayAwaitingServerCommit = false;
            overlayAwaitingServerCommitStamp = null;
            if (err && err.status === 409) {
              overlayHasPendingLocalChanges = false;
              const latest = err.response && err.response.overlay;
              if (latest) {
                applyOverlayData(latest);
              } else {
                void fetchState({ silent: true });
              }
              toast('Overlay updated on another device. Latest version loaded.');
            } else {
              toast(err.message || 'Failed to save overlay preferences');
            }
            markErrorHandled(err);
            throw err;
          }
        });
      } catch (err) {
        if (!isErrorHandled(err)) {
          console.error('Overlay persistence failed', err);
          toast(resolveErrorMessage(err, 'Failed to save overlay preferences'));
        }
      } finally {
        overlaySaveInFlight = false;
        updatePanelBusyStates();
        flushPendingOverlayPayload();
        if (!overlaySaveTimer && !overlaySaveInFlight && !overlayAwaitingServerCommit) {
          overlayHasPendingLocalChanges = false;
        }
      }
    }

    function queueOverlaySave() {
      clearTimeout(overlaySaveTimer);
      overlaySaveTimer = setTimeout(() => {
        overlaySaveTimer = null;
        updatePanelBusyStates();
        persistOverlay();
      }, 200);
      overlayHasPendingLocalChanges = true;
      updatePanelBusyStates();
    }

    async function persistSlate() {
      const base = serverBase();
      const payload = {
        ...serialiseSlateState(),
        updatedAt: Number(slateState.updatedAt) || null
      };
      slateAwaitingServerCommit = true;
      slateSaveInFlight = true;
      updatePanelBusyStates();
      try {
        await runQueued(mutationQueues.slate, async () => {
          try {
            const data = await requestJson(`${base}/slate/state`, {
              init: {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              },
              validate: validateSlateMutation
            });
            if (data && data.slate) {
              applySlateData(data.slate);
            }
          } catch (err) {
            console.error('Failed to save slate state', err);
            if (err && err.status === 409) {
              slateHasPendingLocalChanges = false;
              const latest = err.response && err.response.slate;
              if (latest) {
                applySlateData(latest);
              } else {
                void fetchState({ silent: true });
              }
              toast('Slate updated on another device. Latest version loaded.');
            } else {
              toast(err.message || 'Failed to save slate');
            }
            markErrorHandled(err);
            throw err;
          }
        });
      } catch (err) {
        if (!isErrorHandled(err)) {
          console.error('Slate persistence failed', err);
          toast(resolveErrorMessage(err, 'Failed to save slate'));
        }
      } finally {
        slateSaveInFlight = false;
        updatePanelBusyStates();
        flushPendingSlatePayload();
        slateAwaitingServerCommit = false;
      }
    }

    function queueSlateSave() {
      clearTimeout(slateSaveTimer);
      slateSaveTimer = setTimeout(() => {
        slateSaveTimer = null;
        updatePanelBusyStates();
        persistSlate();
      }, 220);
      updatePanelBusyStates();
    }

    function beginEdit(index) {
      if (index < 0 || index >= state.messages.length) return;
      uiState.editingIndex = index;
      uiState.editingDraft = state.messages[index];
      renderMessages();
      const editor = el.messageList.querySelector('.message-item.is-editing .message-edit-input');
      if (editor) {
        requestAnimationFrame(() => {
          editor.focus();
          editor.setSelectionRange(editor.value.length, editor.value.length);
        });
      }
    }

    function commitEdit(index) {
      if (index < 0 || index >= state.messages.length) return;
      const sanitised = sanitiseTextInput(uiState.editingDraft, {
        maxLength: MAX_MESSAGE_LENGTH,
        fallback: ''
      });
      if (!sanitised) {
        toast('Message cannot be empty');
        return;
      }
      const originalLength = typeof uiState.editingDraft === 'string'
        ? uiState.editingDraft.trim().length
        : 0;
      if (originalLength > MAX_MESSAGE_LENGTH) {
        toast(`Message trimmed to ${MAX_MESSAGE_LENGTH} characters`);
      }
      const changed = state.messages[index] !== sanitised;
      state.messages[index] = sanitised;
      clearEditing();
      if (changed) queueSave();
    }

    function cancelEdit() {
      clearEditing();
      renderMessages();
    }

    function addMessage(text) {
      const sanitised = sanitiseTextInput(text, {
        maxLength: MAX_MESSAGE_LENGTH,
        fallback: ''
      });
      if (!sanitised) {
        toast('Enter a message before adding');
        return false;
      }
      const originalLength = typeof text === 'string' ? text.trim().length : 0;
      if (originalLength > MAX_MESSAGE_LENGTH) {
        toast(`Message trimmed to ${MAX_MESSAGE_LENGTH} characters`);
      }
      if (state.messages.length >= MAX_MESSAGES) {
        toast(`Queue is full (max ${MAX_MESSAGES} messages)`);
        return false;
      }
      state.messages.push(sanitised);
      if (el.autoStart.checked) state.isActive = true;
      clearEditing();
      queueSave();
      return true;
    }

    function removeMessage(index) {
      if (index < 0 || index >= state.messages.length) return;
      state.messages.splice(index, 1);
      if (!state.messages.length) state.isActive = false;
      if (uiState.editingIndex === index) {
        clearEditing();
      }
      queueSave();
    }

    function moveMessage(index, delta) {
      const target = index + delta;
      if (target < 0 || target >= state.messages.length) return;
      const [item] = state.messages.splice(index, 1);
      state.messages.splice(target, 0, item);
      clearEditing();
      renderMessages();
      queueSave();
    }

    function isPresetModalOpen() {
      return el.presetModal && el.presetModal.classList.contains('is-visible');
    }

    function updatePresetModalError(message) {
      const hasError = Boolean(message);
    if (el.presetModalHint) {
        el.presetModalHint.textContent = hasError ? message : PRESET_NAME_HINT;
        el.presetModalHint.classList.toggle('is-error', hasError);
      }
    if (el.presetModalName) {
        el.presetModalName.classList.toggle('has-error', hasError);
      }
    }

    function openPresetModal(index, triggerButton) {
      if (!el.presetModal || typeof index !== 'number') return;
      const message = state.messages[index];
      const trimmed = typeof message === 'string' ? message.trim() : '';
      if (!trimmed) {
        toast('Message is empty');
        return;
      }
      const defaultName = trimmed.length > 40 ? `${trimmed.slice(0, 40)}…` : trimmed;
      uiState.pendingPresetMessage = {
        index,
        message,
        trigger: triggerButton || null
      };
    if (el.presetModalPreview) {
        const previewHtml = formatMessage(message) || '<span class="small">Message will be sanitised before saving.</span>';
        el.presetModalPreview.innerHTML = previewHtml;
      }
    if (el.presetModalName) {
        el.presetModalName.value = defaultName || 'Message preset';
        requestAnimationFrame(() => {
          try {
            el.presetModalName.focus();
            el.presetModalName.select();
          } catch (err) {
            // ignore focus errors
          }
        });
      }
      updatePresetModalError('');
      el.presetModal.classList.add('is-visible');
      el.presetModal.setAttribute('aria-hidden', 'false');
      document.body.classList.add('is-modal-open');
    }

    function closePresetModal(options = {}) {
      const { restoreFocus = false } = options;
      const trigger = uiState.pendingPresetMessage && uiState.pendingPresetMessage.trigger;
      uiState.pendingPresetMessage = null;
    if (el.presetModal) {
        el.presetModal.classList.remove('is-visible');
        el.presetModal.setAttribute('aria-hidden', 'true');
      }
      document.body.classList.remove('is-modal-open');
    if (el.presetModalName) {
        el.presetModalName.value = '';
        el.presetModalName.classList.remove('has-error');
      }
    if (el.presetModalPreview) {
        el.presetModalPreview.innerHTML = '<span class="small">Select a message to begin.</span>';
      }
      updatePresetModalError('');
      if (restoreFocus && trigger && typeof trigger.focus === 'function') {
        requestAnimationFrame(() => {
          try {
            trigger.focus();
          } catch (err) {
            // ignore focus errors
          }
        });
      }
    }

    function confirmPresetModal() {
      if (!uiState.pendingPresetMessage || !el.presetModalName) return;
      const rawName = el.presetModalName.value;
      const cleanedName = sanitiseTextInput(rawName, {
        maxLength: MAX_PRESET_NAME_LENGTH,
        fallback: ''
      });
      if (!cleanedName) {
        updatePresetModalError('Enter a preset name');
        el.presetModalName.focus();
        return;
      }
      const trimmedOriginal = typeof rawName === 'string' ? rawName.trim() : '';
      if (trimmedOriginal.length > MAX_PRESET_NAME_LENGTH) {
        updatePresetModalError(`Preset names must be ${MAX_PRESET_NAME_LENGTH} characters or fewer.`);
        el.presetModalName.focus();
        return;
      }
      const { index, message: fallback } = uiState.pendingPresetMessage;
      let source = typeof index === 'number' && index >= 0 && index < state.messages.length
        ? state.messages[index]
        : fallback;
      const sanitised = sanitiseMessagesFn([source], { includeMeta: true });
      if (!sanitised.messages.length) {
        updatePresetModalError('Message is empty after sanitising');
        return;
      }
      const payload = {
        id: generateClientId('preset'),
        name: cleanedName,
        messages: sanitised.messages,
        updatedAt: Date.now()
      };
      const existingIndex = presets.findIndex(item => item.name.toLowerCase() === cleanedName.toLowerCase());
      if (existingIndex >= 0) {
        payload.id = presets[existingIndex].id;
        presets.splice(existingIndex, 1, payload);
      } else {
        presets.unshift(payload);
      }
      renderPresets();
      void persistPresets({ notify: false });
      toast(`Saved “${cleanedName}” to presets`);
      closePresetModal({ restoreFocus: true });
    }

    function handleMessageAction(event) {
      const button = event.target.closest('button[data-action]');
      if (!button) return;
      const row = button.closest('.message-item');
      if (!row) return;
      const index = Number(row.dataset.index);
      switch (button.dataset.action) {
        case 'delete':
          removeMessage(index);
          break;
        case 'up':
          moveMessage(index, -1);
          break;
        case 'down':
          moveMessage(index, 1);
          break;
        case 'edit':
          beginEdit(index);
          break;
        case 'save-preset':
          openPresetModal(index, button);
          break;
        case 'save': {
          const input = row.querySelector('.message-edit-input');
          if (input) uiState.editingDraft = input.value;
          commitEdit(index);
          break;
        }
        case 'cancel':
          cancelEdit();
          break;
      }
    }

    function updateSegmentSelection(container, attr, value) {
      if (!container) return;
      const selector = `[data-${attr}]`;
      Array.from(container.querySelectorAll(selector)).forEach(btn => {
        const isActive = btn.dataset[attr] === value;
        btn.classList.toggle('is-active', isActive);
        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      });
    }

    function setMode(value) {
      const mode = typeof sharedNormaliseMode === 'function'
        ? sharedNormaliseMode(value)
        : (['auto', 'marquee', 'chunk'].includes(String(value).toLowerCase()) ? String(value).toLowerCase() : null);
      if (!mode) return;
      overlayPrefs.mode = mode;
      updateSegmentSelection(el.modeButtons, 'mode', mode);
      updateOverlayChip();
      queueOverlaySave();
    }

    function setPosition(value) {
      const position = typeof sharedNormalisePosition === 'function'
        ? sharedNormalisePosition(value)
        : (String(value).toLowerCase() === 'top' ? 'top' : 'bottom');
      overlayPrefs.position = position;
      updateSegmentSelection(el.positionButtons, 'position', position);
      updateOverlayChip();
      queueOverlaySave();
    }

    function setTheme(value) {
      if (!THEME_OPTIONS.includes(value)) return;
      overlayPrefs.theme = value;
      updateSegmentSelection(el.themeButtons, 'theme', value);
      applyPreviewTheme();
      updateOverlayChip();
      queueOverlaySave();
    }

    function updateScale(value) {
      const next = typeof clampScaleValue === 'function'
        ? clampScaleValue(value, overlayPrefs.scale)
        : (() => {
            const numeric = Number(value);
            if (!Number.isFinite(numeric)) return overlayPrefs.scale;
            return Math.max(0.75, Math.min(2.5, Math.round(numeric * 100) / 100));
          })();
      overlayPrefs.scale = next;
      if (el.scaleRange && el.scaleRange.value !== String(next)) {
        el.scaleRange.value = String(next);
      }
      if (el.scaleNumber && el.scaleNumber.value !== String(next)) {
        el.scaleNumber.value = String(next);
      }
      updateOverlayChip();
      queueOverlaySave();
    }

    function updatePopupScale(value) {
      const next = typeof clampPopupScaleValue === 'function'
        ? clampPopupScaleValue(value, overlayPrefs.popupScale)
        : (() => {
            const numeric = Number(value);
            if (!Number.isFinite(numeric)) return overlayPrefs.popupScale;
            return Math.max(0.6, Math.min(1.5, Math.round(numeric * 100) / 100));
          })();
      overlayPrefs.popupScale = next;
      if (el.popupScaleRange && el.popupScaleRange.value !== String(next)) {
        el.popupScaleRange.value = String(next);
      }
      if (el.popupScaleNumber && el.popupScaleNumber.value !== String(next)) {
        el.popupScaleNumber.value = String(next);
      }
      renderPopupPreviewScale();
      updateOverlayChip();
      queueOverlaySave();
    }

    function handlePresetAction(event) {
      const button = event.target.closest('button[data-action]');
      if (!button) return;
      const card = button.closest('.preset-card');
      if (!card) return;
      const id = card.dataset.id;
      const preset = presets.find(item => item.id === id);
      if (!preset) return;
      switch (button.dataset.action) {
        case 'load':
          const loadResult = sanitiseMessagesFn(preset.messages, { includeMeta: true });
          state.messages = [...loadResult.messages];
          if (state.messages.length) {
            state.isActive = state.isActive || el.autoStart.checked;
          } else {
            state.isActive = false;
          }
          queueSave();
          {
            const notes = [];
            if (loadResult.truncated) notes.push(`limited to ${MAX_MESSAGES}`);
            if (loadResult.trimmed) notes.push(`trimmed to ${MAX_MESSAGE_LENGTH} chars`);
            const summary = `Loaded preset “${preset.name}”`;
            toast(notes.length ? `${summary} • ${notes.join('; ')}` : summary);
          }
          break;
        case 'append':
          if (state.messages.length >= MAX_MESSAGES) {
            toast(`Queue is full (max ${MAX_MESSAGES} messages)`);
            return;
          }
          const appendResult = sanitiseMessagesFn(preset.messages, { includeMeta: true });
          const available = MAX_MESSAGES - state.messages.length;
          const additions = appendResult.messages.slice(0, available);
          if (!additions.length) {
            toast(`Queue is full (max ${MAX_MESSAGES} messages)`);
            return;
          }
          state.messages.push(...additions);
          if (el.autoStart.checked && state.messages.length) state.isActive = true;
          queueSave();
          {
            const skippedForQueue = appendResult.messages.length - additions.length;
            const notes = [];
            if (skippedForQueue > 0) notes.push(`skipped ${skippedForQueue} (queue full)`);
            if (appendResult.truncated) notes.push(`preset limited to ${MAX_MESSAGES}`);
            if (appendResult.trimmed) notes.push(`trimmed to ${MAX_MESSAGE_LENGTH} chars`);
            const summary = `Appended ${additions.length} message${additions.length === 1 ? '' : 's'}`;
            toast(notes.length ? `${summary} • ${notes.join('; ')}` : summary);
          }
          break;
        case 'delete':
          {
            const filtered = presets.filter(item => item.id !== id);
            presets.length = 0;
            presets.push(...filtered);
          }
          persistPresets();
          break;
      }
    }

    function buildSceneOverlayPayload(prefs = overlayPrefs) {
      if (!prefs || typeof prefs !== 'object') {
        return null;
      }

      const allowedKeys = SCENE_OVERLAY_KEYS || [];

      if (serialiseOverlayForSceneImpl) {
        const serialised = serialiseOverlayForSceneImpl(prefs, {
          normaliseOverlayData: normaliseOverlayDataFn,
          overlayKeys: allowedKeys,
          includeEmptyStrings: false
        });
        if (!serialised || typeof serialised !== 'object') {
          return null;
        }
        const filtered = {};
        for (const key of allowedKeys) {
          if (Object.prototype.hasOwnProperty.call(serialised, key)) {
            filtered[key] = serialised[key];
          }
        }
        return Object.keys(filtered).length ? filtered : null;
      }

      const base = {
        ...DEFAULT_OVERLAY,
        highlight: DEFAULT_OVERLAY.highlight || DEFAULT_HIGHLIGHT_STRING
      };
      const normalised = { ...base };

      if (typeof prefs.label === 'string') {
        const trimmed = prefs.label.trim().slice(0, 48);
        if (trimmed) normalised.label = trimmed;
      }

      if (typeof prefs.accent === 'string') {
        const trimmed = prefs.accent.trim();
        if (!trimmed) {
          normalised.accent = '';
        } else if (trimmed.length <= 64 && isSafeColour(trimmed)) {
          normalised.accent = trimmed;
        }
      }

      if (typeof prefs.accentSecondary === 'string') {
        const trimmedSecondary = prefs.accentSecondary.trim();
        if (!trimmedSecondary) {
          normalised.accentSecondary = '';
        } else if (trimmedSecondary.length <= 64 && isSafeColour(trimmedSecondary)) {
          normalised.accentSecondary = trimmedSecondary;
        }
      }

      if (typeof prefs.highlight === 'string') {
        const normalisedHighlight = normaliseHighlightInputFn(prefs.highlight);
        if (typeof normalisedHighlight === 'string' && normalisedHighlight) {
          normalised.highlight = normalisedHighlight.slice(0, 512);
        } else {
          normalised.highlight = prefs.highlight.trim().slice(0, 512);
        }
      }

      if (Number.isFinite(prefs.scale)) {
        normalised.scale = typeof clampScaleValue === 'function'
          ? clampScaleValue(prefs.scale, normalised.scale)
          : Math.max(0.75, Math.min(2.5, Math.round(Number(prefs.scale) * 100) / 100));
      }

      if (Number.isFinite(prefs.popupScale)) {
        normalised.popupScale = typeof clampPopupScaleValue === 'function'
          ? clampPopupScaleValue(prefs.popupScale, normalised.popupScale)
          : Math.max(0.6, Math.min(1.5, Math.round(Number(prefs.popupScale) * 100) / 100));
      }

      if (typeof prefs.position === 'string') {
        normalised.position = typeof sharedNormalisePosition === 'function'
          ? sharedNormalisePosition(prefs.position)
          : (String(prefs.position).toLowerCase() === 'top' ? 'top' : 'bottom');
      }

      if (typeof prefs.mode === 'string') {
        const fallbackMode = ['auto', 'marquee', 'chunk'].includes(String(prefs.mode).toLowerCase())
          ? String(prefs.mode).toLowerCase()
          : normalised.mode;
        normalised.mode = typeof sharedNormaliseMode === 'function'
          ? sharedNormaliseMode(prefs.mode) || normalised.mode
          : fallbackMode;
      }

      if (typeof prefs.accentAnim === 'boolean') {
        normalised.accentAnim = prefs.accentAnim;
      }

      if (typeof prefs.sparkle === 'boolean') {
        normalised.sparkle = prefs.sparkle;
      }

      if (typeof prefs.theme === 'string') {
        const normalisedTheme = typeof sharedNormaliseTheme === 'function'
          ? sharedNormaliseTheme(prefs.theme)
          : String(prefs.theme).trim().toLowerCase();
        const candidate = typeof normalisedTheme === 'string'
          ? normalisedTheme.trim().toLowerCase()
          : '';
        if (candidate && THEME_OPTIONS.includes(candidate)) {
          normalised.theme = candidate;
        }
      }

      const limited = {};
      for (const key of allowedKeys) {
        if (Object.prototype.hasOwnProperty.call(normalised, key)) {
          const value = normalised[key];
          if (value !== undefined) {
            limited[key] = value;
          }
        }
      }

      return Object.keys(limited).length ? limited : null;
    }

    function buildScenePayload(name, existingId, fallbackName = '') {
      const baseName = sanitiseTextInput(name || fallbackName, {
        maxLength: MAX_SCENE_NAME_LENGTH,
        fallback: ''
      });
      if (!baseName) {
        toast('Enter a scene name');
        return null;
      }
      const trimmedName = baseName;
      const tickerResult = sanitiseMessagesFn(state.messages, { includeMeta: true });
      const messages = tickerResult.messages;
      const popup = normalisePopupDataFn(popupState);
      if (!messages.length && !popup.text) {
        toast('Add messages or popup text before saving a scene');
        return null;
      }
      if (tickerResult.trimmed || tickerResult.truncated) {
        const notes = [];
        if (tickerResult.trimmed) notes.push(`trimmed ${tickerResult.trimmed}`);
        if (tickerResult.truncated) notes.push(`skipped ${tickerResult.truncated}`);
        if (notes.length) toast(`Scene adjusted • ${notes.join('; ')}`);
      }
      const overlay = buildSceneOverlayPayload(overlayPrefs);
      const payload = {
        id: existingId || generateClientId('scene'),
        name: trimmedName,
        ticker: {
          messages,
          displayDuration: state.displayDuration,
          intervalBetween: minutesToSeconds(state.intervalMinutes),
          isActive: state.isActive && messages.length > 0
        },
        popup: {
          text: popup.text,
          isActive: popup.isActive,
          durationSeconds: popup.durationSeconds,
          countdownEnabled: popup.countdownEnabled,
          countdownTarget: popup.countdownTarget
        },
        slate: serialiseSlateState(),
        updatedAt: Date.now()
      };
      if (overlay) {
        payload.overlay = overlay;
      }
      return payload;
    }

    function normaliseSceneForComparison(scene, { ignoreName = false } = {}) {
      if (!scene) return null;
      const comparable = {
        ticker: scene.ticker || null,
        popup: scene.popup || null,
        slate: scene.slate || null,
        overlay: scene.overlay || null
      };
      if (!ignoreName) {
        comparable.name = String(scene.name || '').trim();
      }
      return comparable;
    }

    function scenesAreEquivalent(a, b, options = {}) {
      if (!a || !b) return false;
      const normalisedA = normaliseSceneForComparison(a, options);
      const normalisedB = normaliseSceneForComparison(b, options);
      return JSON.stringify(normalisedA) === JSON.stringify(normalisedB);
    }

    function scenesShareTickerMessages(a, b) {
      if (!a || !b) return false;
      const messagesA = Array.isArray(a && a.ticker && a.ticker.messages) ? a.ticker.messages : [];
      const messagesB = Array.isArray(b && b.ticker && b.ticker.messages) ? b.ticker.messages : [];
      if (!messagesA.length && !messagesB.length) {
        return false;
      }
      if (messagesA.length !== messagesB.length) {
        return false;
      }
      return JSON.stringify(messagesA) === JSON.stringify(messagesB);
    }

    function generateUniqueSceneName(baseName) {
      const normalised = String(baseName || '').trim();
      const trimmedBase = normalised.slice(0, MAX_SCENE_NAME_LENGTH);
      if (!trimmedBase) return trimmedBase;
      const existingNames = new Set(
        scenes.map(scene => String(scene.name || '').trim().toLowerCase())
      );
      const lowerBase = trimmedBase.toLowerCase();
      if (!existingNames.has(lowerBase)) {
        return trimmedBase;
      }
      for (let suffix = 2; suffix < 1000; suffix += 1) {
        const label = ` (${suffix})`;
        const limit = Math.max(0, MAX_SCENE_NAME_LENGTH - label.length);
        const truncatedBase = trimmedBase.slice(0, limit).trimEnd();
        const candidate = `${truncatedBase}${label}`;
        const lowerCandidate = candidate.toLowerCase();
        if (!existingNames.has(lowerCandidate)) {
          return candidate;
        }
      }
      return trimmedBase;
    }

    async function persistScenes(successMessage = 'Scene saved') {
      if (scenesSaveInFlight) {
        pendingSceneMessage = successMessage;
        return;
      }
      const base = serverBase();
      scenesSaveInFlight = true;
      try {
        await runQueued(mutationQueues.scenes, async () => {
          try {
            const data = await requestJson(`${base}/ticker/scenes`, {
              init: {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ scenes })
              },
              validate: validateScenesMutation
            });
            if (data && Array.isArray(data.scenes)) {
              applyScenesData(data.scenes);
            }
            toast(successMessage);
          } catch (err) {
            console.error('Failed to save scenes', err);
            toast(resolveErrorMessage(err, 'Failed to save scenes'));
            markErrorHandled(err);
            throw err;
          }
        });
      } catch (err) {
        if (!isErrorHandled(err)) {
          console.error('Scenes persistence failed', err);
          toast(resolveErrorMessage(err, 'Failed to save scenes'));
        }
      } finally {
        scenesSaveInFlight = false;
        if (pendingSceneMessage) {
          const message = pendingSceneMessage;
          pendingSceneMessage = null;
          void persistScenes(message);
        }
      }
    }

    async function activateScene(scene) {
      const base = serverBase();
      try {
        await runQueued(mutationQueues.scenes, async () => {
          try {
            await requestJson(`${base}/ticker/scenes/apply`, {
              init: {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sceneId: scene.id })
              },
              validate: validateSceneActivation
            });
            toast(`Activated scene “${scene.name}”`);
          } catch (err) {
            console.error('Failed to activate scene', err);
            toast(resolveErrorMessage(err, 'Failed to activate scene'));
            markErrorHandled(err);
            throw err;
          }
        });
      } catch (err) {
        if (!isErrorHandled(err)) {
          console.error('Scene activation failed', err);
          toast(resolveErrorMessage(err, 'Failed to activate scene'));
        }
      }
    }

    function saveScenePreset(existing) {
      const rawName = el.sceneName ? el.sceneName.value : '';
      const cleanedName = sanitiseTextInput(rawName, {
        maxLength: MAX_SCENE_NAME_LENGTH,
        fallback: ''
      });
      if (el.sceneName && cleanedName !== rawName) {
        el.sceneName.value = cleanedName;
      }
      const existingId = existing && existing.id ? existing.id : null;
      const existingName = existing && existing.name ? existing.name : '';
      const payload = buildScenePayload(cleanedName || rawName, existingId || null, existingName || '');
      if (!payload) return;
      const existingScene = existing
        ? scenes.find(scene => scene.id === existing.id)
        : null;
      if (existingScene && scenesAreEquivalent(existingScene, payload)) {
        toast('No changes detected. Reuse the existing scene instead of saving.');
        return;
      }
      const duplicateScene = scenes.find(scene => scene.id !== payload.id && scenesAreEquivalent(scene, payload));
      if (duplicateScene) {
        toast(`Scene matches existing preset “${duplicateScene.name}”. Reuse it instead of saving a duplicate.`);
        return;
      }
      if (existingScene) {
        const confirmMessage = `Replace “${existingScene.name}” with the current configuration?`;
        if (!confirm(confirmMessage)) {
          toast('Scene save cancelled');
          return;
        }
        {
          const updatedScenes = scenes.map(scene => (scene.id === existingScene.id ? payload : scene));
          scenes.length = 0;
          scenes.push(...updatedScenes);
        }
        persistScenes('Scene updated');
      } else {
        const contentTwin = scenes.find(scene =>
          scene.id !== payload.id && scenesAreEquivalent(scene, payload, { ignoreName: true })
        );
        if (contentTwin) {
          const confirmMessage = contentTwin.name
            ? `Another scene (“${contentTwin.name}”) already has the same content. Save anyway?`
            : 'Another scene already has the same content. Save anyway?';
          if (!confirm(confirmMessage)) {
            toast('Scene save cancelled');
            return;
          }
        }
        const nameDuplicate = scenes.find(scene =>
          scene.name && payload.name && scene.name.trim().toLowerCase() === payload.name.trim().toLowerCase()
        );
        if (nameDuplicate) {
          if (!confirm(`A scene named “${payload.name}” already exists. Keep the same name?`)) {
            const uniqueName = generateUniqueSceneName(payload.name);
            if (!uniqueName) {
              toast('Scene save cancelled');
              return;
            }
            if (uniqueName === payload.name) {
              toast('Scene save cancelled');
              return;
            }
            payload.name = uniqueName;
            toast(`Scene renamed to “${payload.name}”.`);
          }
        }
        const mostRecent = scenes[0];
        if (mostRecent && scenesShareTickerMessages(mostRecent, payload)) {
          toast(`Heads-up: the message queue matches the most recent preset “${mostRecent.name}”.`);
        }
        scenes.unshift(payload);
        persistScenes('Scene saved');
      }
      if (el.sceneName) el.sceneName.value = '';
    }

    function handleSceneAction(event) {
      const button = event.target.closest('button[data-action]');
      if (!button) return;
      const card = button.closest('.scene-card');
      if (!card) return;
      const id = card.dataset.id;
      const scene = scenes.find(item => item.id === id);
      if (!scene) return;
      switch (button.dataset.action) {
        case 'activate':
          void activateScene(scene);
          break;
        case 'replace':
          saveScenePreset(scene);
          break;
        case 'delete':
          {
            const filteredScenes = scenes.filter(item => item.id !== id);
            scenes.length = 0;
            scenes.push(...filteredScenes);
          }
          persistScenes('Scene removed');
          break;
      }
    }

    function registerEventHandlers() {

      if (handlersRegistered) return;
      handlersRegistered = true;

      var on = addManagedEventListener;

      // Defensive: log missing elements and bail early for critical ones
      var criticalElements = ['messageForm', 'newMessage', 'serverUrl'];
      for (var i = 0; i < criticalElements.length; i++) {
        var key = criticalElements[i];
        if (!el[key]) {
          console.error('[Ticker] Critical element missing: ' + key);
          return;
        }
      }

      for (const [key, value] of Object.entries(el)) {
        if (!value) {
          console.warn(`[Ticker] Missing DOM element: el.${key}`);
        }
      }

      if (panelTabButtons.size) {
        panelTabButtons.forEach(function(tab, id) {
          if (!tab) return;
          tab.tabIndex = id === activePanelId ? 0 : -1;
          on(tab, 'click', function() {
            setActivePanel(id);
          });
          on(tab, 'keydown', function(event) {
            switch (event.key) {
              case 'ArrowRight':
              case 'ArrowDown':
                event.preventDefault();
                focusAdjacentPanel(id, 1);
                break;
              case 'ArrowLeft':
              case 'ArrowUp':
                event.preventDefault();
                focusAdjacentPanel(id, -1);
                break;
              case 'Home':
                event.preventDefault();
                {
                  const ids = orderedPanelIds();
                  if (!ids.length) break;
                  const firstId = ids[0];
                  setActivePanel(firstId);
                  const firstTab = panelTabButtons.get(firstId);
                  if (firstTab && typeof firstTab.focus === 'function') {
                    firstTab.focus();
                  }
                }
                break;
              case 'End':
                event.preventDefault();
                {
                  const ids = orderedPanelIds();
                  if (!ids.length) break;
                  const lastId = ids[ids.length - 1];
                  setActivePanel(lastId);
                  const lastTab = panelTabButtons.get(lastId);
                  if (lastTab && typeof lastTab.focus === 'function') {
                    lastTab.focus();
                  }
                }
                break;
              default:
                break;
            }
          });
        }
        setActivePanel(activePanelId, { skipSave: true, force: true });
      }

      if (el.previewFrame) {
        on(el.previewFrame, 'load', () => {
          setPreviewLoading(false);
        });
        on(el.previewFrame, 'error', () => {
          setPreviewLoading(false);
          toast('Preview failed to load');
        });
      }

      if (el.overlayChip) {
        el.overlayChip.addEventListener('click', async () => {
          const url = buildOverlayUrl();
          if (!navigator || !navigator.clipboard || typeof navigator.clipboard.writeText !== 'function') {
            toast('Clipboard unavailable');
            return;
          }
          try {
            await navigator.clipboard.writeText(url);
            toast('Overlay URL copied');
          } catch (err) {
            console.warn('Clipboard copy failed', err);
            toast('Copy failed');
          }
        });
      }

      if (el.copyOverlay) {
        el.copyOverlay.addEventListener('click', async () => {
          const url = buildOverlayUrl();
          if (!navigator || !navigator.clipboard || typeof navigator.clipboard.writeText !== 'function') {
            toast('Clipboard unavailable');
            return;
          }
          try {
            await navigator.clipboard.writeText(url);
            toast('Overlay URL copied');
          } catch (err) {
            toast('Copy failed');
          }
        });
      }

      if (el.openOverlay) {
        el.openOverlay.addEventListener('click', () => {
          const url = buildOverlayUrl();
          if (!url) {
            toast('Overlay URL unavailable');
            return;
          }
          try {
            window.open(url, '_blank', 'noopener');
          } catch (err) {
            console.warn('Failed to open overlay URL', err);
            toast('Unable to open overlay');
          }
        });
      }

      if (el.reloadPreview) {
        el.reloadPreview.addEventListener('click', () => {
          const url = buildOverlayUrl();
          uiState.lastPreviewUrl = url;
          schedulePreviewUpdate(url);
        });
      }

      if (el.serverUrl) {
        el.serverUrl.addEventListener('change', () => {
          console.log('[DEBUG] Server URL changed to:', el.serverUrl.value);
          const cleaned = sanitiseServerUrlInput(el.serverUrl.value);
          if (cleaned && cleaned !== el.serverUrl.value) {
            safeSetValue(el.serverUrl, cleaned);
          } else if (!cleaned) {
            safeSetValue(el.serverUrl, '');
          }
          saveLocal();
          console.log('[DEBUG] Attempting to connect with URL:', serverBase());
          void connectStream({ reason: 'server-url-change' });
          void fetchState({ silent: true });
          updateOverlayChip();
        });
      }

      if (el.stateExport) {
        el.stateExport.addEventListener('click', async () => {
          if (!confirm('Export the full dashboard state as a JSON download?')) {
            return;
          }
          const base = serverBase();
          try {
            const blob = await requestBlob(`${base}/ticker/state/export`, {
              init: { cache: 'no-store' }
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ticker-state.json';
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 500);
            toast('State exported');
          } catch (err) {
            console.error('State export failed', err);
            toast('Failed to export state');
          }
        });
      }

      if (el.stateImport) {
        el.stateImport.addEventListener('click', () => {
          if (!el.stateImportInput) return;
          el.stateImportInput.value = '';
          el.stateImportInput.click();
        });
      }

      if (el.stateImportInput) {
        el.stateImportInput.addEventListener('change', async () => {
          const file = el.stateImportInput.files && el.stateImportInput.files[0];
          if (!file) return;
          if (!confirm(`Import "${file.name}" and replace the current dashboard state?`)) {
            el.stateImportInput.value = '';
            return;
          }
          try {
            const text = await file.text();
            let parsed;
            try {
              parsed = JSON.parse(text);
            } catch (err) {
              throw new Error('Selected file is not valid JSON');
            }
            const base = serverBase();
            await requestJson(`${base}/ticker/state/import`, {
              init: {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(parsed)
              },
              validate: validateStateImport
            });
            await fetchState({ silent: false });
            toast('State imported');
          } catch (err) {
            console.error('State import failed', err);
            toast(err.message || 'Failed to import state');
          } finally {
            el.stateImportInput.value = '';
          }
        });
      }

      if (el.autoStart) {
        el.autoStart.addEventListener('change', () => {
          saveLocal();
        });
      }

      if (el.duration) {
        el.duration.addEventListener('change', () => {
          state.displayDuration = clampDuration(el.duration.value);
          renderTicker();
          queueSave();
        });
      }

      if (el.interval) {
        el.interval.addEventListener('change', () => {
          state.intervalMinutes = clampMinutesValue(el.interval.value);
          renderTicker();
          queueSave();
        });
      }

      if (el.startBtn) {
        el.startBtn.addEventListener('click', () => {
          if (!state.messages.length) {
            toast('Add at least one message first');
            return;
          }
          state.isActive = true;
          renderTicker();
          queueSave();
        });
      }

      if (el.stopBtn) {
        el.stopBtn.addEventListener('click', () => {
          state.isActive = false;
          renderTicker();
          queueSave();
        });
      }

      if (el.refreshBtn) {
        el.refreshBtn.addEventListener('click', () => void fetchState({ silent: true }));
      }

      if (el.overlayLabel) {
        on(el.overlayLabel, 'input', () => {
          const cleaned = sanitiseTextInput(el.overlayLabel.value, {
            maxLength: MAX_OVERLAY_LABEL_LENGTH,
            fallback: 'LIVE'
          }) || 'LIVE';
          if (el.overlayLabel.value !== cleaned) {
            el.overlayLabel.value = cleaned;
          }
          overlayPrefs.label = cleaned;
          updateOverlayChip();
          saveLocal();
          queueOverlaySave();
        });
      }

      const ACCENT_LENGTH_ERROR = `Colour values must be ${ACCENT_MAX_LENGTH} characters or fewer.`;
      const ACCENT_SECONDARY_LENGTH_ERROR = `Colour values must be ${ACCENT_MAX_LENGTH} characters or fewer. Clear the field to remove this colour.`;

    function commitAccentInput(nextValue) {
      if (!el.overlayAccent) return;
      const rawValue = typeof nextValue === 'string' ? nextValue : el.overlayAccent.value;
      const trimmed = rawValue.trim();
      if (!trimmed) {
        const changed = overlayPrefs.accent !== '';
        overlayPrefs.accent = '';
        updateAccentInputsFromPrefs();
        setAccentError('');
        applyPreviewTheme();
        if (changed) {
          updateOverlayChip();
          saveLocal();
          queueOverlaySave();
        }
        return;
      }
      if (trimmed.length > ACCENT_MAX_LENGTH) {
        if (el.overlayAccent) {
          el.overlayAccent.value = trimmed;
        }
        setAccentError(ACCENT_LENGTH_ERROR);
        if (el.overlayAccentPicker) {
          el.overlayAccentPicker.value = parseHexForPicker(overlayPrefs.accent) || ACCENT_FALLBACK_HEX;
        }
        return;
      }
      if (!isSafeColour(trimmed)) {
        if (el.overlayAccent) {
          el.overlayAccent.value = trimmed;
        }
        setAccentError('Enter a valid CSS colour value.');
        if (el.overlayAccentPicker) {
          el.overlayAccentPicker.value = parseHexForPicker(overlayPrefs.accent) || ACCENT_FALLBACK_HEX;
        }
        return;
      }
      setAccentError('');
      const changed = trimmed !== overlayPrefs.accent;
      overlayPrefs.accent = trimmed;
      updateAccentInputsFromPrefs();
      if (changed) {
        updateOverlayChip();
        saveLocal();
        queueOverlaySave();
      }
      applyPreviewTheme();
    }

    function commitAccentSecondaryInput(nextValue) {
      if (!el.overlayAccentSecondary) return;
      const rawValue = typeof nextValue === 'string' ? nextValue : el.overlayAccentSecondary.value;
      const trimmed = rawValue.trim();
      if (!trimmed) {
        const changed = overlayPrefs.accentSecondary !== '';
        overlayPrefs.accentSecondary = '';
        updateAccentInputsFromPrefs();
        setAccentSecondaryError('');
        applyPreviewTheme();
        if (changed) {
          updateOverlayChip();
          saveLocal();
          queueOverlaySave();
        }
        return;
      }
      if (trimmed.length > ACCENT_MAX_LENGTH) {
        if (el.overlayAccentSecondary) {
          el.overlayAccentSecondary.value = trimmed;
        }
        setAccentSecondaryError(ACCENT_SECONDARY_LENGTH_ERROR);
        if (el.overlayAccentSecondaryPicker) {
          el.overlayAccentSecondaryPicker.value = parseHexForPicker(overlayPrefs.accentSecondary) || ACCENT_SECONDARY_FALLBACK_HEX;
        }
        return;
      }
      if (!isSafeColour(trimmed)) {
        if (el.overlayAccentSecondary) {
          el.overlayAccentSecondary.value = trimmed;
        }
        setAccentSecondaryError('Enter a valid CSS colour value or clear the field.');
        if (el.overlayAccentSecondaryPicker) {
          el.overlayAccentSecondaryPicker.value = parseHexForPicker(overlayPrefs.accentSecondary) || ACCENT_SECONDARY_FALLBACK_HEX;
        }
        return;
      }
      setAccentSecondaryError('');
      const changed = trimmed !== overlayPrefs.accentSecondary;
      overlayPrefs.accentSecondary = trimmed;
      updateAccentInputsFromPrefs();
      if (changed) {
        updateOverlayChip();
        saveLocal();
        queueOverlaySave();
      }
      applyPreviewTheme();
    }

      if (el.overlayAccent) {
        el.overlayAccent.addEventListener('input', () => commitAccentInput());
        el.overlayAccent.addEventListener('change', () => commitAccentInput());
        el.overlayAccent.addEventListener('blur', () => commitAccentInput());
      }
      if (el.overlayAccentPicker) {
        el.overlayAccentPicker.addEventListener('input', event => {
          setAccentError('');
          commitAccentInput(event.target.value);
        });
      }

      if (el.overlayAccentSecondary) {
        el.overlayAccentSecondary.addEventListener('input', () => commitAccentSecondaryInput());
        el.overlayAccentSecondary.addEventListener('change', () => commitAccentSecondaryInput());
        el.overlayAccentSecondary.addEventListener('blur', () => commitAccentSecondaryInput());
      }
      if (el.overlayAccentSecondaryPicker) {
        el.overlayAccentSecondaryPicker.addEventListener('input', event => {
          setAccentSecondaryError('');
          commitAccentSecondaryInput(event.target.value);
        });
      }

      if (el.highlightWords) {
        el.highlightWords.addEventListener('input', () => {
          const raw = el.highlightWords.value;
          updateHighlightHint(raw);
          const normalised = normaliseHighlightInputFn(raw);
          const changed = overlayPrefs.highlight !== normalised;
          overlayPrefs.highlight = normalised;
          if (changed) {
            updateHighlightRegex();
            renderMessages();
            renderPopupControls();
            updateOverlayChip();
            saveLocal();
            queueOverlaySave();
          }
        });
        el.highlightWords.addEventListener('blur', () => {
          el.highlightWords.value = overlayPrefs.highlight;
          updateHighlightHint(overlayPrefs.highlight);
        });
      }

      if (el.slateEnabled) {
        el.slateEnabled.addEventListener('change', () => {
          updateSlateBoolean('isEnabled', el.slateEnabled.checked);
        });
      }
      if (el.slateShowClock) {
        el.slateShowClock.addEventListener('change', () => {
          updateSlateBoolean('showClock', el.slateShowClock.checked);
        });
      }
      if (el.slateRotation) {
        el.slateRotation.addEventListener('input', () => {
          updateSlateRotationInput(el.slateRotation.value);
        });
        el.slateRotation.addEventListener('change', () => {
          updateSlateRotationInput(el.slateRotation.value);
        });
      }
      if (el.slateRotationNumber) {
        const commitRotationNumber = () => {
          updateSlateRotationInput(el.slateRotationNumber.value);
        };
        el.slateRotationNumber.addEventListener('input', commitRotationNumber);
        el.slateRotationNumber.addEventListener('change', commitRotationNumber);
        el.slateRotationNumber.addEventListener('blur', () => {
          el.slateRotationNumber.value = String(clampSlateRotation(el.slateRotationNumber.value));
        });
      }
      if (el.slateClockLabel) {
        el.slateClockLabel.addEventListener('input', () => {
          updateSlateTextField('clockLabel', el.slateClockLabel.value, MAX_SLATE_TITLE_LENGTH);
        });
        el.slateClockLabel.addEventListener('blur', () => {
          el.slateClockLabel.value = slateState.clockLabel || '';
        });
      }
      if (el.slateClockSubtitle) {
        el.slateClockSubtitle.addEventListener('input', () => {
          updateSlateTextField('clockSubtitle', el.slateClockSubtitle.value, MAX_SLATE_TEXT_LENGTH);
        });
        el.slateClockSubtitle.addEventListener('blur', () => {
          el.slateClockSubtitle.value = slateState.clockSubtitle || '';
        });
      }
      if (el.slateNextLabel) {
        el.slateNextLabel.addEventListener('input', () => {
          updateSlateTextField('nextLabel', el.slateNextLabel.value, MAX_SLATE_TITLE_LENGTH);
        });
        el.slateNextLabel.addEventListener('blur', () => {
          el.slateNextLabel.value = slateState.nextLabel || '';
        });
      }
      if (el.slateNextTitle) {
        el.slateNextTitle.addEventListener('input', () => {
          updateSlateTextField('nextTitle', el.slateNextTitle.value, MAX_SLATE_TITLE_LENGTH);
        });
        el.slateNextTitle.addEventListener('blur', () => {
          el.slateNextTitle.value = slateState.nextTitle || '';
        });
      }
      if (el.slateNextSubtitle) {
        el.slateNextSubtitle.addEventListener('input', () => {
          updateSlateTextField('nextSubtitle', el.slateNextSubtitle.value, MAX_SLATE_TEXT_LENGTH);
        });
        el.slateNextSubtitle.addEventListener('blur', () => {
          el.slateNextSubtitle.value = slateState.nextSubtitle || '';
        });
      }
      if (el.slateSponsorLabel) {
        el.slateSponsorLabel.addEventListener('input', () => {
          updateSlateTextField('sponsorLabel', el.slateSponsorLabel.value, MAX_SLATE_TITLE_LENGTH);
        });
        el.slateSponsorLabel.addEventListener('blur', () => {
          el.slateSponsorLabel.value = slateState.sponsorLabel || '';
        });
      }
      if (el.slateSponsorName) {
        el.slateSponsorName.addEventListener('input', () => {
          updateSlateTextField('sponsorName', el.slateSponsorName.value, MAX_SLATE_TITLE_LENGTH);
        });
        el.slateSponsorName.addEventListener('blur', () => {
          el.slateSponsorName.value = slateState.sponsorName || '';
        });
      }
      if (el.slateSponsorTagline) {
        el.slateSponsorTagline.addEventListener('input', () => {
          updateSlateTextField('sponsorTagline', el.slateSponsorTagline.value, MAX_SLATE_TEXT_LENGTH);
        });
        el.slateSponsorTagline.addEventListener('blur', () => {
          el.slateSponsorTagline.value = slateState.sponsorTagline || '';
        });
      }
      if (el.slateNotesLabel) {
        el.slateNotesLabel.addEventListener('input', () => {
          updateSlateTextField('notesLabel', el.slateNotesLabel.value, MAX_SLATE_TITLE_LENGTH);
        });
        el.slateNotesLabel.addEventListener('blur', () => {
          el.slateNotesLabel.value = slateState.notesLabel || '';
        });
      }
      if (el.slateNotes) {
        el.slateNotes.addEventListener('input', () => {
          updateSlateNotes(el.slateNotes.value);
        });
        el.slateNotes.addEventListener('blur', () => {
          el.slateNotes.value = Array.isArray(slateState.notes) ? slateState.notes.join('\n') : '';
        });
      }
      if (el.slatePreviewDots) {
        el.slatePreviewDots.addEventListener('click', event => {
          const dot = event.target.closest('.slate-preview-dot');
          if (!dot) return;
          const index = Number(dot.dataset.index);
          if (!Number.isFinite(index) || index < 0 || index >= slatePreviewCards.length) return;
          slatePreviewIndex = index;
          playSlatePreviewCard(index, { animate: true, updateDots: true });
        });
      }

      if (el.popupText) {
        el.popupText.addEventListener('input', () => {
          updatePopupPreview();
          if (!el.popupText.value.trim() && el.popupActive) {
            el.popupActive.checked = false;
          }
          popupHasPendingLocalChanges = true;
          updatePanelBusyStates();
        });
      }

      if (el.popupDuration) {
        el.popupDuration.addEventListener('change', () => {
          popupHasPendingLocalChanges = true;
          updatePanelBusyStates();
          queuePopupSave();
        });
      }

      if (el.popupCountdownTarget) {
        el.popupCountdownTarget.addEventListener('input', () => {
          if (el.popupCountdownEnabled && el.popupCountdownEnabled.checked) {
            updatePopupPreview();
          }
          popupHasPendingLocalChanges = true;
          updatePanelBusyStates();
        });
        el.popupCountdownTarget.addEventListener('change', () => {
          if (el.popupCountdownEnabled && el.popupCountdownEnabled.checked) {
            popupHasPendingLocalChanges = true;
            updatePanelBusyStates();
            queuePopupSave();
          }
        });
      }

      if (el.popupCountdownEnabled) {
        el.popupCountdownEnabled.addEventListener('change', () => {
          if (el.popupCountdownEnabled.checked) {
            if (!el.popupText.value.trim()) {
              el.popupCountdownEnabled.checked = false;
              toast('Enter popup text before enabling the countdown');
              return;
            }
            if (!el.popupCountdownTarget || !el.popupCountdownTarget.value) {
              toast('Select a countdown target time');
            }
          }
          updatePopupPreview();
          if (el.popupCountdownTarget) {
            el.popupCountdownTarget.disabled = popupSaveInFlight || !el.popupCountdownEnabled.checked;
          }
          const hasTarget = el.popupCountdownTarget && el.popupCountdownTarget.value;
          if (!el.popupCountdownEnabled.checked || hasTarget) {
            popupHasPendingLocalChanges = true;
            updatePanelBusyStates();
            queuePopupSave();
          }
        });
      }

      if (el.popupActive) {
        el.popupActive.addEventListener('change', () => {
          if (el.popupActive.checked && (!el.popupText || !el.popupText.value.trim())) {
            el.popupActive.checked = false;
            toast('Enter popup text before enabling');
            return;
          }
          popupHasPendingLocalChanges = true;
          updatePanelBusyStates();
          queuePopupSave();
        });
      }

      if (el.savePopup) {
        el.savePopup.addEventListener('click', () => {
          popupHasPendingLocalChanges = true;
          updatePanelBusyStates();
          queuePopupSave();
        });
      }

      if (el.clearPopup) {
        el.clearPopup.addEventListener('click', () => {
          if ((!el.popupText || !el.popupText.value) && !popupState.text) {
            if (el.popupActive) el.popupActive.checked = false;
            updatePopupPreview();
            updatePopupMeta();
            return;
          }
          if (!confirm('Clear the popup message?')) {
            return;
          }
          if (el.popupText) el.popupText.value = '';
          if (el.popupActive) el.popupActive.checked = false;
          updatePopupPreview();
          Object.assign(popupState, {
            text: '',
            isActive: false,
            durationSeconds: null,
            countdownEnabled: false,
            countdownTarget: null,
            updatedAt: Date.now()
          });
          popupHasPendingLocalChanges = true;
          updatePanelBusyStates();
          queuePopupSave();
        });
      }

      if (el.brbText) {
        el.brbText.addEventListener('input', () => {
          if (!el.brbText.value.trim() && el.brbActive) {
            el.brbActive.checked = false;
          }
        });
      }

      if (el.brbSave) {
        el.brbSave.addEventListener('click', () => {
          queueBrbSave();
        });
      }

      if (el.brbClear) {
        el.brbClear.addEventListener('click', () => {
          const hasBrbInput = el.brbText && el.brbText.value.trim().length > 0;
          const hasBrbState = brbState.text && brbState.text.trim().length > 0;
          const brbActive = (el.brbActive && el.brbActive.checked) || brbState.isActive;

          if (hasBrbInput || hasBrbState || brbActive) {
            if (!confirm('Clear the BRB message?')) {
              return;
            }
          }

          if (el.brbText) el.brbText.value = '';
          if (el.brbActive) el.brbActive.checked = false;
          Object.assign(brbState, { text: '', isActive: false, updatedAt: Date.now() });
          renderBrbControls();
          queueBrbSave();
        });
      }

      if (el.brbActive) {
        el.brbActive.addEventListener('change', () => {
          if (el.brbActive.checked && (!el.brbText || !el.brbText.value.trim())) {
            el.brbActive.checked = false;
            toast('Enter BRB text before enabling');
            return;
          }
          queueBrbSave();
        });
      }

      const overlayPanelEl = panelSections.get('overlayPanel');
      const debouncedScaleUpdate = createDebounced(value => updateScale(value), 32);
      const debouncedPopupScaleUpdate = createDebounced(value => updatePopupScale(value), 32);

      if (overlayPanelEl) {
        overlayPanelEl.addEventListener('input', event => {
          const target = event.target;
          if (!target) return;
          if (target.matches('#scaleRange')) {
            debouncedScaleUpdate(target.value);
          } else if (target.matches('#scaleNumber')) {
            if (target.value === '') return;
            debouncedScaleUpdate(target.value);
          } else if (target.matches('#popupScaleRange')) {
            debouncedPopupScaleUpdate(target.value);
          } else if (target.matches('#popupScaleNumber')) {
            if (target.value === '') return;
            debouncedPopupScaleUpdate(target.value);
          }
        });
        overlayPanelEl.addEventListener('change', event => {
          const target = event.target;
          if (!target) return;
          if (target.matches('#scaleNumber')) {
            if (target.value === '') return;
            debouncedScaleUpdate(target.value);
          } else if (target.matches('#popupScaleNumber')) {
            if (target.value === '') return;
            debouncedPopupScaleUpdate(target.value);
          }
        });
      }

      if (el.positionButtons) {
        el.positionButtons.addEventListener('click', event => {
          const button = event.target.closest('button[data-position]');
          if (!button) return;
          setPosition(button.dataset.position);
        });
      }

      if (el.modeButtons) {
        el.modeButtons.addEventListener('click', event => {
          const button = event.target.closest('button[data-mode]');
          if (!button) return;
          setMode(button.dataset.mode);
        });
      }

      if (el.themeButtons) {
        el.themeButtons.addEventListener('click', event => {
          const button = event.target.closest('button[data-theme]');
          if (!button) return;
          setTheme(button.dataset.theme);
        });
      }

      if (el.accentAnim) {
        el.accentAnim.addEventListener('change', () => {
          overlayPrefs.accentAnim = el.accentAnim.checked;
          updateOverlayChip();
          saveLocal();
          queueOverlaySave();
        });
      }

      if (el.sparkle) {
        el.sparkle.addEventListener('change', () => {
          overlayPrefs.sparkle = el.sparkle.checked;
          updateOverlayChip();
          saveLocal();
          queueOverlaySave();
        });
      }

      if (el.messageForm && el.newMessage) {
        el.messageForm.addEventListener('submit', function(event) {
          event.preventDefault();
          
          try {
            var message = el.newMessage.value.trim();
            if (!message) {
              ToastManager.error('Please enter a message before adding');
              return;
            }
            
            LoadingManager.show('Adding message...');
            var added = addMessage(message);
            LoadingManager.hide();
            
            if (added) {
              el.newMessage.value = '';
              ToastManager.success('Message added successfully');
            }
            el.newMessage.focus();
          } catch (error) {
            LoadingManager.hide();
            handleNetworkError(error, 'Add Message');
          }
        });
      } else {
        console.error('Message form or input not found:', { form: !!el.messageForm, input: !!el.newMessage });
        ToastManager.error('Message form not found - please refresh the page');
      }

      if (el.clearMessages) {
        el.clearMessages.addEventListener('click', () => {
          if (!state.messages.length) return;
          if (confirm('Clear all messages?')) {
            state.messages = [];
            state.isActive = false;
            renderMessages();
            renderTicker();
            queueSave();
          }
        });
      }

      if (el.exportMessages) {
        el.exportMessages.addEventListener('click', () => {
          const blob = new Blob([JSON.stringify({ messages: state.messages }, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'ticker-messages.json';
          a.click();
          URL.revokeObjectURL(url);
        });
      }

      if (el.importMessages) {
        el.importMessages.addEventListener('click', () => {
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = 'application/json';
          input.onchange = async () => {
            const file = input.files && input.files[0];
            if (!file) return;
            try {
              const text = await file.text();
              const data = JSON.parse(text);
              if (Array.isArray(data.messages)) {
                const result = sanitiseMessagesFn(data.messages, { includeMeta: true });
                state.messages = result.messages;
                if (el.autoStart && el.autoStart.checked && state.messages.length) state.isActive = true;
                renderMessages();
                renderTicker();
                queueSave();
                const notes = [];
                if (result.truncated) notes.push(`limited to ${MAX_MESSAGES}`);
                if (result.trimmed) notes.push(`trimmed to ${MAX_MESSAGE_LENGTH} chars`);
                const summary = 'Messages imported';
                toast(notes.length ? `${summary} • ${notes.join('; ')}` : summary);
              } else {
                toast('Invalid file format');
              }
            } catch (err) {
              console.error('Failed to import messages', err);
              toast('Import failed');
            }
          };
          input.click();
        });
      }

      if (el.messageList) {
        on(el.messageList, 'click', handleMessageAction);
        on(el.messageList, 'input', event => {
          const textarea = event.target.closest('.message-edit-input');
          if (!textarea) return;
          uiState.editingDraft = textarea.value;
          const row = textarea.closest('.message-item');
          if (row) {
            const preview = row.querySelector('.message-preview');
            if (preview) {
              const html = formatMessage(uiState.editingDraft);
              preview.innerHTML = html || '<span class="small">Preview updates as you type.</span>';
            }
          }
        });
      }

      if (el.savePreset) {
        on(el.savePreset, 'click', () => {
          const rawName = el.presetName ? el.presetName.value : '';
          const cleanedName = sanitiseTextInput(rawName, {
            maxLength: MAX_PRESET_NAME_LENGTH,
            fallback: ''
          });
          if (!cleanedName) {
            toast('Enter a preset name');
            return;
          }
          if (!state.messages.length) {
            toast('Nothing to save');
            return;
          }
          const trimmedOriginal = typeof rawName === 'string' ? rawName.trim() : '';
          if (trimmedOriginal.length > MAX_PRESET_NAME_LENGTH) {
            toast(`Preset names must be ${MAX_PRESET_NAME_LENGTH} characters or fewer`);
            return;
          }
          const existing = presets.find(p => p.name.toLowerCase() === cleanedName.toLowerCase());
          const payload = {
            id: existing ? existing.id : generateClientId('preset'),
            name: cleanedName,
            messages: [...state.messages],
            updatedAt: Date.now()
          };
          if (existing) {
            Object.assign(existing, payload);
          } else {
            presets.unshift(payload);
          }
          if (el.presetName) {
            el.presetName.value = '';
          }
          renderPresets();
          persistPresets();
        });
      }

      if (el.presetList) {
        on(el.presetList, 'click', handlePresetAction);
      }

      if (el.presetModalCancel) {
        on(el.presetModalCancel, 'click', () => closePresetModal({ restoreFocus: true }));
      }
      if (el.presetModalSave) {
        on(el.presetModalSave, 'click', () => confirmPresetModal());
      }
      if (el.presetModalName) {
        on(el.presetModalName, 'keydown', event => {
          if (event.key === 'Enter') {
            event.preventDefault();
            confirmPresetModal();
          } else if (event.key === 'Escape') {
            event.preventDefault();
            closePresetModal({ restoreFocus: true });
          }
        });
        on(el.presetModalName, 'input', () => updatePresetModalError(''));
      }
      if (el.presetModal) {
        on(el.presetModal, 'click', event => {
          if (event.target === el.presetModal) {
            closePresetModal({ restoreFocus: true });
          }
        });
      }
      if (typeof document !== 'undefined') {
        addManagedEventListener(document, 'keydown', event => {
          if (event.key === 'Escape' && isPresetModalOpen()) {
            event.preventDefault();
            closePresetModal({ restoreFocus: true });
          }
        });
      }

      if (el.saveScene) {
        addManagedEventListener(el.saveScene, 'click', () => {
          saveScenePreset();
        });
      }

      if (el.sceneName) {
        addManagedEventListener(el.sceneName, 'keydown', event => {
          if (event.key === 'Enter') {
            event.preventDefault();
            saveScenePreset();
          }
        });
      }

      if (el.sceneList) {
        addManagedEventListener(el.sceneList, 'click', handleSceneAction);
      }

      if (typeof window !== 'undefined') {
        addManagedEventListener(window, 'beforeunload', () => destroyDashboard());
        addManagedEventListener(window, 'pagehide', () => destroyDashboard());
      }
    }

    async function init() {
      if (initStarted) return;
      initStarted = true;
      
      // Initialize UI management systems
      LoadingManager.init();
      ToastManager.init();
      ConnectionManager.init();
      
      LoadingManager.show('Initializing dashboard...');
      
      try {
        initialiseStateStore();
        registerEventHandlers();
        LoadingManager.update('Loading configuration...');
      applyServerStatus('checking', { force: true });
      loadLocal();
      renderOverlayControls();
      updateHighlightRegex();
      renderPopupControls();
      renderBrbControls();
      renderMessages();
      renderTicker();
      renderPresets();
      renderScenes();
      updateOverlayChip();
      LoadingManager.update('Connecting to server...');
      void connectStream({ reason: 'initial' });
      
      // Hide loading after successful initialization
      setTimeout(function() {
        LoadingManager.hide();
        ConnectionManager.setStatus('connected', 'Dashboard ready');
      }, 1000);
      
      } catch (error) {
        LoadingManager.hide();
        handleNetworkError(error, 'Dashboard Initialization');
        ConnectionManager.setStatus('disconnected', 'Initialization failed');
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init, { once: true });
    } else {
      void init();
    }
  </script>
</body>
</html>